<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0"><meta property="og:title" content="基本実験" />
<meta property="og:description" content="かんたんな実験を通じてFPGAでのハードウェア作りの基礎力を手に入れましょう．
はじめに いくつかの簡単なHDLコードを書いて，FPGAでのハードウェア作りの基礎力を手に入れましょう．実際にHDLコードを書き，シミュレーションして，実機動作を確認することは，より複雑なハードウェアを設計するための第一歩です．
ILAを使ってFPGA内部の信号を観測する FPGAは，FPGAの中で回路がどのように動作しているのかを知るためのILA(Internal Logic Analyzer)という仕組みを持っています．実験コードを書きはじめる前に，このILAの使い方を学んでみましょう．
LチカでILAの動作を学ぶ 三度目の登場ですが，LチカでILAの動作を学びましょう．第4章で利用した\verb|project_2|を使用します．
準備 ILAを使ってデバッグするために，topモジュールのソースコードを次のように書き変えてください．
\begin{figure}[H] \begin{quote} \begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top;
architecture RTL of top is
attribute mark_debug : string; &ndash; (1) 追加 signal counter : unsigned(31 downto 0) := (others =&gt; &lsquo;0&rsquo;); attribute mark_debug of counter : signal is &ldquo;true&rdquo;; &ndash; (2) 追加" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://miyo.github.io/learning_fpga/docs/book01/basics/" />
<meta property="article:published_time" content="2019-10-30T19:15:46+09:00" />
<meta property="article:modified_time" content="2019-10-30T19:15:46+09:00" />
<title>基本実験 | Learning FPGA</title>
<link rel="icon" href="/learning_fpga/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/learning_fpga/book.min.92b28337361d2bcca5e0ffaff5092dda7140e89d9a7a7a4dcc6055fd7d702ace.css" integrity="sha256-krKDNzYdK8yl4P&#43;v9Qkt2nFA6J2aenpNzGBV/X1wKs4=">


<script defer src="/learning_fpga/search.min.1b1d8c2a9b30aeee8b43f416ee4725f5fbfad0d3aea16a151e95e3619c0dfdf8.js" integrity="sha256-Gx2MKpswru6LQ/QW7kcl9fv60NOuoWoVHpXjYZwN/fg="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://miyo.github.io/learning_fpga/"><span>Learning FPGA</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    

  
  





 
  
    




  
  <ul>
    
      
        <li>

  <a href="/learning_fpga/docs/book01/introduction/" >
      Introduction
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/languages/" >
      VHDL/Veilog 入門
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/quickstart/" >
      クイックスタート
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/simulation/" >
      シミュレーション
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/basics/"  class="active">
      基本実験
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/experiments/" >
      実験
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/book01/ipi/" >
      IP Integrator入門
  </a>

</li>
      
    
      
        

  <li  class="book-section-flat" >
    
      

  <a href="/learning_fpga/docs/example/" >
      Example Site
  </a>


    

    




  
  <ul>
    
      
        

  <li >
    
      

  <a href="/learning_fpga/docs/example/table-of-contents/" >
      Table of Contents
  </a>


    

    




  
  <ul>
    
      
        <li>

  <a href="/learning_fpga/docs/example/table-of-contents/with-toc/" >
      With ToC
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/example/table-of-contents/without-toc/" >
      Without ToC
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
      
        

  <li >
    
      

  <a href="/learning_fpga/docs/example/2nd/" >
      2nd
  </a>


    

    






  </li>


      
    
  </ul>
  



  </li>


      
    
      
    
      
        

  <li  class="book-section-flat" >
    
      <span>Shortcodes</span>
    

    




  
  <ul>
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/buttons/" >
      Buttons
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/columns/" >
      Columns
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/expand/" >
      Expand
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/hints/" >
      Hints
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/katex/" >
      Katex
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/mermaid/" >
      Mermaid
  </a>

</li>
      
    
      
        <li>

  <a href="/learning_fpga/docs/shortcodes/tabs/" >
      Tabs
  </a>

</li>
      
    
  </ul>
  



  </li>


      
    
  </ul>
  



  











</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/learning_fpga/svg/menu.svg" alt="Menu" />
  </label>
  <strong>基本実験</strong>
</header>

      
<article class="markdown">

<p>かんたんな実験を通じてFPGAでのハードウェア作りの基礎力を手に入れましょう．</p>

<h1 id="はじめに">はじめに</h1>

<p>いくつかの簡単なHDLコードを書いて，FPGAでのハードウェア作りの基礎力を手に入れましょう．実際にHDLコードを書き，シミュレーションして，実機動作を確認することは，より複雑なハードウェアを設計するための第一歩です．</p>

<h1 id="ilaを使ってfpga内部の信号を観測する">ILAを使ってFPGA内部の信号を観測する</h1>

<p>FPGAは，FPGAの中で回路がどのように動作しているのかを知るためのILA(Internal Logic Analyzer)という仕組みを持っています．実験コードを書きはじめる前に，このILAの使い方を学んでみましょう．</p>

<h2 id="lチカでilaの動作を学ぶ">LチカでILAの動作を学ぶ</h2>

<p>三度目の登場ですが，LチカでILAの動作を学びましょう．第4章で利用した\verb|project_2|を使用します．</p>

<h2 id="準備">準備</h2>

<p>ILAを使ってデバッグするために，topモジュールのソースコードを次のように書き変えてください．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
 library ieee;
 use ieee.std_logic_1164.all;
 use ieee.numeric_std.all;</p>

<p>entity top is
    Port ( clk   : in std_logic;
           reset : in std_logic;
           led   : out std_logic
         );
 end top;</p>

<p>architecture RTL of top is</p>

<p>attribute mark_debug : string; &ndash; (1) 追加
  signal counter : unsigned(31 downto 0) := (others =&gt; &lsquo;0&rsquo;);
  attribute mark_debug of counter : signal is &ldquo;true&rdquo;; &ndash; (2) 追加</p>

<p>begin</p>

<p>&ndash; カウンタの3bit目をledに接続(実機では23bit目を使った)
  led &lt;= std_logic(counter(3));</p>

<p>process(clk) &ndash; クロックの変化で動作するプロセス
  begin
    if rising_edge(clk) then &ndash; クロックの立ち上がりであれば
      if reset = &lsquo;1&rsquo; then
        counter &lt;= (others =&gt; &lsquo;0&rsquo;);
      else
        counter &lt;= counter + 1; &ndash; カウンタをインクリメント
      end if;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\caption{ILA実験用に変更したリストの例}
\end{figure}</p>

<p>(1)と(2)が追加ポイントです．(1)で\verb|mark_debug|というattributeを利用することを宣言し，(2)でcounterに\verb|mark_debug|というattributeを付与しています．attributeは，ツールに対する指示子です．Vivadoでは，\verb|mark_debug|を付与した信号はデバッグ対象の可能性があるとして特別扱いします．</p>

<p>コードが準備できたら，一度合成してピン配置まで終わらせてしまいましょう．</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_59_41.png}
  \end{center}
  \caption{I/O Planningでclk，reset，ledのピン配置を決定する}
 \end{figure}</p>

<h2 id="ilaのセットアップと利用方法">ILAのセットアップと利用方法</h2>

<p>準備ができたらILAを追加して，その動作の様子を確認してみましょう．</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_57_01.png}
  \end{center}
  \caption{一度合成する}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_58_37.png}
  \end{center}
  \caption{合成が終わったらOpen Synthesized Designで合成結果を開く}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_00_09.png}
  \end{center}
  \caption{LayoutメニューのDebugをクリックしてデバッグビューに変更する}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_37.png}
  \end{center}
  \caption{ILA設定用の画面 \label{fig:debug_mode_view}}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_43.png}
  \end{center}
  \caption{下にある虫みたいなアイコンをクリックしてILA設定用のウィザードを開く}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_58.png}
  \end{center}
  \caption{ILA設定用ウィザードの開始}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_03.png}
  \end{center}
  \caption{mark_debugを付与したcounterがリストに追加されているので，そのままNextですすむ．ここで新たにILAによる観測対象を追加したい場合には+アイコンをクリックすると信号を選ぶことができる．逆にリストにある信号を対象から取り除きたい場合には，取り除きたい信号を選択して-をクリックする}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_08.png}
  \end{center}
  \caption{ILAで取得するデータ数の設定など．今回はそのままにしてNextですすむ}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_13.png}
  \end{center}
  \caption{サマリの表示．Finishで完了}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_28.png}
  \end{center}
  \caption{ウィザードが閉じてILAの設定は完了．ILAが追加できていることがわかる．あとは，Generate Bitstreamでビットファイルを作成すればよい．}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_33.png}
  \end{center}
  \caption{ILAの設定情報をxdcファイルに保存してよいかの確認．Yesで次のステップにすすむ．}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_44.png}
  \end{center}
  \caption{Generate bitstreamの前に依存する他のタスクを実行します，という確認ダイアログ．Yesで次のステップへ}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_49.png}
  \end{center}
  \caption{合成と配置配線の開始}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_23_17.png}
  \end{center}
  \caption{無事に合成と配置配線が終了しビットファイルができあがったところ．Open Hardware Managerを選択してOKをクリックすることで，ハードウェアマネージャの起動の手間を省くことができる}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_23_59.png}
  \end{center}
  \caption{FPGAとパソコンをUSBケーブルで接続してAuto connectで認識させた後，Program Deviceをクリック}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_06.png}
  \end{center}
  \caption{bitファイルはFPGAに，ILAのパソコン側の定義ファイルであるilxはVivadoに読み込ませる．}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_16.png}
  \end{center}
  \caption{書き込み中}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_38.png}
  \end{center}
  \caption{FPGAへのダウンロードが終了した．また，ILAによる動作のモニタ画面が表示された}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_53.png}
  \end{center}
  \caption{二重矢印のアイコンをクリックすると，その時点での値をキャプチャしてくれる}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_07.png}
  \end{center}
  \caption{虫眼鏡アイコンで拡大すると，値が1ずつ増えていることが確認できる}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_21.png}
  \end{center}
  \caption{実機デバッガでは値をキャプチャする条件(トリガ条件)を指定する}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_27.png}
  \end{center}
  \caption{counterの値をトリガ条件に使用することとする}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_34.png}
  \end{center}
  \caption{counterの値がトリガ条件として登録された}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_50.png}
  \end{center}
  \caption{counterが00001000になった時点でキャプチャするように設定．トリガ値を指定したら三角アイコンでキャプチャを開始する}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_27_49.png}
  \end{center}
  \caption{counterが00001000になった時点のデータをキャプチャすることができた}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_28_03.png}
  \end{center}
  \caption{トリガにはドントケア(X)を指定することも可能．ここでは下位16bitが3000になるデータを取得するように指定してみる}
 \end{figure}</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_28_15.png}
  \end{center}
  \caption{上位16bitは指定なく，下位16bitが3000の時点のデータがキャプチャできていることがわかる}
 \end{figure}</p>

<h2 id="ila挿入すると回路は変わる">ILA挿入すると回路は変わる</h2>

<p>重要な点ですが，ILAを挿入すると，挿入前とは異なるハードウェアになることを理解しておく必要があります．ILA向けのリソース使用量が増えるのはもちろん，観測対象の信号の接続関係も変化します．また観測のために残すべきレジスタの都合で最適化の結果もかわってきます．</p>

<p>たとえば，図\ref{fig:without_mark_debug}は，counterにmark_debugアトリビュートを付与せずに合成した場合のデバッグビューです．3bit目をledに接続し，それ以上のbit数の値は利用さていないため，ばっさりと回路が小さくなっていることがわかります．</p>

<p>しかし，mark_debugアトリビュートを付与して合成した場合には，もちろん最適化するわけにはいかないため，図\ref{fig:debug_mode_view}のように要/不要にかかわらず32bit分すべてのレジスタが回路として生成されています．</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.8\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_00_24.png}
  \end{center}
  \caption{counterにmark_debugがない場合 \label{fig:without_mark_debug}}
 \end{figure}</p>

<h1 id="基本実験の準備">基本実験の準備</h1>

<p>FPGAを使った実験をする前に，動作の様子を確認しながら実験できるように簡単なテンプレートモジュールを用意しておくことにします．
ここで作るのは，図\ref{fig:experiment_template}のように4bitの入力と4bitの出力ポートで構成されるモジュールです．
ZYBOのDIPスイッチSW0〜SW3を4bitの入力に，LED LD0〜LD3を4bitの出力にマッピングすることにします．</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.6\textwidth]{chapter05_figures/experiment_template.png}
  \end{center}<br />
  \caption{実験用の簡単なテンプレートモジュール \label{fig:experiment_template}}
 \end{figure}</p>

<p>次のような内容のVHDLファイルを用意します．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;</p>

<p>use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity top is
  port (
    CLK : in  std_logic;
    SW  : in  std_logic_vector(3 downto 0);
    LD  : out std_logic_vector(3 downto 0)
    );
end entity top;</p>

<p>architecture RTL of top is</p>

<p>signal sw_d0 : std_logic_vector(3 downto 0);
  signal sw_d1 : std_logic_vector(3 downto 0);</p>

<p>begin</p>

<p>LD &lt;= sw_d1;</p>

<p>process(CLK)
  begin
    if rising_edge(CLK) then
      sw_d0 &lt;= SW;
      sw_d1 &lt;= sw_d0;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>ピン定義も用意しましょう．第3章で紹介したようにGUIで設定することもできますが，スクリプトファイルでピン定義を決めることもできます．実験に使用するZYBO Z7-20の全てのI/O定義は\url{<a href="https://github.com/Digilent/digilent-xdc/blob/master/Zybo-Z7-Master.xdc}にまとまっています．URL先の情報に基づいて，使用するピンの定義をまとめると次のようになります．top.xdcなどと，拡張子を.xdcとしてファイルに保存します．">https://github.com/Digilent/digilent-xdc/blob/master/Zybo-Z7-Master.xdc}にまとまっています．URL先の情報に基づいて，使用するピンの定義をまとめると次のようになります．top.xdcなどと，拡張子を.xdcとしてファイルに保存します．</a>
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33 } [get_ports {CLK}];
create_clock -add -name clk_pin -period 8.00 -waveform {0 4} [get_ports {CLK}];</p>

<p>set_property -dict {PACKAGE_PIN G15 IOSTANDARD LVCMOS33} [get_ports {SW[0]}];
set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS33} [get_ports {SW[1]}];
set_property -dict {PACKAGE_PIN W13 IOSTANDARD LVCMOS33} [get_ports {SW[2]}];
set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports {SW[3]}];</p>

<p>set_property -dict {PACKAGE_PIN M14 IOSTANDARD LVCMOS33} [get_ports {LD[0]}];
set_property -dict {PACKAGE_PIN M15 IOSTANDARD LVCMOS33} [get_ports {LD[1]}];
set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {LD[2]}];
set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS33} [get_ports {LD[3]}];
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>作成したVHDLファイルと定義ファイルをプロジェクトに追加して合成し，できあがったbitファイルをZYBO Z7-20に書きこみましょう．DIPスイッチをオン・オフすることでLEDが点灯，消灯するはずです．</p>

<h1 id="基本演算の動作を確認してみよう">基本演算の動作を確認してみよう</h1>

<p>基本的な論理演算である，AND/OR/XORの動作を実機のILAを使って確認してみましょう．</p>

<p>AND/OR/XOR/NOTの動作を確認するためのモジュールとして次のようなモジュールを用意します．
名前は\verb|logic_test.vhd|として保存することにします．
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;</p>

<p>use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity logic_test is
  port (
    CLK   : in  std_logic;
    a, b  : in  std_logic;
    q_and : out std_logic;
    q_or  : out std_logic;
    q_xor : out std_logic;
    q_not : out std_logic
    );
end entity logic_test;</p>

<p>architecture RTL of logic_test is</p>

<p>attribute mark_debug : string;</p>

<p>q_and_i : std_logic;
  q_or_i  : std_logic;
  q_xor_i : std_logic</p>

<p>attribute mark_debug of q_and_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of q_or_i  : signal is &ldquo;true&rdquo;;
  attribute mark_debug of q_xor_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of q_not_i : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>q_and &lt;= q_and_i;
  q_or  &lt;= q_or_i;
  q_xor &lt;= q_xor_i;
  q_not &lt;= q_not_i;</p>

<p>process(CLK)
  begin
    if rising_edge(CLK) then
      q_and_i &lt;= a and b;
      q_or_i  &lt;= a or b;
      q_xor_i &lt;= a and b;
      q_not_i &lt;= xor a;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>先に用意したテンプレートに組み込んで，実機で動作を確認するために，\verb|top.vhd|を次のように変更します．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;</p>

<p>use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity top is
  port (
    CLK : in  std_logic;
    SW  : in  std_logic_vector(3 downto 0);
    LD  : out std_logic_vector(3 downto 0)
    );
end entity top;</p>

<p>architecture RTL of top is</p>

<p>signal sw_d0 : std_logic_vector(3 downto 0);
  signal sw_d1 : std_logic_vector(3 downto 0);</p>

<p>component logic_test
    port (
      CLK   : in  std_logic;
      a, b  : in  std_logic;
      q_and : out std_logic;
      q_or  : out std_logic;
      q_xor : out std_logic;
      q_not : out std_logic
      );
  end component logic_test;</p>

<p>begin</p>

<p>&ndash; LD &lt;= sw_d1;</p>

<p>process(CLK)
  begin
    if rising_edge(CLK) then
      sw_d0 &lt;= SW;
      sw_d1 &lt;= sw_d0;
    end if;
  end process;</p>

<p>U : logic_test port map(
    CLK   =&gt; CLK,
    a     =&gt; sw_d1(0),
    b     =&gt; sw_d1(1),
    q_and =&gt; LD(0),
    q_or  =&gt; LD(1),
    q_xor =&gt; LD(2),
    q_not =&gt; LD(3)
    );</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="ランダムな振る舞いを実現する擬似乱数の生成">ランダムな振る舞いを実現する擬似乱数の生成</h1>

<p>ゲームなどで，ランダムな振る舞いをさせたいときに用いられるのが乱数です．本物の乱数を作るのは非常に難しいため，一般的には数式で導いた擬似乱数で代用します．ソフトウェアで乱数を作成する場合は，rand関数などを呼び出すことで乱数系列に従って生成された値を利用できます．</p>

<p>乱数系列の作り方には，いろいろな方法があります．今回は，ビット操作の練習として，シフトとXOR演算のみで構成できるXORSHIFT法(参考文献1)に基づく乱数生成器を実装してみましょう．32ビットのXORSHIFT法による乱数生成をCで記述すると，
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
 unsigned long xor() {
  static unsigned long y=2463534242;
  y ^= (y &lt;&lt; 13);
  y ^= (y &gt;&gt; 17);
  return (y ^= (y&lt;&lt;5));
 }
\end{Verbatim}
\end{quote}
\end{figure}
という関数になります．
この関数と同等の操作をするハードウェア・モジュールを作成し，シミュレーションと実機で動作を確認してみましょう．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;</p>

<p>use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity xorshift is
  port (
    CLK   : in  std_logic;
    Q     : out std_logic_vector(31 downto 0)
    );
end entity xorshift;</p>

<p>architecture RTL of xorshift is</p>

<p>attribute mark_debug : string;</p>

<p>&ndash; 2463534242 = 0x92d68ca2
  signal y : std_logic_vector(63 downto 0) := X&rdquo;0000000092d68ca2&rdquo;;
  signal y0_d, y1_d : std_logic_vector(63 downto 0);</p>

<p>attribute mark_debug of y : signal is &ldquo;true&rdquo;;
  attribute mark_debug of y0_d : signal is &ldquo;true&rdquo;;
  attribute mark_debug of y1_d : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>Q &lt;= y(31 downto 0);</p>

<p>process(CLK)
    variable y0 : std_logic_vector(63 downto 0);
    variable y1 : std_logic_vector(63 downto 0);
  begin
    if rising_edge(CLK) then
      &ndash; y ^= (y &lt;&lt; 13);
      y0 := y xor (y(63-13 downto 0) &amp; &ldquo;0000000000000&rdquo;);
      &ndash; y ^= (y &gt;&gt; 17);
      y1 := y0 xor (&ldquo;00000000000000000&rdquo; &amp; y0(63 downto 17));
      &ndash; y ^= (y &lt;&lt; 5);
      y &lt;= y1 xor (y1(63-5 downto 0) &amp; &ldquo;00000&rdquo;);</p>

<pre><code>  -- to debug
  y0_d &lt;= y0;
  y1_d &lt;= y1;
end if;
</code></pre>

<p>end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;</p>

<p>use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity top is
  port (
    CLK : in  std_logic;
    SW  : in  std_logic_vector(3 downto 0);
    LD  : out std_logic_vector(3 downto 0)
    );
end entity top;</p>

<p>architecture RTL of top is</p>

<p>signal sw_d0 : std_logic_vector(3 downto 0);
  signal sw_d1 : std_logic_vector(3 downto 0);</p>

<p>component xorshift
    port (
      CLK   : in  std_logic;
      Q     : out std_logic_vector(31 downto 0)
      );
  end component xorshift;</p>

<p>begin</p>

<p>&ndash; LD &lt;= sw_d1;</p>

<p>process(CLK)
  begin
    if rising_edge(CLK) then
      sw_d0 &lt;= SW;
      sw_d1 &lt;= sw_d0;
    end if;
  end process;</p>

<p>U : xorshift
    port map(
      CLK            =&gt; CLK,
      Q(3 downto 0)  =&gt; LD(3 downto 0),
      Q(31 downto 4) =&gt; open
      );</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="ビット加算器を作ってみよう">ビット加算器を作ってみよう</h1>

<p>ビット加算器，つまり足算の基本要素を作ってみましょう．ビット加算器では，足される数，足す数，および，繰り上がりの3bitの入力から，その桁の結果と繰り上がりの2bitを出力します．全加算器は半加算器2個とORで作ることができます．
以下のリストを参考に，加算器が正しく動作することをシミュレータおよびILAを使って実機で確認してください．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
&ndash; 半加算器
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity half_addr is
  port ( a : in std_logic;
         b : in std_logic;
         s : out std_logic;
         c : out std_logic
         );
end half_addr;</p>

<p>architecture RTL of half_addr is</p>

<p>attribute mark_debug : string;</p>

<p>signal s_i : std_logic;
  signal c_i : std_logic;</p>

<p>attribute mark_debug of s_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of c_i  : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>s &lt;= s_i;
  c &lt;= c_i;</p>

<p>process(a, b)
  begin
    s_i &lt;= a xor b;
    c_i &lt;= a and b;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
&ndash; 全加算器
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity full_addr is
  Port ( a : in std_logic;
         b : in std_logic;
         ci : in std_logic;
         s : out std_logic;
         co : out std_logic
         );
end full_addr;</p>

<p>architecture RTL of full_addr is</p>

<p>attribute mark_debug : string;</p>

<p>signal s_i : std_logic;
  signal co_i  : std_logic;</p>

<p>attribute mark_debug of s_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of co_i  : signal is &ldquo;true&rdquo;;</p>

<p>component half_addr
    Port ( a : in std_logic;
           b : in std_logic;
           s : out std_logic;
           c : out std_logic
           );
  end component half_addr;</p>

<p>signal s0 : std_logic;
  signal c0 : std_logic;
  signal c1 : std_logic;</p>

<p>begin</p>

<p>s &lt;= s_i;
  co &lt;= co_i;</p>

<p>U0: half_addr port map( a =&gt; a, b =&gt; b, s =&gt; s0, c =&gt; c0);
  U1: half_addr port map( a =&gt; s0, b =&gt; ci, s =&gt; s_i, c =&gt; c1);
  co_i &lt;= c0 or c1;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="hdlの四則演算を試してみよう">HDLの四則演算を試してみよう</h1>

<p>VHDLやVerilog HDLでは，加算器のレベルでハードウェアを設計する必要はなく，実際には定義されている算術演算を利用することができます．+/-/*の動作をシミュレータおよび実機で確認してみてください．</p>

<p>たとえば，次のようなVHDLコードを書いて試すことができます．
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity arith_test is
  port (
    a          : in  std_logic_vector(1 downto 0);
    b          : in  std_logic_vector(1 downto 0);
    q_a_add_b  : out std_logic_vector(2 downto 0);
    q_a_sub_b  : out std_logic_vector(2 downto 0);
    q_a_mult_b : out std_logic_vector(3 downto 0)
  );
end arith_test;</p>

<p>architecture RTL of arith_test is</p>

<p>attribute mark_debug : string;</p>

<p>signal q_a_add_b_i  : unsigned(2 downto 0);
  signal q_a_sub_b_i  : unsigned(2 downto 0);
  signal q_a_mult_b_i : unsigned(3 downto 0);</p>

<p>attribute mark_debug of q_a_add_b_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of q_a_sub_b_i : signal is &ldquo;true&rdquo;;
  attribute mark_debug of q_a_mult_b_i : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>q_a_add_b  &lt;= std_logic_vector(q_a_add_b_i);
  q_a_sub_b  &lt;= std_logic_vector(q_a_sub_b_i);
  q_a_mult_b &lt;= std_logic_vector(q_a_mult_b_i);</p>

<p>process(a, b)
  begin
    q_a_add_b_i  &lt;= unsigned(&lsquo;0&rsquo; &amp; a) + unsigned(&lsquo;0&rsquo; &amp; b);
    q_a_sub_b_i  &lt;= unsigned(&lsquo;0&rsquo; &amp; a) - unsigned(&lsquo;0&rsquo; &amp; b);
    q_a_mult_b_i &lt;= unsigned(a) * unsigned(b);
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="合計値の計算">合計値の計算</h1>

<p>算術演算の応用問題として，与えられたデータ(たとえば32ビットのビット列)の中に，1がいくつあるかを数えて値を返すというモジュールを作成してみましょう．たとえば，0x00000001の場合はビット列の中に1は1個，0xAAAAAAAAの場合は16個という値を出力する，モジュールです．</p>

<p>もちろん逐次的に，1クロックで1bitずつ&rsquo;0&rsquo;か&rsquo;1&rsquo;かを検査するという，ソフトウェア的な実装も考えられますが，ここでは，入力された値に対して即座に結果を返す組み合わせ回路として設計し，シミュレーションと実機で動作を確認してみてください．</p>

<p>たとえば，次のようなVHDLコードを書いて試すことができます．
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity bitcount is
  port (
    a : in  std_logic_vector(31 downto 0);
    q : out std_logic_vector(4 downto 0)
  );
end bitcount;</p>

<p>architecture RTL of bitcount is</p>

<p>attribute mark_debug : string;</p>

<p>signal q_i  : unsigned(4 downto 0);
  attribute mark_debug of q_i : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>q &lt;= std_logic_vector(q_i);</p>

<p>process(a)
    variable sum : integer := 0;
  begin
    sum := 0;
    for i in 0 to a&rsquo;length-1 loop
      if a(i) = &lsquo;1&rsquo; then
        sum := sum + 1;
      end if;
    end loop;
    q_i &lt;= to_unsigned(sum, q_i&rsquo;length);
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="pwm">PWM</h1>

<p>ある値を，1bitの信号の&rsquo;1&rsquo;と&rsquo;0&rsquo;の幅で表現するPWMという変調方式があります．
ディジタルで簡単に信号の強度を変える方法としてもよく利用されます．</p>

<p>次のVHDLコードは，PWMを実装してみた例です．
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity pwm is
  port (
    clk : in  std_logic;
    a   : in  std_logic_vector(3 downto 0);
    d   : in  std_logic;
    q   : out std_logic
  );
end pwm;</p>

<p>architecture RTL of pwm is</p>

<p>attribute mark_debug : string;</p>

<p>signal counter : unsigned(3 downto 0) := (others =&gt; &lsquo;0&rsquo;);
  signal q_i     : std_logic := &lsquo;0&rsquo;;</p>

<p>attribute mark_debug of q_i     : signal is &ldquo;true&rdquo;;
  attribute mark_debug of counter : signal is &ldquo;true&rdquo;;</p>

<p>begin</p>

<p>q &lt;= q_i;</p>

<p>process(clk)
  begin
    if rising_edge(clk) then
      counter &lt;= counter + 1;
      if counter &gt;= unsigned(a) and unsigned(a) &lt; 15 then
        q_i &lt;= d;
      else
        q_i &lt;= not d;
      end if;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>次のようにスイッチをPWMの幅に，出力をLEDに割り当てて合成したときの動作を
実機で確認してみましょう．
\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity top is
  port (
    CLK : in  std_logic;
    SW  : in  std_logic_vector(3 downto 0);
    LD  : out std_logic_vector(3 downto 0)
    );
end entity top;</p>

<p>architecture RTL of top is
  signal sw_d0 : std_logic_vector(3 downto 0);
  signal sw_d1 : std_logic_vector(3 downto 0);
  component pwm
    port (
      clk : in  std_logic;
      a   : in  std_logic_vector(3 downto 0);
      d   : in  std_logic;
      q   : out std_logic
      );
  end component pwm;
  signal pwm_q : std_logic;
begin</p>

<p>process(CLK)
  begin
    if rising_edge(CLK) then
      sw_d0 &lt;= SW;
      sw_d1 &lt;= sw_d0;
    end if;
  end process;</p>

<p>U: pwm
    port map(
      clk =&gt; clk,
      a   =&gt; sw_d1,
      d   =&gt; &lsquo;1&rsquo;,
      q   =&gt; pwm_q
      );
  LD(0) &lt;= pwm_q;
  LD(1) &lt;= pwm_q;
  LD(2) &lt;= pwm_q;
  LD(3) &lt;= pwm_q;
end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="ステートマシンの作り方と利用方法">ステートマシンの作り方と利用方法</h1>

<p>基本実験の最後に，ハードウェア・プログラミングで逐次的に処理するために必要不可欠な概念であるステート・マシンと，その実装方法を学びましょう．ハードウェアでは処理を並列に実行できますが，世の中には順番にしか実行できない物事もたくさんあります．たとえば，そうめんを茹でるとき，鍋の水がまだ湯になる前に並行してそうめんを鍋に入れても，とても食べられるものはできあがりません．何事でも順序を守ることが大事なときもありますよね．</p>

<h2 id="料理は逐次的な処理">料理は逐次的な処理</h2>

<p>何かを実行し，その次に何かを実行し，その次に&hellip;，という決まった手順に従った処理の実装は，ソフトウェアによく見られます．たとえば，そうめんをゆでるときには，</p>

<ul>
<li>鍋に水を入れる</li>
<li>鍋を火にかける</li>
<li>沸騰するまで待つ</li>
<li>そうめんを入れる</li>
<li>1分くらい待つ</li>
<li>十分やわらかいか確認する</li>
<li>やわらかくなったら取り出して，できあがり</li>
</ul>

<p>という手順が必要となります．ソフトウェアであれば，このような手順をそのままプログラミング言語で記述して実装できます．しかし，ハードウェア・プログラミングでは逐次的な処理をそのまま記述できません．逐次的に処理を進めることそのものを自分で記述する必要があります．これを簡単に扱う道具がステート・マシン(状態遷移機械)です．</p>

<h2 id="ステート-マシンとは">ステート・マシンとは</h2>

<p>図\ref{fig:statemachine_example}は，そうめんをゆでる手順をステート・マシン的に表現した例です．楕円は「状態」を矢印は「状態遷移」を示しています．矢印に条件が書かれている場合は，その条件が満たされたときだけ状態が遷移する，ということを意味します．</p>

<p>\begin{figure}[H]
  \begin{center}
   \includegraphics[width=.6\textwidth]{chapter05_figures/statemachine_example.png}
  \end{center}<br />
  \caption{そうめんを茹でる流れをステートマシン的に表現してみた例．\label{fig:statemachine_example}}
 \end{figure}</p>

<p>ステート・マシンとは，処理を「状態」と「状態遷移」で抽象化した概念です．列挙された状態を定義された状態遷移に従って順々にたどっていくことで所望の処理が実現できます．各状態での処理を定義することで，逐次的な処理をステート・マシンを使って記述できます．</p>

<h2 id="ハードウェア-プログラミングと相性の良いステート-マシン">ハードウェア・プログラミングと相性の良いステート・マシン</h2>

<p>ステート・マシンをハードウェア・プログラミングで実装するのは意外と簡単です．そうめんを茹でる手順をハードウェア記述言語の一つであるVHDLで記述した擬似コードを示します．
各状態を\verb|std_logic_vector|型の変数stateで管理しています．stateの値が各状態に対応しています．変数stateをクロックごとに参照し，その時点で実行すべき処理を判断します．各状態では，次の状態に遷移するための条件判断と，遷移のための状態変数の更新を行います．</p>

<p>\begin{figure}[H]
\begin{quote}</p>

<h2 id="begin-verbatim-frame-single-numbers-left-baselinestretch-0-8">\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]</h2>

<h2 id="そうめんをゆでるステートマシンの擬似コード">&ndash; そうめんをゆでるステートマシンの擬似コード</h2>

<p>architecture RTL of somen</p>

<p>signal state : std_logic_vector(2 downto 0) := (others =&gt; &lsquo;0&rsquo;);</p>

<p>process(clk)
  begin
    if rising_edge(clk) then
      case conv_integer(state) &ndash; 変数「state」によって状態の場合分けをする
        when 0 =&gt;
          鍋に水をいれる
          state &lt;= conv_std_logic_vector(1, 3);
        when 1 =&gt;
          鍋を火をかける
          state &lt;= conv_std_logic_vector(2, 3);
        when 2 =&gt;
          if 水が湧いたか？ = true then
            state &lt;= conv_std_logic_vector(3, 3);
          end if;
        when 3 =&gt;
          そうめんをいれる
          state &lt;= conv_std_logic_vector(4, 3);
        when 4 =&gt;
          if 時間 = 1分 then
            state &lt;= conv_std_logic_vector(5, 3);
          end if;
        when 5 =&gt;
          if やわらかさが十分か？ = true then
            state &lt;= conv_std_logic_vector(6, 3);
          end if;
        when 6 =&gt;
          &ndash; おしまい
        when others =&gt; &ndash; 「上記以外のその他」に相当．これで，全条件を列挙できた．
          null;
      end case;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>ところで，リスト1のコードには，0，1，2，&hellip;という状態を識別するための番号が振られています．これらの値に意味はなく，単にほかと区別するために便宜的に付けられたマジック・ナンバです．マジック・ナンバはコードの可読性を下げ，後の変更を加えづらくします．ソフトウェアでもマジック・ナンバは忌み嫌われるように，ハードウェア・プログラミングでもできれば避けたいものです．</p>

<p>VHDLでは自分で型を定義することで，Verilogではdefineやlocalparamを使って値に名前を付けることで，ソース・コードからマジック・ナンバを取り除くことができます．VHDLで状態を表す型を定義して，マジック・ナンバをなくした例が次の通りです．</p>

<p>\begin{figure}[H]
\begin{quote}</p>

<h2 id="begin-verbatim-frame-single-numbers-left-baselinestretch-0-8-1">\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]</h2>

<p>&ndash; そうめんをゆでるステートマシンの擬似コード</p>

<h2 id="状態変数のための型を定義しマジックナンバをなくしたバージョン">&ndash; 状態変数のための型を定義しマジックナンバをなくしたバージョン</h2>

<p>architecture RTL of somen</p>

<p>&ndash; 状態を表わす型を定義する．これは，enumのような列挙型に相当．
  type StateType is (WATER, FIRE, HOT_WATER, PUT_SOMEN, WAIT_A_MIN, BOIL, FIN)
  signal state : StateType := WATER;</p>

<p>process(clk)
  begin
    if rising_edge(clk) then
      case conv_integer(state)
        when WATER =&gt;
          鍋に水をいれる
          state &lt;= FIRE;
        when FIRE =&gt;
          鍋を火をかける
          state &lt;= HOT_WATER;
        when HOT_WATER =&gt;
          if &ldquo;水が湧いたか？ = true&rdquo; then
            state &lt;= PUT_SOMEN;
          end if;
        when PUT_SOMEN =&gt;
          そうめんをいれる
          state &lt;= WAIT_A_MIN;
        when WAIT_A_MIN =&gt;
          if 時間 = 1分 then
            state &lt;= BOIL
          end if;
        when BOIL =&gt;
          if やわらかさが十分か？ = true then
            state &lt;= conv_std_logic_vector(6, 3);
          end if;
        when FIN =&gt;
          &ndash; おしまい
        when others =&gt;
          null;
      end case;
    end if;
  end process;</p>

<p>end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<p>次のリストを参考に，ステートマシンを利用したハードウェアを設計し，動作をシミュレーションとILAで確認してみてください．</p>

<p>\begin{figure}[H]
\begin{quote}
\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.6]
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;</p>

<p>entity stmt_test is
  port ( clk : in std_logic;
         a,b : in std_logic;
         led : out std_logic_vector(2 downto 0)
       );
end stmt_test;</p>

<p>architecture RTL of stmt_test is
  attribute mark_debug : string;</p>

<p>signal led_i : std_logic_vector(2 downto 0) := (others =&gt; &lsquo;0&rsquo;);
  attribute mark_debug of led_i : signal is &ldquo;true&rdquo;;</p>

<p>type StateType is (BLACK, RED, GREEN, BLUE);
  signal state : StateType := BLACK;</p>

<p>signal a_d, b_d : std_logic := &lsquo;0&rsquo;;
  signal a_rising, b_rising : std_logic := &lsquo;0&rsquo;;</p>

<p>begin</p>

<p>led &lt;= led_i;
  a_rising &lt;= &lsquo;1&rsquo; when a_d = &lsquo;0&rsquo; and a = &lsquo;1&rsquo; else &lsquo;0&rsquo;;
  b_rising &lt;= &lsquo;1&rsquo; when b_d = &lsquo;0&rsquo; and b = &lsquo;1&rsquo; else &lsquo;0&rsquo;;</p>

<p>process(clk)
  begin
    if rising_edge(clk) then
      a_d &lt;= a;
      b_d &lt;= b;</p>

<pre><code>  case state is
  when BLACK =&gt;
    led_i &lt;= &quot;000&quot;;
    if a_rising = '1' then
      state &lt;= RED;
    elsif b_rising = '1' then
      state &lt;= BLUE;
    end if;
  when RED =&gt;
    led_i &lt;= &quot;001&quot;;
    if a_rising = '1' then
      state &lt;= GREEN;
    elsif b_rising = '1' then
      state &lt;= BLACK;
    end if;
  when GREEN =&gt;
    led_i &lt;= &quot;010&quot;;
    if a_rising = '1' then
      state &lt;= BLUE;
    elsif b_rising = '1' then
      state &lt;= RED;
    end if;
  when BLUE =&gt;
    led_i &lt;= &quot;100&quot;;
    if a_rising = '1' then
      state &lt;= BLACK;
    elsif b_rising = '1' then
      state &lt;= GREEN;
    end if;
  when others =&gt;
    led_i &lt;= &quot;000&quot;;
    state &lt;= BLACK;
 end case;
end if;
</code></pre>

<p>end process;
end RTL;
\end{Verbatim}
\end{quote}
\end{figure}</p>

<h1 id="参考文献">参考文献</h1>

<ol>
<li>George Marsaglia, &ldquo;Xorshift RNGs&rdquo;, The Florida State University, \url{<a href="http://www.jstatsoft.org/v08/i14">http://www.jstatsoft.org/v08/i14</a>}</li>
</ol>
</article>

      

      
    </div>

    
  

  <aside class="book-toc levels-6 fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#はじめに">はじめに</a></li>
<li><a href="#ilaを使ってfpga内部の信号を観測する">ILAを使ってFPGA内部の信号を観測する</a>
<ul>
<li><a href="#lチカでilaの動作を学ぶ">LチカでILAの動作を学ぶ</a></li>
<li><a href="#準備">準備</a></li>
<li><a href="#ilaのセットアップと利用方法">ILAのセットアップと利用方法</a></li>
<li><a href="#ila挿入すると回路は変わる">ILA挿入すると回路は変わる</a></li>
</ul></li>
<li><a href="#基本実験の準備">基本実験の準備</a></li>
<li><a href="#基本演算の動作を確認してみよう">基本演算の動作を確認してみよう</a></li>
<li><a href="#ランダムな振る舞いを実現する擬似乱数の生成">ランダムな振る舞いを実現する擬似乱数の生成</a></li>
<li><a href="#ビット加算器を作ってみよう">ビット加算器を作ってみよう</a></li>
<li><a href="#hdlの四則演算を試してみよう">HDLの四則演算を試してみよう</a></li>
<li><a href="#合計値の計算">合計値の計算</a></li>
<li><a href="#pwm">PWM</a></li>
<li><a href="#ステートマシンの作り方と利用方法">ステートマシンの作り方と利用方法</a>
<ul>
<li><a href="#料理は逐次的な処理">料理は逐次的な処理</a></li>
<li><a href="#ステート-マシンとは">ステート・マシンとは</a></li>
<li><a href="#ハードウェア-プログラミングと相性の良いステート-マシン">ハードウェア・プログラミングと相性の良いステート・マシン</a></li>
<li><a href="#begin-verbatim-frame-single-numbers-left-baselinestretch-0-8">\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]</a></li>
<li><a href="#そうめんをゆでるステートマシンの擬似コード">&ndash; そうめんをゆでるステートマシンの擬似コード</a></li>
<li><a href="#begin-verbatim-frame-single-numbers-left-baselinestretch-0-8-1">\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8]</a></li>
<li><a href="#状態変数のための型を定義しマジックナンバをなくしたバージョン">&ndash; 状態変数のための型を定義しマジックナンバをなくしたバージョン</a></li>
</ul></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
