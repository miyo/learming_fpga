<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Learning FPGA</title>
    <link>https://miyo.github.io/learning_fpga/docs/</link>
    <description>Recent content in Docs on Learning FPGA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Oct 2019 19:15:46 +0900</lastBuildDate>
    
	<atom:link href="https://miyo.github.io/learning_fpga/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Introduction</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/introduction/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/introduction/</guid>
      <description>イントロダクション ○○を制御したいけどソフトウェアじゃ難しい 実験などのために，何かの入力を観測しながら，それに応じて何かの処理をする，という機会がありませんか？そのような場合，パソコンやマイコンで実装してみようとしても
 モータやセンサをたくさんつなぎたいから100個くらい自由に使える入出力があればいいのに システムを乾電池1本で動作しないかなあ 決められた時間内できちんと処理を終わらせたい/繰り返したい 処理専用の特別な命令を実行できたら高速化できるのにな いくつもの処理を並行して実行できたらいいのにな 361ビットの値の演算が一発でできたらすっきり書けるのに など，ソフトウェアではあと一息痒いところに手が届かず，歯痒い思いをしたことはないでしょうか．  プロセッサがプログラムを実行する パソコンはもちろんのこと，今やテレビや携帯電話，自動車などのあらゆる製品の中でソフトウェアが動作しています．それらのソフトウェアは，実現したいアプリケーションや動作させる環境に応じて，さまざまなプログラミング言語で記述されています．たとえば，JavaScriptはWebアプリケーションを便利に華やかにしてくれますし，Cで記述されたプログラムはシステムを細やかに制御し，高速に動作させることができます．
近年のソフトウェアが動作する環境は，プログラミング言語やオペレーティング・システム，ライブラリなどにより上手に隠蔽されていますので，抽象化された世界の上でプログラムを書けるソフトウェア・エンジニアは，ハードウェアを意識することが少ないかもしれませんが，どのような言語を使ったプログラムでも，ハードウェアであるプロセッサで処理が実行されます．
たとえば，パソコン上で動作するソフトウェアはIntelのCore i7などのプロセッサの上で動作し，スマートフォンの上のソフトはARMプロセッサの上で動作しています．また，組み込み機器でも各種マイコンの上で処理が実行されています．一般に，マイコンは，演算装置に加え様々なデバイスを制御するためのI/Oコントローラを備えているためセンサの入力を読み取ったり，モーターを回したりといった処理をソフトウェアで操作できます． 「プロセッサ」や「マイコン」はデバイスそのものがアプリケーションに応じて変化するわけではなく，図\ref{fig:software_on_processor})のように，ソフトウェアによって処理させる内容をその時々で決めることができるため，幅広い用途に活用されています．
\begin{figure}[H] \begin{center} \includegraphics[width=.95\textwidth]{chapter01_figures/software_on_processor.png} \end{center} \caption{ソフトウェアプログラムはプロセッサの上で処理される．どんなプログラムを実行する場合でもプロセッサの構造は変わらない \label{fig:software_on_processor}} \end{figure}
一方で，自由に設計できるようにみえるソフトウェアも，実際に動作するときには，常にプロセッサの制約を受けます．たとえば，プロセッサの処理能力の限界を越えるような速さでの計算や，プロセッサがもっていないI/Oを操作するといったことはできません． しかし，デバイスそのものをアプリケーションに応じて変化させて，冒頭に挙げたような「もし○○なプログラムが書けたなら」の希望を現実にできる手段があれば，今まで手を出しにくかったアプリケーションが実現できるのではないでしょうか．
ハードウェア・デバイスを作るための便利な仕組み そんなときには，オリジナルのハードウェアを作るという解決策があります．ハードウェアを作るといっても，げじげじの足が付いたデバイスを一つずつはんだ付けしたり，半導体工場に製作を依頼する必要はありません．ハードウェア記述言語（HDL；Hardware Description Language）を用いて作成したハードウェア・イメージを専用のデバイス（FPGA）に書き込むだけでオリジナルのハードウェア・デバイスを作る便利な仕組みがあります． FPGAは，図\ref{fig:fpga_simple_image}のように，論理回路になる素や，論理回路同士を接続する素がパッケージされたLSIです．
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter01_figures/fpga_simple_image.png} \end{center} \caption{FPGAは，論理回路の素や配線回路の素がパッケージされたLSI \label{fig:fpga_simple_image}} \end{figure}
用途によって，とにかく短い時間で処理をしたい，低消費電力で処理をさせたい，同時にたくさんのI/Oにアクセスしたいといったことが求められることもあるでしょう．FPGAは，そんな要求に応えることができる，やりたい処理をさせるための専用ハードウェアを自在に作れる柔らかいプログラム可能なハードウェア・デバイスです(図\ref{fig:fpga_processing_image})．
\begin{figure}[H] \begin{center} \includegraphics[width=.95\textwidth]{chapter01_figures/fpga_processing_image.png} \end{center} \caption{FPGAは，実現したい処理向けの専用ロジックを自分で作ることができる \label{fig:fpga_processing_image}} \end{figure}
FPGAには小さなメモリ(LUT)がたくさん入っている FPGAの中身はどのようになっているのか，もう少し詳しくのぞいてみましょう．図\ref{fig:inside_fpga_example}は，代表的なFPGAメーカーであるXilinxとIntelのFPGAの内部構造です．多少違いはありますが，基本的な構成要素は，LUT(Look-up Table)と記憶素子(D-FF)で構成されるロジック・セルです．
\begin{figure}[H] \begin{center} \includegraphics[width=.95\textwidth]{chapter01_figures/inside_fpga_example.png} \end{center} \caption{FPGAの内部構造 \label{fig:inside_fpga_example}} \end{figure}
好きな論理演算を実現する鍵はLUTで，これは小規模なメモリのようなものです．入力されたデータに対して出力する信号を決定するためのテーブルの役割を持ちます．
たとえば，図\ref{fig:inside_fpga_example}のように，アドレス0に0，それ以外のアドレス1〜63には，1と書いてあるLUTの場合には，6入力1出力のOR回路に相当します．同様に，アドレス0〜62に0をアドレス63に1と書いておけば，6入力1出力のAND回路を作ることができます．また，1が奇数個のアドレス，たとえば，アドレス1，2，4，7など，のみに1と書いておけば，6入力1出力のXOR回路になります．
入力ビット幅の範囲で好きな論理演算を決められるLUTと，複数のLUTを好きに接続できる接続テーブルによって，大規模な論理演算を好きに構成することができますね．
ハードウェアと記述言語 LUTと接続テーブルを設定して，ハードウェアを自由に設計できるといっても，ソフトウェアでは簡単に書ける足し算や引き算といった基本的な演算を，一つ一つ論理回路で構成するのは骨が折れる作業です．そこで利用するのがハードウェア記述言語(HDL; Hardware Description Language)です．
HDLは，Cプログラミングなどと同じように変数への加減算や条件分岐などを用いてハードウェアを設計できるプログラミング言語です．ユーザは，まるでプログラムをロードするように，ハードウェア・データをFPGAに書き込むことで所望のデバイスを作ることができます．
ハードウェア・プログラミングを理解する三つのポイント オリジナルのハードウェアを作成するための手段が，ハードウェア・プログラミングです．ソフトウェア・プログラミングでは，プロセッサ(というハードウェア)を動作させるための命令列を設計するのに対し，ハードウェア・プログラミングは，ハードウェアそのものを設計します．ハードウェア・プログラミングにチャレンジするにあたり，ハードウェアの基本概念となる「演算の決め方」と「データの単位」，「処理の動作方式」についてソフトウェア・プログラミングと比較しながら説明します．
演算の決め方 ソフトウェア・プログラミングでは，演算はプロセッサのもつ命令として決められています．一方でハードウェア・プログラミングでは，論理演算を組み合わせて自分で演算を決めることができます．</description>
    </item>
    
    <item>
      <title>VHDL/Veilog 入門</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/languages/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/languages/</guid>
      <description>はじめに 本章では，ハードウェア記述言語(HDL; Hardware Description Language)のうち，よく使用されるVHDLとVerilog HDLの二つのHDLの基本文法を説明します．ちょっとした違いを発見しながら読み進めると面白いでしょう．
ソフトウェア・プログラミングで使用するCやJava，コミュニケーションで使用する英語についても，正しく使用するために文法の知識は欠かせません．同じようにHDLで設計する際も文法の知識が必要です．ここで，基本文法をしっかり押さえましょう．
ハードウェア記述言語の基本概念 プログラミング言語に多くの種類があるように，ハードウェア記述言語(HDL)にもさまざまな種類があります．その中でもよく利用されるのが，VHDLとVerilog HDLです．VHDLとVerilog HDLは，どちらも，ハードウェアを表現するための似たような概念を取り扱うことができる言語です．
ただし，似たような概念でもそれぞれの言語で使用する言葉が違うので注意が必要です．両方の言語に共通する概念と，言語の特徴について説明します．
構造の基本 &amp;mdash; エンティティ/モジュール どの言語にも基本的な構造があります．たとえば，Cでは関数，Javaではクラスなどです．HDLでは，与えられた入力に対して出力を生成するブロックが基本的な単位です(図\ref{fig:design_unit})．このブロックをVHDLではエンティティ(\verb|entityt|)，Verilog HDLではモジュール(\verb|module|)と呼びます．ただし，この章では，特にVHDLやVerilog HDLに違いがない説明では，モジュールと呼ぶことにします．
\begin{figure}[H] \begin{center} \includegraphics[width=.5\textwidth]{chapter02_figures/design_unit.png} \end{center} \caption{ハードウェア・プログラミングの基本的な単位 \label{fig:design_unit}} \end{figure}
通常のプログラミング言語とHDLの大きな違いは，エンティティ/モジュールは，最初から最後まで与えられた入力に対する出力を生成し続けるということです．Cなどで関数を呼び出す場合，mainプログラムからその関数内へ処理が移ります(\ref{fig:software_running_model})．処理を終えると戻り値を呼び出し元に返し，mainプログラムが再び動き始めます．つまり，mainプログラムは，呼び出した関数の処理が完了するまで待たされます．これは，プログラム・カウンタが，プログラムを順々に呼び出して実行するからです．
\begin{figure}[H] \begin{center} \includegraphics[width=.75\textwidth]{chapter02_figures/software_running_model.png} \end{center} \caption{Cで記述した一般的なソフトウェア・プログラムの実行の様子 \label{fig:software_running_model}} \end{figure}
一方，HDLで記述されたエンティティ/モジュールには，共通のプログラム・カウンタのような，複数の演算回路の動作を制御する仕組みはありません．(図\ref{fig:hardware_instances})．どのモジュールも常に存在し，独立して動作します．したがって，特定の入力を与えると出力を返すというよりも，入力されているデータに対して出力するデータを作り続けているというイメージになります．複数のモジュール間で制御が必要であれば自分で，そのように設計する必要があります．
\begin{figure}[H] \begin{center} \includegraphics[width=.65\textwidth]{chapter02_figures/hardware_instances.png} \end{center} \caption{ハードウェアは常に存在し，演算回路の動作が制御されることはない(制御が必要なら自分で記述する必要がある) \label{fig:hardware_instances}} \end{figure}
2種類の基本処理方法 &amp;mdash; 同時処理文と順次処理文 繰り返しになりますが，ハードウェア・プログラミングでは，独立して動作するモジュールを扱う必要があります．すなわちハードウェアを記述するための言語では，独立して動作する同時並行的な処理を記述できる必要があります．とはいえ，実現したい処理によっては，条件分岐のような依存関係のある処理の記述が望まれます．これらの要求を満たすため，VHDLとVerilog HDLのどちらも，同時処理文と順次処理文と呼ばれる二種類の記述方式をサポートしています．具体的な記述方法は後で説明しますが，それぞれの考え方を頭に入れておいてください．
同時処理文 同時処理文とは，周りの処理に依存せず独立して動作する処理です．複数の同時処理文は，ある特定の時点で一斉に処理されます．そのため，記述順や各処理文の間には，構文的な順序が存在せず，「ある時点」で入力された値に従って出力が生成されます．出力が確定するまでの時間は，物理的にデバイスの中を電気が流れる速さや信号遅延に依存します．
順次処理文 順次処理文は，複数の処理同士に構文などによって順序が規定された処理です．たとえば，ソフトウェアには欠かせない分岐などの制御文の表現には順序が必要になります．
使用できる変数 &amp;mdash; 数値と信号 プログラミング言語と同じようにHDLでも変数を利用できます．VHDLでもVerilog HDLでも，変数はすべて型を持ちます．ハードウェアとして，基本的な型は1本の信号線です．また，信号線を束ねた配列もサポートされます．このほかに，整数や自分で定義した型も利用できます．
変数は，英数字からなる名前を付けることができます．変数名の先頭は英字または「_」で始める必要があり，末尾を「_」にしてはいけません．Verilog HDLでは，大文字と小文字は区別されます．
演算の基本 &amp;mdash; 算術/論理減算，比較，代入 VHDLおよびVerilog HDLでは加減算や論理演算，比較などの演算子を利用することができます．ソフトウェア・プログラミングの場合は演算子を使って記述された処理はプロセッサに与える命令に変換されますが，HDLの場合は，その演算に相当するハードウェア・ロジックとしてLUTやFFなどの組み合わせに合成されます．FPGAの中には，小さなディジタルシグナルプロセッサや乗算器を持つものがあり，条件にうまく合致すると，それらが使用されます．
HDLでもソフトウェア・プログラミング同様に，演算した結果を代入演算を利用して，ほかの(あるいは同じ)変数に代入することができます．HDLの代入には，ブロッキング代入とノンブロッキング代入の2種類があります．ブロッキング代入は，その時点で値を代入して次に進む代入です．一方，ノンブロッキング代入は，複数の代入文において，それらの代入の同時実行を規定します．Cなどで記述した単一スレッドのソフトウェア・プログラムの代入は，HDLでいうところのブロッキング代入に相当します．
値の基本 &amp;mdash; &amp;lsquo;0&amp;rsquo;，&amp;rsquo;1&amp;rsquo;，&amp;rsquo;Z&amp;rsquo;，&amp;rsquo;X&amp;rsquo; ハードウェアの値は&amp;rsquo;0&amp;rsquo;と&amp;rsquo;1&amp;rsquo;の値をとります．加えて，ハードウェアにはハイ・インピーダンスという，「抵抗が無限大」を意味する状態が存在します．VHDLやVerilog HDLでは&amp;rsquo;Z&amp;rsquo;で表されます．値として「抵抗が無限大」というのは，少しわかりにくいかもしれません．物理的には，図\ref{fig:high_imp_image}のようにスイッチを切った状態をイメージしてください．複数の信号が一つにまとめられるとき，&amp;rsquo;Z&amp;rsquo;は，「ほかの値に影響を与えない」ということを意味します．
\begin{figure}[H] \begin{center} \includegraphics[width=.</description>
    </item>
    
    <item>
      <title>クイックスタート</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/quickstart/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/quickstart/</guid>
      <description>FPGA開発におけるHello World ``Lチカ&amp;rdquo; を通して，開発の手順に慣れよう
はじめに この章では，FPGA開発におけるHello World，すなわち最初に試してみるサンプルとして Lチカ を題材に，開発の手順に慣れてみましょう． Lチカ とは，「LEDをチカチカさせる」の略です．
単にLEDとチカチカさせるだけ，なのですが，開発の手順を身につけるには十分です．また，実際多くの信号制御は何かしらの規則にしたがって信号をON/OFFしていることですから，すべての信号制御はLチカの応用にあるとも言えます．簡単ですが大事ですよ．
実習 プロジェクトの用意 \begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_24.png} \end{center} \caption{VivadoのFileメニューから，New Project&amp;hellip;を選択する} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_32.png} \end{center} \caption{プロジェクト作成ダイアログが開くので，Next$\gt$で次へ} \end{figure}
プロジェクト名と格納先を決めます．ここでは，ホームディレクトリの下のVivadoというフォルダの下にプロジェクトを格納することとし，名前をproject_1としています． \begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_37.png} \end{center} \caption{プロジェクト名と格納先を決めます} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_43.png} \end{center} \caption{プロジェクトタイプの指定です．RTLプロジェクトを指定します} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_24.png} \end{center} \caption{すでにソースコードがある場合にはここで追加できます．今回はないのでNext$\gt$で，そのまま次へ} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_30.png} \end{center} \caption{すでに制約ファイルがある場合にはここで追加できます．今回はないのでNext$\gt$で，そのまま次へ} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_49.png} \end{center} \caption{ターゲットとするFPGAの選択画面です．BoardタブをクリックしZybo Z7-20を選択して$\gt$で次へ} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_55.png} \end{center} \caption{確認画面です．Finishをクリックするとプロジェクトの作成は完了です} \end{figure}
\begin{figure}[H] \begin{center} \includegraphics[width=.8\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_06.png} \end{center} \caption{プロジェクト作成には少し時間がかかります} \end{figure}</description>
    </item>
    
    <item>
      <title>シミュレーション</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/simulation/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/simulation/</guid>
      <description>この章では，``Lチカ&amp;rdquo;を題材に設計したデザインがどのように動いているのか，Vivado付属のシミュレータを使ったシミュレーションによって確認する方法を学びます．
はじめに 実際の開発現場で不具合を解析するときにもシミュレーションは大変有用な手段です．
HDLで記述したアプリケーション回路をFPGA上で動作させるためには，合成や配置配線を実行してFPGA書き込み用のコンフィギュレーション情報のファイルを生成する必要があります．回路規模が大きくなると，コンフィギュレーション情報を作成するのにも長い時間が必要になります．しかし，シミュレーションの場合は簡単なコンパイルでおしまいです．デバッグなどで，何度もソース・コードを変更するような場合には，シミュレータで動作を確認できれば圧倒的に短時間で済みます．
また，FPGAで動作しているアプリケーション回路の各信号が，どのように変化しているか，外から観測するのはなかなか難しいものです．一方で，シミュレーションでは自由に記述したロジックの信号の変化を観察できます．
そのため，シミュレーションを使用した内部の信号の観測がHDLレベルでの論理的なデバッグに有効です．この章では，このHDLコードの動作をVivadoシミュレータでシミュレーションする方法を学びましょう．
シミュレーションに必要なもの &amp;mdash; テスト・ベンチ CPUを買ってきても，マザーボードがないとパソコンとして動かないように，FPGAも周辺部品の載った``マザーボード&amp;rdquo;がないと動きません．FPGAもFPGA単体では動作せず，MicroBoardやDE0 nanoに搭載されているような回路を駆動するクロック信号やリセット信号が必須です．
実際にFPGAを使ったシステムでは，クロックは外から与えられるものですが，シミュレーションでは，FPGAに実装したHDLモジュールが動作するのに必要なクロック信号やリセット信号なども自前で用意しなければなりません(図\ref{fig:test_bench_image})．
\begin{figure}[H] \begin{center} \includegraphics[width=.95\textwidth]{chapter04_figures/test_bench_image.png} \end{center} \caption{設計したモジュールを実機で動作させる場合(a)とシミュレーションする場合(b)の違い．シミュレーションする場合にはテスト・ベンチを用意する必要がある．\label{fig:test_bench_image}} \end{figure}
といっても，とりたてて新しく特別なことを覚える必要があるわけではありません．外から与えられるべきクロック信号やリセット信号もHDLで記述できます．これをシミュレーション・コードやテスト・ベンチと呼びます．シミュレーション対象のモジュールで必要となる信号は，すべてテスト・ベンチで生成します．テスト・ベンチの記述方法はHDLソースとほとんど同じで，違いは下記の3つになります．
 エンティティの中身(モジュールの入出力信号)が空である 時間を表す構文を使って信号の振る舞いを規定する ハードウェアでは実現できない仮想的な機能を利用できる  設計したHDLモジュールを動作させるのには必要な，マザーボードに相当する部分をすべて記述しなければなりません．逆にいうと，テスト・ベンチは外部との入出力があってはいけないということです．そのため，VHDLの場合はテスト・ベンチのエンティティの中身が，Verilog HDLの場合moduleの引数が空になるというわけです．
テスト・ベンチでは 時間 を表現する必要がある 「スイッチを10秒押してから離す」や「50MHzの信号」などの振る舞いは時間を扱うので，HDLのビヘイビア・モデル（動作記述）を用いて記述します．
たとえば，「10nsの時間を待つ」という動作はHDLで次のように記述します．この記述はビヘイビア・モデルの基本中の基本です． VHDLで記述する場合は， \begin{figure}[H] \begin{quote} \begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] wait for 10ns; \end{Verbatim} \end{quote} \end{figure} Verilog HDLで記述する場合には，初めにtimescaleを使って， \begin{figure}[H] \begin{quote} \begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] timescale 1ns / 1ps \end{Verbatim} \end{quote} \end{figure} と，シミュレーションの単位時間を指定して，時間を挿入したい個所で \begin{figure}[H] \begin{quote} \begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] #10 \end{Verbatim} \end{quote} \end{figure} と記述すると，指定した単位時間分の時間(この例では10ns)を作ることができます．
テストベンチの書き方 またか!</description>
    </item>
    
    <item>
      <title>基本実験</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/basics/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/basics/</guid>
      <description>かんたんな実験を通じてFPGAでのハードウェア作りの基礎力を手に入れましょう．
はじめに いくつかの簡単なHDLコードを書いて，FPGAでのハードウェア作りの基礎力を手に入れましょう．実際にHDLコードを書き，シミュレーションして，実機動作を確認することは，より複雑なハードウェアを設計するための第一歩です．
ILAを使ってFPGA内部の信号を観測する FPGAは，FPGAの中で回路がどのように動作しているのかを知るためのILA(Internal Logic Analyzer)という仕組みを持っています．実験コードを書きはじめる前に，このILAの使い方を学んでみましょう．
LチカでILAの動作を学ぶ 三度目の登場ですが，LチカでILAの動作を学びましょう．第4章で利用した\verb|project_2|を使用します．
準備 ILAを使ってデバッグするために，topモジュールのソースコードを次のように書き変えてください．
\begin{figure}[H] \begin{quote} \begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;
entity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top;
architecture RTL of top is
attribute mark_debug : string; &amp;ndash; (1) 追加 signal counter : unsigned(31 downto 0) := (others =&amp;gt; &amp;lsquo;0&amp;rsquo;); attribute mark_debug of counter : signal is &amp;ldquo;true&amp;rdquo;; &amp;ndash; (2) 追加</description>
    </item>
    
    <item>
      <title>実験</title>
      <link>https://miyo.github.io/learning_fpga/docs/book01/experiments/</link>
      <pubDate>Wed, 30 Oct 2019 19:15:46 +0900</pubDate>
      
      <guid>https://miyo.github.io/learning_fpga/docs/book01/experiments/</guid>
      <description>HDLのいろいろな記述方法を使って，少し複雑なモジュールの設計に取り組んでみましょう．
はじめに これまでに学んできた内容を利用して，少し応用的な実験に取り組んでみましょう．
ストップウォッチを作ってみよう ここでは，
 アクションボタンを押すとミリ秒毎のカウントアップを開始する カウント中に，アクションボタンを押すとカウントを一時停止する 一時停止中に，アクションボタンを押すとカウントを再開する リセットボタンを押すとカウントを0にクリアする  という機能をもったストップウォッチを作ってみましょう．
残念ながら，ZYBO Z7-20には，7セグメントLEDのような数字を表示する分かりやすい表示器はありませんので，4つのLEDと2つの3色LEDを使って数を表現するとよいでしょう．
次のリストはストップウォッチを実装するためのトップモジュールの例です．3色LEDの明るさを適当に調節するために，PWMモジュールを使って出力を変調しています．PWMモジュールによって，たとえば\verb|&amp;lsquo;1&amp;rsquo;|を出力する場合でも，適当なタイミングで&amp;rsquo;1&amp;rsquo;と&amp;rsquo;0&amp;rsquo;がまぜられることで明るさを抑えることができます．
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity stopwatch_z7_20 is port ( CLK : in std_logic; led6_r : out std_logic; led6_g : out std_logic; led6_b : out std_logic; led5_r : out std_logic; led5_g : out std_logic; led5_b : out std_logic; LD : out std_logic_vector(3 downto 0); btn : in std_logic_vector(1 downto 0) ); end entity stopwatch_z7_20; architecture RTL of stopwatch_z7_20 is attribute ASYNC_REG : string; attribute mark_debug : string; component stopwatch generic ( FREQ_MHz : integer := 125 ); port ( clk : in std_logic; reset : in std_logic; action : in std_logic; msec_out : out std_logic_vector(9 downto 0); sec_out : out std_logic_vector(5 downto 0); min_out : out std_logic_vector(5 downto 0); hour_out : out std_logic_vector(4 downto 0) ); end component stopwatch; component pwm port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end component pwm; signal btn_d0 : std_logic_vector(1 downto 0); signal btn_d1 : std_logic_vector(1 downto 0); attribute ASYNC_REG of btn_d0, btn_d1 : signal is &amp;quot;TRUE&amp;quot;; signal msec_out : std_logic_vector(9 downto 0); signal sec_out : std_logic_vector(5 downto 0); signal min_out : std_logic_vector(5 downto 0); signal hour_out : std_logic_vector(4 downto 0); attribute mark_debug of msec_out : signal is &amp;quot;true&amp;quot;; attribute mark_debug of sec_out : signal is &amp;quot;true&amp;quot;; attribute mark_debug of min_out : signal is &amp;quot;true&amp;quot;; attribute mark_debug of hour_out : signal is &amp;quot;true&amp;quot;; begin process(CLK) begin if rising_edge(CLK) then btn_d0 &amp;lt;= btn; btn_d1 &amp;lt;= btn_d0; end if; end process; U: stopwatch generic map( FREQ_MHz =&amp;gt; 125 ) port map( clk =&amp;gt; CLK, reset =&amp;gt; btn_d1(0), action =&amp;gt; btn_d1(1), msec_out =&amp;gt; msec_out, sec_out =&amp;gt; sec_out, min_out =&amp;gt; min_out, hour_out =&amp;gt; hour_out ); LD &amp;lt;= sec_out(3 downto 0); PWM0 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(0), q =&amp;gt; led5_r); PWM1 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(1), q =&amp;gt; led5_g); PWM2 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(2), q =&amp;gt; led5_b); PWM3 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(3), q =&amp;gt; led6_r); PWM4 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(4), q =&amp;gt; led6_g); PWM5 : pwm port map(clk =&amp;gt; clk, a =&amp;gt; &amp;quot;1100&amp;quot;, d =&amp;gt; msec_out(5), q =&amp;gt; led6_b); end RTL;  stopwatchモジュールを実装して，完成させてみましょう．</description>
    </item>
    
  </channel>
</rss>