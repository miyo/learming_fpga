'use strict';(function(){const indexCfg=;indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/learning_fpga/docs/book01/introduction/','title':"Introduction",'content':" イントロダクション ○○を制御したいけどソフトウェアじゃ難しい 実験などのために，何かの入力を観測しながら，それに応じて何かの処理をする，という機会がありませんか？そのような場合，パソコンやマイコンで実装してみようとしても\n モータやセンサをたくさんつなぎたいから100個くらい自由に使える入出力があればいいのに システムを乾電池1本で動作しないかなあ 決められた時間内できちんと処理を終わらせたい/繰り返したい 処理専用の特別な命令を実行できたら高速化できるのにな いくつもの処理を並行して実行できたらいいのにな 361ビットの値の演算が一発でできたらすっきり書けるのに など，ソフトウェアではあと一息痒いところに手が届かず，歯痒い思いをしたことはないでしょうか．  プロセッサがプログラムを実行する パソコンはもちろんのこと，今やテレビや携帯電話，自動車などのあらゆる製品の中でソフトウェアが動作しています．それらのソフトウェアは，実現したいアプリケーションや動作させる環境に応じて，さまざまなプログラミング言語で記述されています．たとえば，JavaScriptはWebアプリケーションを便利に華やかにしてくれますし，Cで記述されたプログラムはシステムを細やかに制御し，高速に動作させることができます．\n近年のソフトウェアが動作する環境は，プログラミング言語やオペレーティング・システム，ライブラリなどにより上手に隠蔽されていますので，抽象化された世界の上でプログラムを書けるソフトウェア・エンジニアは，ハードウェアを意識することが少ないかもしれませんが，どのような言語を使ったプログラムでも，ハードウェアであるプロセッサで処理が実行されます．\nたとえば，パソコン上で動作するソフトウェアはIntelのCore i7などのプロセッサの上で動作し，スマートフォンの上のソフトはARMプロセッサの上で動作しています．また，組み込み機器でも各種マイコンの上で処理が実行されています．一般に，マイコンは，演算装置に加え様々なデバイスを制御するためのI/Oコントローラを備えているためセンサの入力を読み取ったり，モーターを回したりといった処理をソフトウェアで操作できます． 「プロセッサ」や「マイコン」はデバイスそのものがアプリケーションに応じて変化するわけではなく，図1のように，ソフトウェアによって処理させる内容をその時々で決めることができるため，幅広い用途に活用されています．\n 図1: ソフトウェアプログラムはプロセッサの上で処理される．どんなプログラムを実行する場合でもプロセッサの構造は変わらない\n  一方で，自由に設計できるようにみえるソフトウェアも，実際に動作するときには，常にプロセッサの制約を受けます．たとえば，プロセッサの処理能力の限界を越えるような速さでの計算や，プロセッサがもっていないI/Oを操作するといったことはできません． しかし，デバイスそのものをアプリケーションに応じて変化させて，冒頭に挙げたような「もし○○なプログラムが書けたなら」の希望を現実にできる手段があれば，今まで手を出しにくかったアプリケーションが実現できるのではないでしょうか．\nハードウェア・デバイスを作るための便利な仕組み そんなときには，オリジナルのハードウェアを作るという解決策があります．ハードウェアを作るといっても，げじげじの足が付いたデバイスを一つずつはんだ付けしたり，半導体工場に製作を依頼する必要はありません．ハードウェア記述言語（HDL；Hardware Description Language）を用いて作成したハードウェア・イメージを専用のデバイス（FPGA）に書き込むだけでオリジナルのハードウェア・デバイスを作る便利な仕組みがあります． FPGAは，図2のように，論理回路になる素や，論理回路同士を接続する素がパッケージされたLSIです．\n 図2: FPGAは，論理回路の素や配線回路の素がパッケージされたLSI\n  用途によって，とにかく短い時間で処理をしたい，低消費電力で処理をさせたい，同時にたくさんのI/Oにアクセスしたいといったことが求められることもあるでしょう．FPGAは，そんな要求に応えることができる，やりたい処理をさせるための専用ハードウェアを自在に作れる柔らかいプログラム可能なハードウェア・デバイスです(図3)．\n 図2: FPGAは，実現したい処理向けの専用ロジックを自分で作ることができる\n  FPGAには小さなメモリ(LUT)がたくさん入っている FPGAの中身はどのようになっているのか，もう少し詳しくのぞいてみましょう．図3は，代表的なFPGAメーカーであるXilinxとIntelのFPGAの内部構造です．多少違いはありますが，基本的な構成要素は，LUT(Look-up Table)と記憶素子(D-FF)で構成されるロジック・セルです．\n 図3: FPGAの内部構造\n  好きな論理演算を実現する鍵はLUTで，これは小規模なメモリのようなものです．入力されたデータに対して出力する信号を決定するためのテーブルの役割を持ちます．\nたとえば，図3のように，アドレス0に0，それ以外のアドレス1〜63には，1と書いてあるLUTの場合には，6入力1出力のOR回路に相当します．同様に，アドレス0〜62に0をアドレス63に1と書いておけば，6入力1出力のAND回路を作ることができます．また，1が奇数個のアドレス，たとえば，アドレス1，2，4，7など，のみに1と書いておけば，6入力1出力のXOR回路になります．\n入力ビット幅の範囲で好きな論理演算を決められるLUTと，複数のLUTを好きに接続できる接続テーブルによって，大規模な論理演算を好きに構成することができますね．\nハードウェアと記述言語 LUTと接続テーブルを設定して，ハードウェアを自由に設計できるといっても，ソフトウェアでは簡単に書ける足し算や引き算といった基本的な演算を，一つ一つ論理回路で構成するのは骨が折れる作業です．そこで利用するのがハードウェア記述言語(HDL; Hardware Description Language)です．\nHDLは，Cプログラミングなどと同じように変数への加減算や条件分岐などを用いてハードウェアを設計できるプログラミング言語です．ユーザは，まるでプログラムをロードするように，ハードウェア・データをFPGAに書き込むことで所望のデバイスを作ることができます．\nハードウェア・プログラミングを理解する三つのポイント オリジナルのハードウェアを作成するための手段が，ハードウェア・プログラミングです．ソフトウェア・プログラミングでは，プロセッサ(というハードウェア)を動作させるための命令列を設計するのに対し，ハードウェア・プログラミングは，ハードウェアそのものを設計します．ハードウェア・プログラミングにチャレンジするにあたり，ハードウェアの基本概念となる「演算の決め方」と「データの単位」，「処理の動作方式」についてソフトウェア・プログラミングと比較しながら説明します．\n演算の決め方 ソフトウェア・プログラミングでは，演算はプロセッサのもつ命令として決められています．一方でハードウェア・プログラミングでは，論理演算を組み合わせて自分で演算を決めることができます．\nソフトウェア・プログラミング ソフトウェア・プログラミングは，プロセッサの演算ユニットが持つ機能をどのように利用するかを指示します．プロセッサの演算ユニットでは，足し算や掛け算などの算術演算や，比較演算，分岐などの処理を制御する命令を実行できます．また，信号処理を高速に処理できるように「掛け算して足し算」するといった命令を備えているプロセッサもありあます．実際にプロセッサの演算ユニットをどのように使うか，を決定するのはコンパイラの仕事で，プログラマは，普段ほとんど意識する必要はありません．\nハードウェア・プログラミング ハードウェア・プログラミングは，ハードウェアそのものを作成するので，ベースとなる演算ユニットというものは存在しません．演算処理は，基本的には，NOT，AND，ORの論理演算とそれらの組み合わせで実現します．\nデータの単位 ソフトウェア・プログラミングとハードウェア・プログラミングで取り扱い可能なデータの単位について比べてみます．\nソフトウェア・プログラミング 一般に，プロセッサの作業領域であるレジスタの幅は固定されていて，ソフトウェア・プログラミングではそのサイズでしかデータを取り扱えません．たとえば，レジスタ幅が32ビットのプロセッサでは，1という値も4294967295という大きな値も32ビット幅のデータとして処理されます．また，512ビットという大きな値を取り扱うためには，512÷32の16回分のデータ処理を必要とします．\nハードウェア・プログラミング ハードウェア・プログラミングでは，‘0’または‘1’の値である1ビット単位のデータを自由に組み合わせて利用できます．処理内容によって，好きなビット数のデータを定義できるので，大きいデータも小さいデータも自由に定義して処理できます．512ビットのデータも，ハードウェア・プログラミングなら1回のデータ処理で取り扱えます．\n処理の動作方式 ソフトウェア・プログラムは，プロセッサが記述した処理を順序よく実行してくれます．しかし，ハードウェア・プログラムは，生成されたハードウェア回路そのものがデータを処理します．そのため，処理の順序を守るための仕組みが必要な場合には自分でそのしくみを作る必要があります(図4)．\n 図4: ソフトウェア・プログラミングではプロセッサが処理順序を決めてくれる．ハードウェア・プログラミングでは，ハードウェアを構成する回路同士の接続関係や，いつデータを転送するかを全部自分で決める必要がある．\n  ソフトウェア・プログラミング 今日のプロセッサの基本的な構成方式は，図5に示すノイマン型アーキテクチャと呼ばれる方式です．ノイマン型アーキテクチャがプログラムを実行する手順はおよそ次の通りです．\n 命令を読み込む 読み込んだプログラムの命令を理解する 演算ユニット上で命令を実行する 必要に応じてメモリを読み書きする 1.に戻る  パソコンのプロセッサに見られる「クロック3GHz」といったスペックのプロセッサでは，プロセッサ内のユニットが3GHzのクロックに同期して，すなわち0.33n秒程度の時間で動作することで，このサイクルが繰り返されます．\n 図5: 今日のプロセッサの典型的な構成方式．処理性能向上のために，各ユニットは可能な限り並行に動作するように工夫されることが多い．\n  命令を実行する，演算ユニットでは，決められたビット幅の作業領域の値に足し算や掛け算などの演算を適用できます．高い処理性能を達成するために，複数の演算ユニットを持つプロセッサもあり，それらのプロセッサでは，演算ユニットの個数分だけ同時に命令を処理することができます．勿論，「演算Aの後に演算Bを計算しないと演算Aの結果が保存されない，とか，演算Bの入力が揃う前に計算をはじめてしまう」ということは普通はなく，プロセッサが演算の順番を守ってくれます．\nハードウェア・プログラミング ハードウェアの基本となる論理演算回路において，入力信号を与えてから出力信号が得られるまでの時間は，トランジスタの特性や論理演算の段数で決定されます．そのため，複雑にゲートが関係し合うような回路で，データが正しく到達することを考慮するのは大変困難です(図6)．\n 図6: 入力された信号に対して出力が確定するまでの時間は，論理演算回路を構成する論理演算の段数で決まる．\n  ハードウェア・プログラミングでは，これを解決するために大抵の場合，「同期順序回路」という構成方法を利用します．同期順序回路では，独立に動作するハードウェア中のモジュールのデータの入力のタイミングを，共通の信号「クロック」に合わせて制御します．ある単位処理を受けもつハードウェア・モジュールは，クロックが立ち上がりや立ち下がりから一定期間の間で必ず信号を読み取ることにします(図7)．全てのモジュールが，(1)クロックに間にあうように信号を決定し，(2)一定の期間値を変更しない，というルールさえ守れば，全体の演算が正しく動作します．\n 図7: 入力された信号に対して出力が確定するまでの時間は，論理演算回路を構成する論理演算の段数で決まる．\n  回路全体がクロックに合わせて動作するため，クロックの周期が短いほど全体が高速に動作します．しかし，やみくもにクロックを短くできるというわけではありません．\nハードウェア・プログラミングの流れ - 使用する言語と必要なツールは？ ハードウェア・プログラングの詳細は，以降の章で実例と共に紹介しますが，まずは全体の流れのイメージをつかんでみましょう．\nFPGAを使ったハードウェア・プログラミングは，図8のような流れで行ないます．流れ自体はソフトウェア・プログラミングとあまり変わりません．\n 図8: FPGAを使ったハードウェア・プログラミングの流れ．\n  ハードウェア・プログラミングには，ハードウェア記述言語(HDL; Hardware Description Language)を使用します．一般的に使用されているのは，VHDLとVerilog HDLの2種類です．記述自体は好きなテキストエディタで行なって構いません．図9は，emacsを使ってVHDLを記述している例です．\n 図9: emacsを使ってVHDLを記述している例．\n  HDLでハードウェアを設計したら，正しく動作を記述できているかRTLシミュレーションというフローで確認します．コマンドラインベースで使える簡単なシミュレーションツールや，回路の動作の流れを信号の変化をグラフィカルに表示するツールなどがあります．図10は，図9で記述したハードウェアをシミュレーションし信号の変化を描画した様子です．\n 図10: シミュレーション結果を確認している様子．\n  動作の確認ができたら，開発ツールの助けを借りてハードウェアに書き込む構成情報を生成します．開発ツールで行う作業は，合成と配置配線，構成情報生成の3段階です．必要なツールは，FPGAベンダである米国のIntel社とXilinx社の両方から，それぞれ専用のものが提供されています．また，最適化処理などに特色を持つサード・パーティ製の開発ツールもあり，必要に応じて使い分けるとよいでしょう．図11は，開発ツールの例です．\n 図11: 開発ツールを使って，合成・配置配線・構成情報の生成を行なう．\n  開発ツールの行う，ハードウェア・プログラミング特有の作業内容は次の通りです．\n 合成 - 論理回路に置き換える処理] 記述されたHDLを解釈し，論理回路に置き換えます．また，さまざまな最適化を適用し，小さく高速な回路を自動で生成します． [配置配線 - ロジック・セルの割り当てと接続を決定] 合成して生成した論理回路をFPGA内にあるロジック・セルを組み合わせて実現するための割り当てと接続関係を決定します．ここで，ユーザが「特定の回路同士を近付ける」や，「特定の出力を好きなピンにアサインする」などの設定を与えられます． [構成情報生成- 書き込み用ファイルを作る] 最後にFPGAに書き込み可能な構成情報を生成します．  ソフトウェア・プログラミングであれば，コンパイル，リンク，バイナル生成に相当するステップだと思えばよいでしょう．\n構成情報の生成が完了したら，そのデータを書き込みソフトウェアを使用してFPGAに書き込むことで設計したハードウェアを動かすことができます．\nさいごに 本章では，オリジナルのハードウェア・デバイスを設計する方法として，ハードウェア記述言語とFPGAを用いた開発のプロセスについて説明しました．特に，ソフトウェア・プログラミングとハードウェア・プログラミングを対比させながらその違いについて説明しました．ハードウェア設計は自由度が高い分，自分で面倒を見なければならない部分も多いのですが，プロセッサの制約に縛られずにアイデアを実現できる可能性を秘めています． FPGAとHDLによるハードウェア設計に興味を持って，はじめの一歩を踏み出してもらえると嬉しいです．\n"});index.add({'id':1,'href':'/learning_fpga/docs/book01/languages/','title':"VHDL/Veilog 入門",'content':" はじめに 本章では，ハードウェア記述言語(HDL; Hardware Description Language)のうち，よく使用されるVHDLとVerilog HDLの二つのHDLの基本文法を説明します．ちょっとした違いを発見しながら読み進めると面白いでしょう．\nソフトウェア・プログラミングで使用するCやJava，コミュニケーションで使用する英語についても，正しく使用するために文法の知識は欠かせません．同じようにHDLで設計する際も文法の知識が必要です．ここで，基本文法をしっかり押さえましょう．\nハードウェア記述言語の基本概念 プログラミング言語に多くの種類があるように，ハードウェア記述言語(HDL)にもさまざまな種類があります．その中でもよく利用されるのが，VHDLとVerilog HDLです．VHDLとVerilog HDLは，どちらも，ハードウェアを表現するための似たような概念を取り扱うことができる言語です．\nただし，似たような概念でもそれぞれの言語で使用する言葉が違うので注意が必要です．両方の言語に共通する概念と，言語の特徴について説明します．\n構造の基本 \u0026mdash; エンティティ/モジュール どの言語にも基本的な構造があります．たとえば，Cでは関数，Javaではクラスなどです．HDLでは，与えられた入力に対して出力を生成するブロックが基本的な単位です(図\\ref{fig:design_unit})．このブロックをVHDLではエンティティ(\\verb|entityt|)，Verilog HDLではモジュール(\\verb|module|)と呼びます．ただし，この章では，特にVHDLやVerilog HDLに違いがない説明では，モジュールと呼ぶことにします．\n 図1: ハードウェア・プログラミングの基本的な単位\n  通常のプログラミング言語とHDLの大きな違いは，エンティティ/モジュールは，最初から最後まで与えられた入力に対する出力を生成し続けるということです．Cなどで関数を呼び出す場合，mainプログラムからその関数内へ処理が移ります(\\ref{fig:software_running_model})．処理を終えると戻り値を呼び出し元に返し，mainプログラムが再び動き始めます．つまり，mainプログラムは，呼び出した関数の処理が完了するまで待たされます．これは，プログラム・カウンタが，プログラムを順々に呼び出して実行するからです．\n 図2: Cで記述した一般的なソフトウェア・プログラムの実行の様子\n  一方，HDLで記述されたエンティティ/モジュールには，共通のプログラム・カウンタのような，複数の演算回路の動作を制御する仕組みはありません．(図\\ref{fig:hardware_instances})．どのモジュールも常に存在し，独立して動作します．したがって，特定の入力を与えると出力を返すというよりも，入力されているデータに対して出力するデータを作り続けているというイメージになります．複数のモジュール間で制御が必要であれば自分で，そのように設計する必要があります．\n 図3: ハードウェアは常に存在し，演算回路の動作が制御されることはない(制御が必要なら自分で記述する必要がある)\n  2種類の基本処理方法 \u0026mdash; 同時処理文と順次処理文 繰り返しになりますが，ハードウェア・プログラミングでは，独立して動作するモジュールを扱う必要があります．すなわちハードウェアを記述するための言語では，独立して動作する同時並行的な処理を記述できる必要があります．とはいえ，実現したい処理によっては，条件分岐のような依存関係のある処理の記述が望まれます．これらの要求を満たすため，VHDLとVerilog HDLのどちらも，同時処理文と順次処理文と呼ばれる二種類の記述方式をサポートしています．具体的な記述方法は後で説明しますが，それぞれの考え方を頭に入れておいてください．\n同時処理文 同時処理文とは，周りの処理に依存せず独立して動作する処理です．複数の同時処理文は，ある特定の時点で一斉に処理されます．そのため，記述順や各処理文の間には，構文的な順序が存在せず，「ある時点」で入力された値に従って出力が生成されます．出力が確定するまでの時間は，物理的にデバイスの中を電気が流れる速さや信号遅延に依存します．\n順次処理文 順次処理文は，複数の処理同士に構文などによって順序が規定された処理です．たとえば，ソフトウェアには欠かせない分岐などの制御文の表現には順序が必要になります．\n使用できる変数 \u0026mdash; 数値と信号 プログラミング言語と同じようにHDLでも変数を利用できます．VHDLでもVerilog HDLでも，変数はすべて型を持ちます．ハードウェアとして，基本的な型は1本の信号線です．また，信号線を束ねた配列もサポートされます．このほかに，整数や自分で定義した型も利用できます．\n変数は，英数字からなる名前を付けることができます．変数名の先頭は英字または「_」で始める必要があり，末尾を「_」にしてはいけません．Verilog HDLでは，大文字と小文字は区別されます．\n演算の基本 \u0026mdash; 算術/論理減算，比較，代入 VHDLおよびVerilog HDLでは加減算や論理演算，比較などの演算子を利用することができます．ソフトウェア・プログラミングの場合は演算子を使って記述された処理はプロセッサに与える命令に変換されますが，HDLの場合は，その演算に相当するハードウェア・ロジックとしてLUTやFFなどの組み合わせに合成されます．FPGAの中には，小さなディジタルシグナルプロセッサや乗算器を持つものがあり，条件にうまく合致すると，それらが使用されます．\nHDLでもソフトウェア・プログラミング同様に，演算した結果を代入演算を利用して，ほかの(あるいは同じ)変数に代入することができます．HDLの代入には，ブロッキング代入とノンブロッキング代入の2種類があります．ブロッキング代入は，その時点で値を代入して次に進む代入です．一方，ノンブロッキング代入は，複数の代入文において，それらの代入の同時実行を規定します．Cなどで記述した単一スレッドのソフトウェア・プログラムの代入は，HDLでいうところのブロッキング代入に相当します．\n値の基本 \u0026mdash; \u0026lsquo;0\u0026rsquo;，\u0026rsquo;1\u0026rsquo;，\u0026rsquo;Z\u0026rsquo;，\u0026rsquo;X\u0026rsquo; ハードウェアの値は\u0026rsquo;0\u0026rsquo;と\u0026rsquo;1\u0026rsquo;の値をとります．加えて，ハードウェアにはハイ・インピーダンスという，「抵抗が無限大」を意味する状態が存在します．VHDLやVerilog HDLでは\u0026rsquo;Z\u0026rsquo;で表されます．値として「抵抗が無限大」というのは，少しわかりにくいかもしれません．物理的には，図\\ref{fig:high_imp_image}のようにスイッチを切った状態をイメージしてください．複数の信号が一つにまとめられるとき，\u0026rsquo;Z\u0026rsquo;は，「ほかの値に影響を与えない」ということを意味します．\n 図4: HDLではハイ・インピーダンスでスイッチオフを記述できる．\n  また，\u0026rsquo;0\u0026rsquo;でも\u0026rsquo;1\u0026rsquo;のどちらでもいい値として不定値という概念があります．これは，\u0026rsquo;X\u0026rsquo;と表現されます．\nソフトウェア・プログラミングでは，通常，\u0026rsquo;0\u0026rsquo;と\u0026rsquo;1\u0026rsquo;の2値をとる値をビットと呼びますが，\u0026rsquo;Z\u0026rsquo;と\u0026rsquo;X\u0026rsquo;も加えた4つの値をとる信号が便宜上ビットと呼ばれることが多くあります．\n文末には「;」を付ける VHDLもVerilog HDLも，演算処理や変数定義などの文の終わりには「;」(セミコロン)を付けます．ただし，両言語ともソフトウェアのプログラミング言語では少し首をかしげてしまうような，「;」を付けないケースが存在するので注意が必要です．\nVHDLの基本文法のルール VHDLの基本的な文法を説明します．\nコメント 多くのソフトウェア・プログラミング言語と同様に，VHDLでもソースコード中にコメントを書くことができます．VHDLでは，「\\verb|\u0026ndash;|」から行末までがコメントになります．\nモジュールの構成 図\\ref{fig:vhdl_module_overview}に，VHDLで記述するモジュールの概要を示します．VHDLでは，対象とするモジュールを大きく\\verb|entity|と\\verb|architecture|に分けて記述します．\\verb|entity|には外部に接続される入出力ポートの宣言などの回路の外枠を，\\verb|architecture|には使用する関数の定義や処理内容など，回路の内部を定義します．\n 図5: VHDLのモジュール定義はentityとarchitectureから構成される\n  即値の表現方法 VHDLでは，ソース・コードの中に定数の値を記述できます(表1)．複数の信号線を束ねた値は，信号線の本数分だけ各信号に相当する値を並べて表現します(たとえば4bitなら\\verb|\u0026ldquo;0000\u0026rdquo;|など)．また，「\\verb|X\u0026rdquo;01\u0026rdquo;|」と記述することで16進数で数を表記できます．よく用いられる代表的な定数表現には，表\\ref{tbl:vhdl_constants}のようなものがあります．\n表1. VHDLで記述できる定数の例\n   説明 値の例     1本の信号線がとる信号の値 '1'，'0' ，'Z'，'X'   複数の信号線がとる信号の値 \u0026quot;111\u0026quot;，\u0026quot;0100\u0026quot; ，X\u0026quot;10\u0026quot;   整数 32，8 ，1000   真偽値 true，false    型 VHDLの変数はすべて型を持ちます．たくさんの型が定義されており，また，独自の型も定義できます．よく使用される5つの型を表\\ref{tbl:vhdl_types}に示します．基本的には，\\verb|std_logic|，\\verb|std_logic_vector|はハードウェアの信号に相当する型，\\verb|signed|や\\verb|unsigned|は加減算などの算術演算ができる値を表現するために用いる型，一般的な数値を表現できる\\verb|integer|です．\n\\begin{table}[H] \\begin{center} \\begin{tabular}{l|l} \\hline 型名 \u0026amp; 説明 \\\\hline\\hline \\verb|std_logic| \u0026amp; 1bitの信号線 \\\\hline \\verb|std_logic_vector(n-1 downto 0)| \u0026amp; n-bitの信号線 \\\\hline \\verb|unsigned(n-1 downto 0)| \u0026amp; n-bitの符号なしの算術演算可能な値 \\\\hline \\verb|signed(n-1 downto 0)| \u0026amp; n-bitの符号ありの算術演算可能な値 \\\\hline \\verb|integer n to m| \u0026amp; nからmまでの整数 \\\\hline \\end{tabular} \\end{center} \\caption{VHDLで用いられる型の例\\label{tbl:vhdl_types}} \\end{table}\n1-bitの信号 \\verb|std_logic|は，VHDLの基本となる1bitの信号に相当する型です．\u0026rsquo;0\u0026rsquo;，\u0026rsquo;1\u0026rsquo;のほかに，ハイ・インピーダンスを示す\u0026rsquo;Z\u0026rsquo;，不定値を示す\u0026rsquo;X\u0026rsquo;を値としてとれます．これらの値は，ハードウェアにそのまま対応します．\nn-bitの信号 \\verb|std_logic_vector(n downto 0)|は，\\verb|std_logic|がn個並んだn-bitの信号線に相当する型です．「n-bitの\\verb|std_logi_vector|型」と呼びます．\\verb|std_logic_vector|型の変数aの中の要素を，a(3)，a(4 downto 2)などとして取り出せます．前者は\\verb|std_logic|型，後者は3bitの\\verb|std_logic_vector|型です．「\\verb|downto|」は\\verb|std_logic|の並びに，MSBから降順で番号を付けることを意味します．つまり，\\verb|std_logic_vector(n-1 downto 0)|のビット列の場合，MSBが\\verb|std_logic_vector(n-1)|で，LSBが\\verb|std_logic_vector(0)|です．\\verb|to|を使うことで逆順に並べることもできます．その場合は，\\verb|std_logic_vector(n upto 0)|のように書きます．\nモジュールの外枠の記述 \u0026mdash; entity \\verb|entity|は，モジュールの外枠に相当し，モジュールの名前と入出力の信号で定義されます．たとえば， 次の記述は，入力信号にpClkとpReset，出力信号にQを持つtestという名前のモジュールの外枠の定義に相当します．\n1 2 3 4 5 6 7  entity test is port ( pClk : in std_logic; Q : out std_logic; pReset : in std_logic -- 最後の一つの後には\u0026#34;;\u0026#34;をつけない ); end entity;   ポートを定義する ポートは，ハードウェア・モジュールの入出力です．\\verb|entity|の中の\\verb|port( 〜 );|の中に信号を方向と型を指定して定義します．信号の方向には\\verb|in|(入力)と\\verb|out|(出力)，\\verb|inout|(入出力)の3種類があります．各ポートは「名前 : 方向 型」で定義されます．たとえば，\n1  pClk : in std_logic   という記述は，\\verb|pClk|という名前の型が\\verb|std_logic|の入力ポート(\\verb|in|)の定義に相当します．同じ方向，型の複数のポート名は「,」で並べて定義することもできます．たとえば，\n1  pR, pG, pB : in std_logic   として，3つの入力信号\\verb|pR|，\\verb|pG|，\\verb|pB|をまとめて定義できます．\n定数を定義する \\verb|entity|の中にモジュールの中で使用する定数を定義できます．\n1 2 3 4 5 6 7 8 9 10 11  entity test is generic ( width : integer := 640; height : integer := 480 ); port ( pClk : in std_logic; Q : out std_logic; pReset : in std_logic ); end test;   ここでは，\\verb|width|という名前で値が640の\\verb|integer|型，すなわち整数の定数を定義しています．この定数は\\verb|entity|内部，および内部処理を記述する\\verb|architecture|の中で使用できます．\n内部処理の記述 \u0026mdash; architecture VHDLでは，\\verb|architecture|にモジュールの処理内容を記述します．記述の基本的な流れは次の通りです．\n1 2 3 4 5  architecture RTL of test is (ここに変数の定義などを書く) begin (ここに処理内容を記述する) end RTL;   上記は，\\verb|test|という名前のモジュールの中身を記述するためのブロックです．\n変数の定義 1  signal 名前 : 型 := 初期値;   たとえば，10ビットの配列は下記のように定義します．\n1  signal counter : std_logic_vector(9 downto 0);   また，\\verb|generic|で定義した値である\\verb|width|を使用して，幅widthの\\verb|std_logic_vector|型の信号を次のように定義できます．ここで「\\verb|width−1|」の値は合成時に決定されます．\n1  signal counter : std_logic_vector(width-1 downto 0);   演算子と演算 代表的な演算子を表\\ref{tbl:vhdl_operator}にまとめます．論理演算子を\\verb|std_logic_vector|型に定義した場合は，対応する各ビットの値同士に論理演算を適用した結果を返します．たとえば，「\\verb|\u0026ldquo;10\u0026rdquo; and \u0026ldquo;11\u0026rdquo;|」は「\\verb|\u0026ldquo;10\u0026rdquo;|」になり，「\\verb|\u0026ldquo;10\u0026rdquo; or \u0026ldquo;11\u0026rdquo;|」は「\\verb|\u0026ldquo;11\u0026rdquo;|」になります．比較演算の結果は，\\verb|true|か\\verb|false|の真偽値になります．よくあるプログラミング言語に備わっている演算が備わっていることがわかります．ただし，表\\ref{tbl:vhdl_operator}の説明に(*1)をつけている，算術演算や数値の大小を比較する演算では\\verb|unsigned|型，\\verb|signed|型あるいは\\verb|integer|の変数や定数，あるいは数値に相当する即値にしか利用できません．\n\\begin{table}[H] \\begin{center} \\begin{tabular}{l|l|l} \\hline 種類 \u0026amp; 演算子 \u0026amp; 説明 \\\\hline\\hline 論理演算 \u0026amp; \\verb|a and b| \u0026amp; 論理積．aとbが\\verb|\u0026lsquo;1\u0026rsquo;|なら\\verb|\u0026lsquo;1\u0026rsquo;|．さもなければ\\verb|\u0026lsquo;0\u0026rsquo;|．\\\\cline{2-3} \u0026amp; \\verb|a or b| \u0026amp; 論理和．aとbのどちらか又は両方が\\verb|\u0026lsquo;1\u0026rsquo;|なら\\verb|\u0026lsquo;1\u0026rsquo;|．さもなければ\\verb|\u0026lsquo;0\u0026rsquo;|．\\\\cline{2-3} \u0026amp; \\verb|a xor b| \u0026amp; 排他的論理積．aとbの一方だけが\\verb|\u0026lsquo;1\u0026rsquo;|なら\\verb|\u0026lsquo;1\u0026rsquo;|．さもなければ\\verb|\u0026lsquo;0\u0026rsquo;|．\\\\cline{2-3} \u0026amp; \\verb|not a| \u0026amp; 否定．aが\\verb|\u0026lsquo;0\u0026rsquo;|なら\\verb|\u0026lsquo;1\u0026rsquo;|．\\verb|\u0026lsquo;1\u0026rsquo;|ならverb|\u0026lsquo;0\u0026rsquo;|\\\\hline 比較演算 \u0026amp; \\verb|a = b| \u0026amp; aとbが等しい場合\\verb|true|．さもなければ\\verb|false|\\\\cline{2-3} \u0026amp; \\verb|a /= b| \u0026amp; aとbが等しくなければ場合\\verb|true|．さもなければ\\verb|false|\\\\cline{2-3} \u0026amp; \\verb|a \u0026gt; b| \u0026amp; aがbがより大きいなら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026lt; b| \u0026amp; aとbがより小さいなら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026gt;= b| \u0026amp; aとb以上なら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026lt;= b| \u0026amp; aとb以下なら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\hline 算術演算 \u0026amp; \\verb|a + b| \u0026amp; aとbの足し算 (*1)\\\\cline{2-3} \u0026amp; \\verb|a - b| \u0026amp; aとbの引き算 (*1)\\\\cline{2-3} \u0026amp; \\verb|a * b| \u0026amp; aとbの引き算 (*1)\\\\cline{2-3} \u0026amp; \\verb|a / b| \u0026amp; aとbの割り算 (*1)\\\\cline{2-3} \u0026amp; \\verb|a ** b| \u0026amp; aのb乗 (*1)\\\\hline 配列操作 \u0026amp; \\verb|a \u0026amp; b| \u0026amp; aとbをこの順に並べた信号線の束を作る \\\\cline{2-3} \u0026amp; \\verb|a(b) | \u0026amp; aのb番目の信号を取り出す \\\\cline{2-3} \u0026amp; \\verb|a(b downto c) | \u0026amp; aのb番目からc番目の信号線の束を取り出す \\\\hline \\end{tabular} \\end{center} \\caption{VHDLで用いられる演算の例\\label{tbl:vhdl_operator}} \\end{table}\n演算結果の代入 演算の結果は代入文でほかの(あるいは同じ)変数へ代入できます．代入にはブロッキング代入とノンブロッキング代入があります．\n1 2  := ブロッキング代入 \u0026lt;= ノンブロッキング代入   たとえば，\n1  Q \u0026lt;= counter(width-1);   という記述は，\\verb|std_logic_vector|型の変数\\verb|counter|の\\verb|(width-1)|番目を取り出し，\\verb|Q|に代入するハードウェアの記述に相当します．VHDLでは，\\verb|signal|変数には，初期化時以外でブロッキング代入を使用することはできません．\n型の変換 VHDLは型の制約が強い言語で．代入は同じ型の変数同士でしか認められません．また演算子も適用可能な型があらかじめ決められています．そのため，幅の違う\\verb|std_logic_vector|同士で値を定義する場合には，ビット幅を削る/足すなどして同じ幅にしなければいけません．たとえば，aとbが，それぞれ幅16-bit，8-bitの\\verb|std_logic_vector|型であれば，\n1 2  a \u0026lt;= \u0026#34;00000000\u0026#34; \u0026amp; b; -- 足りない8bitを8bitの0(=\u0026#34;00000000\u0026#34;)で埋めている b \u0026lt;= a(7 downto 0); -- aの下位8bitだけをbに代入している   などとする必要があります．\n型の変換には専用の関数を利用します．たとえば，\\verb|std_logic_vector|を\\verb|unsigned|型あるいは\\verb|signed|型に変換するためには，それぞれ\\verb|unsigned|関数あるいは\\verb|signed|を用います．\n1  unsigned(c);   と記述すると\\verb|std_logic_vector|型の変数\\verb|c|を\\verb|unsigned|型に変換できます．\n逆に，\\verb|unsigned|型や\\verb|singed|型の変数を\\verb|std_logic_vector|型に変換する場合には，\\verb|std_logic_vector|関数を用います．\n1  std_logic_vector(d);   と記述すると\\verb|unsigned|型の変数\\verb|d|を\\verb|std_logic_vector|型に変換できます．\n\\verb|integer|型の変数を\\verb|unsigned|型や\\verb|signed|型に変換する場合には，\\verb|to_unsigned|あるいは\\verb|to_signed|を使います．たとえば，\\verb|integer|型の変数\\verb|k|をn-bitの\\verb|unsigned|型に変換する場合は，2番目の引数にビット数\\verb|n|を指定して，\n1  to_unsigned(k, n);   と記述します．\n一般に，VHDLでは，\\verb|std_logic_vector|型の変数に対して算術演算は記述できません．そのため，\\verb|std_logic_vector|と定数の加減算や比較演算する場合には，一度\\verb|unsigned|型に変換して演算する必要があります．たとえば，幅nの\\verb|std_logic_vector|の変数counterに定数\\verb|1|を加算する場合には，次のように，一度\\verb|unsigned|型に変換して演算した後で\\verb|std_logic_vector|型に戻す必要があります．\n1  counter \u0026lt;= std_logic_vector(unsigned(counter) + 1);   シフト演算 VHDLには，ソフトウェア・プログラミング言語で一般的なシフト演算子に相当する演算子がありません．VHDLでは配列操作の演算を用いて似たような操作ができます．たとえば，幅n-bitの\\verb|std_logic_vector|型の変数counterを右に1つシフトしたい場合には，次のように記述します．\n1  counter \u0026lt;= \u0026#39;0\u0026#39; \u0026amp; counter(n-1 downto 1);   左に2つシフトしたい場合には，\n1  counter \u0026lt;= counter(n-3 downto 0) \u0026amp; \u0026#34;00\u0026#34;;   となります．\n同時処理文 1 2  c \u0026lt;= a and b; e \u0026lt;= c and d;   と書いても，\n1 2  e \u0026lt;= c and d; c \u0026lt;= a and b;   と書いても，同じように図\\ref{fig:parallel_vhdl}の回路が合成されます．\n 図5: 同時処理文は，記述順によらず解析・合成される\n  順次処理文 \u0026mdash; process文 順次処理文では記述された順序に従って意味が解析され，回路が合成されます．そのため，複雑な制御構文を使用できます．VHDLでは，\\verb|architecture|中で\\verb|process|を使って順次処理文を記述するためのブロックを作ることができます．\\verb|process|文の基本的な構文を次に示します．\n1 2 3 4 5  process(a, b) begin c \u0026lt;= a and b; d \u0026lt;= a or b; end process;   ここで，\\verb|process()|の「\\verb|()|」内の変数のリストをセンシティビティ・リストといいます．このリストに列挙した変数の信号が変化すると\\verb|process|の中の回路が動作し出力値が変更されます．ノンブロッキング代入は，process内の記述が順に解釈された後で，同時に信号が確定します．このprocess文は，図\\ref{fig:process_example}のような回路を生成します．あくまで文が順に解釈されるだけで，順に処理される回路が生成できるわけではない，ことに注意する必要があります．\n 図5: 順次処理文中の複数のノンブロッキング文は順に解釈され，最後に値が同時に確定する\n  \\verb|process|文の中にでてくる入力変数(式の右辺にでてくる変数)がすべてセンシティビティ・リストに列挙されている場合，入力が変化する度に回路が動作し，出力変数(式の左辺)の値が変更されます．つまり，その\\verb|process|文から生成される回路では，何も状態を保存する必要がありません．そのため，図\\ref{fig:process_example}のような記憶素子を必要としない組み合わせ回路として構成されます．\nセンシティビティ・リストにない変数が右辺に使われる．次のようなprocess文を考えてみます．\n1 2 3 4 5  process(a) begin c \u0026lt;= a and b; d \u0026lt;= a or b; end process;   ここでは，センシティビティ・リストに「b」がなく，入力変数が全部列挙されていません．この回路では，bの値が変化しても出力先であるcとdの値は変化しません．つまり，図\\ref{fig:process_example}のように，入力であるaとbを出力のcとdに直接接続することができず，cとdの値を保存する機構，記憶素子が必要となり，組み合わせ回路として合成されません．「同じように記述したつもりでも違う回路になるかもしれない」ということを覚えておいてください．\nVHDLの\\verb|process|文では，ブロッキング代入可能な\\verb|variable|変数を利用できます．\\verb|variable|変数は，順次処理文において便宜的に一時的な値を格納しておくためのものです．長く複雑な演算を行う場合に，ソース・コードの見通しをよくできます． たとえば，次のように使います．\n1 2 3 4 5 6 7 8  process(a,b) variable tmp0 : std_logic; variable tmp1 : std_logic; begin tmp0 := a and b; tmp1 := a or b; c \u0026lt;= tmp0 xor tmp1; end process;   ここでは，tmp0とtmp1がvariable変数です．ブロッキング代入における演算の結果がそれぞれ代入されています．ブロッキング代入のため，合成ツールがこの構文に出会ったところで，tmp0の値は(a and b)に，tmp1の値は(a or b)にすぐさま置き換わります．つまり，これは，\\verb|c \u0026lt;= (a and b) xor (a or b)|という回路として合成されます．\n制御構文 VHDLでは，まるでソフトウェアを記述するように，条件分岐やCの\\verb|switch|文のような制御構文が使えます．多くの制御構文は，\\verb|process|文の中でのみ使用ができます．代表的なものを紹介します．\nwhen 〜 else 同時処理文中で記述可能な制御構文です．条件に従って出力する値を選択できます．下記は，\\verb|a|と\\verb|b|の値が等しい場合は\\verb|X|を，等しくない場合には\\verb|Y|を\\verb|c|に代入する例です．\n1  c \u0026lt;= X when a = b else Y;   制御構文というよりは，Cなどで，\\verb|c = (a==b) ? X : Y|と書く3項演算子に近いイメージですね．\nif 〜 then 〜 elsif 〜 else 〜 end if \u0026mdash; 条件分岐構文 \\verb|process|文の中でのみ使用できる条件分岐構文です． 次は，\\verb|a|より\\verb|b|が大きい場合は処理文Xが，それ以外の場合は処理文Yが有効になります．また，処理文の中で\\verb|if|をネスト(入れ子に)することもできます．\n1 2 3 4 5  if a \u0026gt; b then 処理文X else 処理文Y end if;   また，\\verb|elsif|を使うと，\\verb|else|節に重ねて次の条件を記述できます．\n1 2 3 4 5 6 7  if a \u0026gt; b then 処理文X elsif a \u0026lt; b then 処理文Y else 処理文Z end if;   VHDLでは，単に信号の値に対する条件だけでなく，信号が変化するタイミングを使用した条件式が書けます． たとえば，変数clkが変化するタイミングはclk\u0026rsquo;eventと書きますので，これを使って，\n1 2 3  if clk\u0026#39;event and clk = \u0026#39;1\u0026#39; then 処理文 end if;   のような条件文を作ることができます．この例では，「clkが変化し，かつ，clkが1」のときに処理文が実行されます．ハードウェアとしては，clk信号が立ち上がった瞬間に相当します．それ意外のタイミングでは，処理文は動作せず，値が保存し続けられます．これは，決まったタイミングで処理を実行する順序同期回路の設計に欠かせない表現です．\nただし，2018年現在では，多くの場合，直接「クロックの立ち上がり」を表す，\\verb|rising_edge|という関数を使って，\n1 2 3  if rising_edge(clk) then 処理文 end if;   という記述が好まれます．\ncase〜when \u0026mdash; 選択 CやJavaでいうところの\\verb|switch|構文です．次に示す例では，\\verb|std_logic_vector|型の変数aの値によって処理文X，Y，Zのどれかが実行されます．0，1，2という整数と一致させられるように，\\verb|to_integer|を使って\\verb|a|を\\verb|integer|型に変換しています．ここで，VHDLの\\verb|case ~ when|構文では，どれかの\\verb|when|に必ず該当するように記述する必要があることに注意しなければいけません．すべての\\verb|when|を列挙する代わりに「\\verb|others|」で残りすべての条件にマッチする場合を表現できます．\n1 2 3 4 5 6 7 8 9 10  case to_integer(unsigned(a)) when 0 =\u0026gt; 処理文X when 1 =\u0026gt; 処理文Y when 2 =\u0026gt; 処理文Z when others =\u0026gt; --そのほかのすべての場合 処理文W end case;   for 〜 in 〜 loop \u0026mdash; 繰り返し VHDLにおける繰り返し処理は，単に似たような処理を繰り返して記述する代わりに簡単に書けるようにするための構文です．実際には，合成時に繰り返し回数分のハードウェア回路が生成されます．\nたとえば，下記に示す処理は，5bitの\\verb|std_logic_vector|型の変数\\verb|a|と\\verb|std_logic|型の変数\\verb|b|が定義されているときに，\n1 2 3 4 5 6 7 8 9 10  process variable i : integer := 0; variable tmp : std_logic; begin tmp := \u0026#39;0\u0026#39; for i in 0 to 4 loop tmp := tmp or a(i); end loop; b \u0026lt;= tmp end process;   という記述は，次のような記述を簡単に記述したことに相当します．\n1 2 3 4 5 6 7 8 9 10 11 12  process variable i : integer := 0; variable tmp : std_logic; begin tmp := \u0026#39;0\u0026#39; tmp := tmp or a(0); tmp := tmp or a(1); tmp := tmp or a(2); tmp := tmp or a(3); tmp := tmp or a(4); b \u0026lt;= tmp end process;   作成した回路が動作する時ではなく，回路を作成する時点で繰り返し処理が解釈されることに注意してください．\n組み合わせ回路のサブモジュール VHDLでは，複雑な組み合わせ回路を生成するために，\\verb|function|というサブモジュールを記述できます．\\verb|function|は順次処理文で，\\verb|if|や\\verb|case|などの条件文を記述できますが，ノンブロッキング代入を用いることはできません．\\verb|function|は，次のように定義します．\n1 2 3 4 5 6 7 8 9 10 11  function f (a : in std_logic; b : in std_logic) return std_logic is variable Q : std_logic; begin if (a = b) then Q := \u0026#39;1\u0026#39;; else Q := \u0026#39;0\u0026#39;; end if; return Q; end f;   これは，1ビットの変数である\\verb|a|と\\verb|b|を入力とする名前\\verb|f|の\\verb|function|の定義です．入力された二つの値が等しいときに1を，異なるときに0を出力する関数です．\n呼び出し側では，\n1  x \u0026lt;= f(x, y)   などとします．xとyは，関数呼び出しに対する実引き数になります．\nまた次のように，配列型の変数を入力あるいは出力する関数を定義できます．\n1 2 3 4 5 6 7 8  function g (x : in std_logic_vector(1 downto 0)) return std_logic_vector is variable Q : std_logic_vector(1 downto 0); begin Q(0) := x(1); Q(1) := x(0); return Q; end g;   Cなどのソフトウェア・プログラミング言語の関数とは違い，関数の計算が終了するまで呼び出し側の処理が待たされるということはありません． 複雑な組み合わせ回路を見通しよく記述できる書き方です．\nおまじない 実は，ここまで説明してきた\\verb|std_logic|などを利用するには，これらの機能が実装されたライブラリなどを読み込む必要があります． VHDLソース・コードの先頭に以下を記述します．\n1 2 3  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;   Verilog HDLの基本文法のルール Verilog HDLの基本的な文法を説明します．\nコメント 多くのソフトウェア・プログラミング言語と同様に，Verilog HDLでもソースコード中にコメントを書くことができます．Verilog HDLでは，C++と同じように \\verb|/* 〜 */| で囲んだ部分や \\verb|//| から行末までがコメントになります．\nモジュールの構成 図\\ref{fig:verilog_module_overview}に，Verlog HDLで記述するモジュールの概要を示します．VHDLでは，外枠の定義\\verb|entity|と内部の定義\\verb|architecture|が区別されていたのに対し，Verilog HDLにはそのような区別はありません．\\verb|module|の中に，外部と接続されるポートや関数内で使用する変数の宣言，処理内容などを記述します．\n 図5: Verilog HDLのモジュール定義の概要\n  値の表現方法 Verilog HDLでは，必要とするビット幅(\\verb|w|)と基数(\\verb|f|)を付けて「\\verb|w\u0026rsquo;f値|」という形式で即値を記述します．ビット幅は10進数で記述します．ビット幅と基数を省略すると10進数，32bitの値になります．表\\ref{tbl:verilog_value}に，基数と記号と表現される数の関係を示します．\n\\begin{table}[H] \\begin{center} \\begin{tabular}{l|l|l|l} \\hline 基数(w) \u0026amp; 基数記号(f) \u0026amp; 例 \u0026amp; 10進数表記での値 \\\\hline\\hline 2 \u0026amp; \\verb|b| \u0026amp; \\verb|8\u0026rsquo;b10| \u0026amp; 2 \\\\hline 10 \u0026amp; \\verb|d| \u0026amp; \\verb|10\u0026rsquo;d10| \u0026amp; 10 \\\\hline \u0026amp; \u0026amp; \\verb|10| \u0026amp; 10 \\\\hline 16 \u0026amp; \\verb|h| \u0026amp; \\verb|8\u0026rsquo;h10| \u0026amp; 16 \\\\hline \\end{tabular} \\end{center} \\caption{Verilog HDLにおける値の表記例\\label{tbl:verilog_value}} \\end{table}\n型 \u0026mdash; ネット型変数とレジスタ変数 Verilog HDLの変数には，ネット変数とレジスタ変数があります．どちらも1bitの信号に相当する変数と，複数bitの信号を束にした配列変数を作れます．ネット変数とレジスタ変数の違いは，ハードウェアに則したワイヤ(配線)とレジスタ(記憶素子)を想起させるものですが，後で説明するように使える場面と使い方に違いがあります．表\\ref{tbl:verilog_types}に，変数の型を示します．\n\\begin{table}[H] \\begin{center} \\begin{tabular}{l|l} \\hline 型名 \u0026amp; 説明 \\\\hline\\hline \\verb|wire| \u0026amp; 1-bitのネット変数 \\\\hline \\verb|wire[n-1:0]| \u0026amp; n-bitのネット変数 \\\\hline \\verb|reg| \u0026amp; n-bitのレジスタ変数 \\\\hline \\verb|reg[n-1:0]| \u0026amp; n-bitのレジスタ変数 \\\\hline \\end{tabular} \\end{center} \\caption{Verilog HDLにおける型の例\\label{tbl:verilog_types}} \\end{table}\nネット変数 \u0026mdash; wire モジュールやゲート同士を接続する配線に名前を付けた変数が，ネット変数\\verb|wire|です．ネット変数自身は値を保持することはできず，他から代入された値を次に伝達する役目を担う変数です．ハードウェアの配線そのものに相当します．\nレジスタ変数 \u0026mdash; reg レジスタ変数\\verb|reg|は，値を保存する記憶素子になることができ，変数自身が値を保持できます．組み合わせ回路も順序回路も構成できます．\n配列変数 配列変数\\verb|wire[n-1:0]|，\\verb|reg[n-1:0]|は，それぞれ\\verb|wire|あるいは\\verb|reg|からなるn-bitの変数に相当します．幅\\verb|n|のネット変数\n1 2  wire[n-1:0] a; reg[n-1:0] b;    と定義された変数aの各要素をa[0]，a[2:0]などとして取り出すことができます．前者はwire，後者はwire[2:0]の変数です．\nモジュールの外枠の記述 \u0026mdash; module Verilog HDLでは，\\verb|module|でハードウェア・モジュールの外枠を定義します．モジュールの名前と入出力の信号名を定義します．\n1  module test(pClk, pReset, Q);    この文では，\\verb|pClk|，\\verb|pReset|，\\verb|Q|という名前の入出力信号を持つ\\verb|test|という名前のモジュールを定義しています． Verilog HDLでは，この\\verb|module|文から\n1  endmodule    というキーワードまでがモジュールの定義に相当します． moduleの末尾には‘;’(セミコロン)が必要ですが，endmoduleには付けないことに注意してください． ポート名だけを列挙する場合には，後で，各ポートの入出力方向と幅を定義する必要があります．\n少し前のVerilog-95\n1  module test(pClk, pReset, Q);    ポートの定義 ポートとは，モジュールの入出力信号のことです．ポートの名前は，モジュール名に続く()の中に記述します． それぞれのポートの入出力は，モジュールの中で，「方向 型 変数名;」で宣言します． 方向には，\\verb|input|(入力)と\\verb|output|(出力)，\\verb|inout|(入出力)の3種類があります． \\verb|module|文の\\verb|()|内に与えた信号線の型と入出力方向はモジュールの内部で定義します． たとえば，\\verb|pClk|と\\verb|pReset|が1bitの入力，\\verb|Q|が1bitの出力信号であれば，\n1 2 3 4 5 6 7 8  module test(pClk, pReset, Q); input wire pClk; input wire pReset; output wire Q; // 以降，モジュールの内部処理を記述する  endmodule    と記述されます．\n通常Verilog HDLでは，1bitのwire変数は定義せずに使えるため，wireが省略されることがあります． もちろん，n-bitのポートを定義することもでます．Qが幅n-bitの出力ポートであれば，\n1  output wire[n-1:0] Q    と書けます．\nVerilog-2001以降をサポートする処理系の場合には，VHDLのように信号名の定義に型と変数を付けることができます．\n1 2 3 4 5 6 7 8 9  module test( input wire pClk, input wire pReset, output wire Q ); // 以降，モジュールの内部処理を記述する  endmodule    と記述できます．\n定数を定義する module宣言の後に，各モジュール内で有効な定数をparameter文で定義できます．\n1 2 3  module test(pClk, pReset, Q); parameter width = 640; parameter height = 480;    上記に示したモジュールtestの中では，widthを640という値として利用できます．\n内部処理の記述 ポートの宣言に引き続いて，内部で使用する変数の宣言および処理本体を記述します．\n変数の定義 処理に必要な変数をあらかじめ定義しておく必要があります．変数は，ネット接続型あるいはレジスタ型の型を伴って定義されます．\n1 2  wire a; reg[15:0] b;    これは，ネット変数\\verb|a|と幅16ビットのレジスタ変数\\verb|b|を定義しています．\nまた，\\verb|parameter|で定義した定数\\verb|width|を用いて，次のように変数を定義することもできます．\n1  reg[width-1:0] c;    演算子と演算 代表的な演算子を表\\ref{tbl:verilog_operator}にまとめました． 論理演算における真と偽は，ネット変数やレジスタ変数の場合は\\verb|\u0026lsquo;1\u0026rsquo;|と\\verb|\u0026lsquo;0\u0026rsquo;|に対応します． n-bitの配列変数\\verb|wire[n-1:0]|あるいは\\verb|reg[n-1:0]|の場合には，配列中に一つでも\\verb|\u0026lsquo;1\u0026rsquo;|である要素があれば真，さもなければ偽として判定されます．ビット論理演算子を配列変数に適用する場合は，対応する各要素同士について演算が適用されます．\n\\begin{table}[H] \\begin{center} \\begin{tabular}{l|l|l} \\hline 種類 \u0026amp; 演算子 \u0026amp; 説明 \\\\hline\\hline 論理演算 \u0026amp; \\verb|a \u0026amp;\u0026amp; b| \u0026amp; 論理積．aとbが共に真なら真．さもなければ偽．\\\\cline{2-3} \u0026amp; \\verb|a || b| \u0026amp; 論理和．aとbのどちらか又は両方が真なら真．さもなければ偽．\\\\cline{2-3} \u0026amp; \\verb|!a| \u0026amp; 否定．aが真なら偽．偽なら真\\\\hline ビット論理演算 \u0026amp; \\verb|a \u0026amp; b| \u0026amp; 論理積．aとbが共に\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;1\u0026rsquo;．さもなければ\u0026rsquo;0\u0026rsquo;．\\\\cline{2-3} \u0026amp; \\verb|a | b| \u0026amp; 論理和．aとbのどちらか又は両方が\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;1\u0026rsquo;．さもなければ\u0026rsquo;0\u0026rsquo;．\\\\cline{2-3} \u0026amp; \\verb|a ^ b| \u0026amp; 排他的論理和．aとbのどちらか一方が\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;1\u0026rsquo;．さもなければ\u0026rsquo;0\u0026rsquo;．\\\\cline{2-3} \u0026amp; \\verb|~a| \u0026amp; 論理否定．aが\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;0\u0026rsquo;．さもなければ\u0026rsquo;1\u0026rsquo;．\\\\hline 比較演算 \u0026amp; \\verb|a == b| \u0026amp; aとbが等しい場合\\verb|true|．さもなければ\\verb|false|\\\\cline{2-3} \u0026amp; \\verb|a != b| \u0026amp; aとbが等しくなければ場合\\verb|true|．さもなければ\\verb|false|\\\\cline{2-3} \u0026amp; \\verb|a \u0026gt; b| \u0026amp; aがbがより大きいなら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026lt; b| \u0026amp; aとbがより小さいなら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026gt;= b| \u0026amp; aとb以上なら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\cline{2-3} \u0026amp; \\verb|a \u0026lt;= b| \u0026amp; aとb以下なら\\verb|true|．さもなければ\\verb|false|．(*1)\\\\hline 算術演算 \u0026amp; \\verb|a + b| \u0026amp; aとbの足し算\\\\cline{2-3} \u0026amp; \\verb|a - b| \u0026amp; aとbの引き算\\\\cline{2-3} \u0026amp; \\verb|a * b| \u0026amp; aとbの引き算\\\\cline{2-3} \u0026amp; \\verb|a / b| \u0026amp; aとbの割り算\\\\cline{2-3} \u0026amp; \\verb|a % b| \u0026amp; aとbの割り算の余り\\\\hline シフト演算 \u0026amp; \\verb|a \u0026gt;\u0026gt; b| \u0026amp; aとbビット，右にシフト \\\\cline{2-3} \u0026amp; \\verb|a \u0026lt;\u0026lt; b| \u0026amp; aをbビット，左にシフト \\\\hline 条件演算 \u0026amp; \\verb|a ? b : c| \u0026amp; aが真の時b，偽のときc \\\\hline 配列操作 \u0026amp; \\verb|{a,b,c}| \u0026amp; aとbとcをこの順に並べた信号線の束を作る \\\\cline{2-3} \u0026amp; \\verb|a[b] | \u0026amp; aのb番目の信号を取り出す \\\\cline{2-3} \u0026amp; \\verb|a[b:c]| \u0026amp; aのb番目からc番目の信号線の束を取り出す \\\\hline \\end{tabular} \\end{center} \\caption{Verilog HDLで用いられる演算の例\\label{tbl:verilog_operator}} \\end{table}\n演算結果の代入 演算の結果をネット変数あるいはレジスタ変数に代入できます． ネット型変数への代入には\\verb|assign|命令を使用して，下記のように記述します．\n1  assign c = a \u0026amp; b;    これは，ハードウェア的には，演算の結果を信号線に接続することに相当します． ネット変数の代入は後述の同時処理文としてしか記述できません．\n一方，レジスタ変数への代入では，ブロッキング代入とノンブロッキング代入の両方が使えます． Verilog HDLでは，それぞれ下記のように記述します．\n1 2  = // ブロッキング代入 \u0026lt;= // ノンブロッキング代入    たとえば，\\verb|a + b|の演算結果をノンブロッキング代入する場合には，\n1  c \u0026lt;= a + b;    のように記述します． レジスタ変数への値の代入は，ブロッキング代入とノンブロッキング代入のどちらも， 後で説明する順次処理文内でのみ使えます．\n型の変換 VHDLが型に対して厳格であるのに対して，Verilog HDLでは暗黙のうちに型が変換されます． 意識せずに異なるビット幅の変数を演算，代入できます．\nシフト演算 VHDLと異なり，Verilog HDLにはシフト演算子がありますが，シフト演算は大きな回路になってしまいます． 定数分のシフトを行いたい場合は，配列の結合演算を用いて実装する方が小さな回路として実現できます． たとえば，配列変数reg[n-1:0]のcounterを右に1bitシフトしたい場合は，下記のようになります．\n1  {1\u0026#39;b0, counter[n-1:1]};    また，左に2つシフトしたい場合には，\n1  {counter［n-3:0］, 2\u0026#39;b00};    のように記述します．\n同時処理文 ネット型変数の演算結果の代入は，同時処理文を記述します． 記述されたすべての同時処理文は，合成ツールにより同時に解析され，回路として合成されます． つまり，記述された内容は，その順序に依存しません．たとえば，\n1 2  assign c = a \u0026amp; b; assign e = c \u0026amp; d;    という同時処理文の列も，\n1 2  assign e = c \u0026amp; d; assign c = a \u0026amp; b;    の列も，同じように図8の回路が合成されます．\n順次処理文〜always文 \\verb|always|文は，順次処理文を記述するためのブロックを作るものです．順次処理文では，記述された順序に従って意味が解析され， 回路が合成されます．そのため，複雑な制御構文を使用できます． 基本的な構文を下記に示します．変数\\verb|c|，\\verb|d|は\\verb|reg|変数です．\n1 2 3 4  always @(a, b) begin c \u0026lt;= a \u0026amp; b; d \u0026lt;= a | b; end    ここで，\\verb|always @()|の「\\verb|()|」内の変数のリストをセンシティビティ・リストといいます． このリストに列挙した変数が変化すると，プロセス文の中の回路の値が変更されます． ノンブロッキング代入は，always内の処理の解釈がすべて完了したタイミングで，同時更新されることに注意してください． このalways文は，図\\ref{fig:process_example}のような回路になります．\n\\verb|always|文の中にある入力変数(式の右辺にでてくる変数)がすべてセンシティビティ・リストに列挙されている場合， 入力が変化する度に回路が動作し，出力変数(式の左辺)の値が変更されます． つまり，その\\verb|always|文は，何も状態を保存する必要がありません． そのため，記憶素子を必要としない組み合わせ回路として構成されます． ここで，入力に対して常に出力が生成されない場合とは，条件分岐などによって， 入力信号の値によって値の代入が発生しない出力信号がある場合です．\n次のような\\verb|always|文を考えてみます．\n1 2 3 4  always @(a) begin c \u0026lt;= a \u0026amp; b; d \u0026lt;= a | b; end    ここでは，センシティビティ・リストに「\\verb|b|」がなく，入力変数が全部列挙されていません． この回路では，bの値が変化しても出力先であるcとdの値は変化しません． つまり，図\\ref{fig:process_example}のように，入力であるaとbを出力のcとdに直接接続することができず， \\verb|c|と\\verb|d|の値を保存する機構，記憶素子が必要となり，組み合わせ回路としては合成されません． 「同じように記述したつもりでも違う回路になるかもしれない」ということを覚えておいてください．\n\\verb|always|の中では，\\verb|reg|変数にブロッキング代入することもできます． ブロッキング代入では，\\verb|always|中のほかの代入に関係なく，その時点で代入が発生し値が置き換わります． たとえば，次のような\\verb|always|文を考えます．ここで，\\verb|tmp0|，\\verb|tmp1|，\\verb|c|はすべて\\verb|reg|変数とします．\n1 2 3 4 5  always @(a,b) begin tmp0 = a \u0026amp; b; tmp1 = a | b; c \u0026lt;= tmp0 ^ tmp1; end    この場合，\\verb|tmp0|と\\verb|tmp1|ともに，ブロッキング代入で演算の結果が代入されています． ブロッキング代入なので，合成ツールがこの構文に出会ったところで，\\verb|tmp0|は\\verb|(a \u0026amp; b)|に， \\verb|tmp1|は\\verb|(a | b)|にすぐさま置き換わます．つまり，これは単に\\verb|c \u0026lt;= (a \u0026amp; b) ^ (a | b)|という回路に合成されます．\nセンシティビティ・リストには，\\verb|@(a and b)|という条件式が記述できます． これはaとbのどちらかが変化した場合ではなく，\\verb|(a and b)|が変化した場合に\\verb|always|の中の処理を実行できるようにします． 条件式には，信号の立ち上がり，あるいは立ち下がり条件を使用することもできます． 立ち上がりは「posedge」，立ち下がりは「negedge」というキーワードを使います．\n1 2 3  alwasy @(posedge clk) begin 処理文 end    これは，「clkの立ち上がり」のときに処理文が実行されることを意味します． ハードウェア的には，clk信号が立ち上がった瞬間に相当し，それ意外のタイミングでは，処理文は動作せず，値が保存し続けられます． これは，決まったタイミングで処理を実行する順序同期回路の設計に欠かせない表現です．\n制御構文 ソフトウェア・プログミングのように，条件分岐のifやCでいう\\verb|switch|構文のような制御構文が使えます． 多くの制御構文は，\\verb|always|文の中でのみ使用することができます．代表的なものを次に説明します．\nif 〜 begin 〜 end else begin 〜 end \u0026mdash; 条件分岐構文 \\verb|always|文の中でのみ使用できる条件分岐構文です． 次に示す例では，\\verb|a|が\\verb|b|より大きければ処理文\\verb|X|が，それ以外の場合は処理文\\verb|Y|が実行されます． また，処理文の中で，ifをネスト(入れ子)にすることもできます．\n1 2 3 4 5  if (a \u0026gt; b) begin 処理文X end else begin 処理文Y end    case \u0026mdash; 選択 CやJavaでいうところのswitch構文です． 次に示す例では，変数\\verb|a|の値によって処理文X，Y，Zに分岐しています． \\verb|case|構文では，どれかのケースに該当するように記述しましょう． もちろん，すべての条件を列挙してもよいのですが，「\\verb|default|」でどんな値にもマッチする場合を記述できます．\n1 2 3 4 5 6 7 8 9 10  case(a) 0 : 処理文X 1 : 処理文Y 2 : 処理文Z default : 処理文W endcase    繰り返し構文 \u0026mdash; for Verilog HDLにおける繰り返し処理は，単に似たような処理を繰り返して記述する代わりに簡単に書けるようにするための構文です． 実際には，繰り返し回数分のハードウェア回路が生成されます． たとえば，下記に示す処理ですが，\n1 2 3 4 5  tmp = 1\u0026#39;b0; for (i = 0; i \u0026lt; 5; i = i + 1) begin tmp = tmp | a[i]; end b \u0026lt;= tmp;    これは，次のような代入文を記述することに相当します．\n1 2 3 4 5 6 7  tmp = 1\u0026#39;b0; tmp = tmp | a[0]; tmp = tmp | a[1]; tmp = tmp | a[2]; tmp = tmp | a[3]; tmp = tmp | a[4]; b \u0026lt;= tmp;    組み合わせ回路のサブモジュール Verilog HDLでは，複雑な組み合わせ回路を生成するために，\\verb|function|というサブモジュールを記述できます． \\verb|function|は順次処理文で，\\verb|if|や\\verb|case|などの条件文を記述できますが， ノンブロッキング代入を用いることはできません．\\verb|function|は，次のように定義します．\n1 2 3 4 5 6 7 8 9 10 11  function f; input a; input b; begin if(a == b) begin f = 1\u0026#39;b1; end else begin f = 1\u0026#39;b0; end end endfunction    これは，1ビットのネット型信号である\\verb|a|と\\verb|b|を入力とする名前\\verb|f|の\\verb|function|の定義です． \\verb|function|の中で\\verb|f|に値を代入すると，関数の返り値としてセットされます． この例は，入力された二つの値が等しいときに\u0026rsquo;1\u0026rsquo;を，異なるときに\u0026rsquo;0\u0026rsquo;を出力する関数です．\n呼び出し側では，\n1  assign x = f(x, y)    または，always文で\n1  x \u0026lt;= f(x, y)    などとして呼び出せます．ここで，xとyは，関数呼び出しに対する実引数になります．\nまた，次のように，配列型の変数を入力あるいは出力する関数を定義できます．\n1 2 3 4 5 6 7  function [1:0] g; input [1:0] x; begin g[0] = x[1]; g[1] = x[0]; end endfunction    ここで定義した\\verb|function|は，Cの関数とは違い，関数の計算が終了するまで呼び出し側の処理が待たされるような制御を伴うことはなく， 複雑な組み合わせ回路を見通し良く記述するための書き方です．\nまとめ ハードウェア記述言語であるVHDLとVerilog HDLの基本について説明しました． どちらも一般のソフトウェア・プログラミング言語ではなじみの薄い，\n ノンブロッキング代入とブロッキング代入 同時処理文や順次処理文  といった，ハードウェアを設計するための特有の特徴をもっています． とはいえ，分岐構文などを使うと，ハードウェアで実装したい処理をソフトウェア的に設計できます．\n今回は，基本的な文法の説明をかけあしで紹介しました． ソフトウェア・プログラミングを習得する際にはある程度，文法を覚えたあとは， 他人の書いたコードをたくさん読むことで，言語をスムーズに習得できます． ハードウェアを設計するためのHDLプログラミングでも同じです． たとえば，OpenCores.orgには，さまざまなHDLコードが投稿されており， また，米国Sun Microsystems社からは，SPARCプロセッサのHDLコードが公開されています． 習うより慣れろで，どんどん読み書きしてみましょう．\n参考文献  Douglas L.Perry(著)，メンター・グラフィックス・ジャパン株式会社(翻訳)；VHDL(Ascii software science—Language)，1996年10月，アスキー． Bhasker(著)，デザインウェーブ企画室(翻訳)；VHDL言語入門—ハードウェア記述言語によるロジック設計マスタリング(C\u0026amp;E TUTORIAL)，1995年7月，CQ出版社． 長谷川 裕恭；VHDLによるハードウェア設計入門—言語入力によるロジック回路設計手法を身につけよう，2004年4月，CQ出版社． 小林 優；入門Verilog HDL記述—ハードウェア記述言語の速習\u0026amp;実践 改訂，2004年5月，CQ出版社． 井倉 将実；FPGAボードで学ぶVerilog HDL，2007年2月，CQ出版社．  "});index.add({'id':2,'href':'/learning_fpga/docs/book01/quickstart/','title':"クイックスタート",'content':" FPGA開発におけるHello World Lチカ を通して，開発の手順に慣れよう\nはじめに この章では，FPGA開発におけるHello World，すなわち最初に試してみるサンプルとして Lチカ を題材に，開発の手順に慣れてみましょう． Lチカ とは，「LEDをチカチカさせる」の略です．\n単にLEDとチカチカさせるだけ，なのですが，開発の手順を身につけるには十分です．また，実際多くの信号制御は何かしらの規則にしたがって信号をON/OFFしていることですから，すべての信号制御はLチカの応用にあるとも言えます．簡単ですが大事ですよ．\n実習 プロジェクトの用意 \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_24.png} \\end{center} \\caption{VivadoのFileメニューから，New Project\u0026hellip;を選択する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_32.png} \\end{center} \\caption{プロジェクト作成ダイアログが開くので，Next$\\gt$で次へ} \\end{figure}\nプロジェクト名と格納先を決めます．ここでは，ホームディレクトリの下のVivadoというフォルダの下にプロジェクトを格納することとし，名前をproject_1としています． \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_37.png} \\end{center} \\caption{プロジェクト名と格納先を決めます} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_01_43.png} \\end{center} \\caption{プロジェクトタイプの指定です．RTLプロジェクトを指定します} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_24.png} \\end{center} \\caption{すでにソースコードがある場合にはここで追加できます．今回はないのでNext$\\gt$で，そのまま次へ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_30.png} \\end{center} \\caption{すでに制約ファイルがある場合にはここで追加できます．今回はないのでNext$\\gt$で，そのまま次へ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_49.png} \\end{center} \\caption{ターゲットとするFPGAの選択画面です．BoardタブをクリックしZybo Z7-20を選択して$\\gt$で次へ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_02_55.png} \\end{center} \\caption{確認画面です．Finishをクリックするとプロジェクトの作成は完了です} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_06.png} \\end{center} \\caption{プロジェクト作成には少し時間がかかります} \\end{figure}\nこれでプロジェクトの完成です．Product FamilyがZynq-7000に，Project Summaryの表示を見ると，Project partがZybo Z7-20と，Z7-20向けのプロジェクトができていることがわかります． \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_17.png} \\end{center} \\caption{プロジェクトができあがりました．} \\end{figure}\nファイルの作成 作成したプロジェクトで，LEDをチカチカさせるためのデザインを追加していきます．ここではVivadoのウィザードを使ってデザインファイルを用意する方法ですすめていきます．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_27.png} \\end{center} \\caption{SourcesのDesign Sourceの上で右クリックし，Add Sources\u0026hellip;を選択する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_35.png} \\end{center} \\caption{ファイル追加ダイアログが開く} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_42.png} \\end{center} \\caption{2番目のAdd or create design sources\u0026hellip;にチェックをいれてNext$\\gt$をクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_03_54.png} \\end{center} \\caption{ここで新しくファイルを作るので，Create Fileをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_04_01.png} \\end{center} \\caption{使用言語とモジュール名を決めます．ここではVHDLを使うこととし，名前をtopと決めてOKをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_04_44.png} \\end{center} \\caption{作成するファイルがリストに登録されたので，Finishをクリックします} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_04_59.png} \\end{center} \\caption{新たに作成したtopモジュールのポートなどを定義することができます．あとで自分で書いてもいいのですが，入力ポートのclkと出力ポートのledを追加しましょう．OKをクリックします} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_05_13.png} \\end{center} \\caption{作成したtopモジュールがプロジェクトに組み込まれました} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_06_55.png} \\end{center} \\caption{組み込まれたtopをダブルクリックするとファイルを編集することができます} \\end{figure}\nデザインの修正 ウィザードで作成したtopモジュールは雛形でしかないので，このままでは，もちろん所望の動作はしません．次の内容で書き変えてください．スペースの都合上，作成されたコメントは取り除いています．ファイルを編集するときには気をつけてください．また，リスト中のコメントは説明上のものですので，実際には入力する必要はありません．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library IEEE; use IEEE.STD_LOGIC_1164.ALL; use ieee.numeric_std.all; \u0026ndash; 追加する．数値演算に必要(1)．\nentity top is Port ( clk : in STD_LOGIC; led : out STD_LOGIC); \u0026ndash; このPortはウィザードで作成された end top;\narchitecture Behavioral of top is\n\u0026ndash; 次の行を追加．カウンタ変数の定義(2)． signal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;);\nbegin \u0026ndash; 追加，ここから(3) led \u0026lt;= std_logic(counter(23)); \u0026ndash; カウンタの23bit目をledに接続\nprocess(clk) \u0026ndash; クロックの変化で動作するプロセス begin if rising_edge(clk) then \u0026ndash; クロックの立ち上がりであれば counter \u0026lt;= counter + 1; \u0026ndash; カウンタをインクリメント end if; end process; \u0026ndash; 追加，ここまで end Behavioral; \\end{Verbatim} \\end{quote} \\end{figure}\n追加箇所は多くないので，少し詳しくみてみましょう．\n追加箇所(1) 数値演算に必要なライブラリ，今回の場合でいうと``+\u0026ldquo;演算を利用するために\\verb|use ieee.numeric_std.all|という前置きをしています．\n追加箇所(2) LEDチカチカの，``チカチカ\u0026rdquo;というタイミングを制御するためのカウンタ変数を定義です．+演算を利用したいので\\verb|unsigned|型で定義しています．\n追加箇所(3) いわば処理の本体です．一行目の代入文は，定義したcounter変数の23bit目を出力ポートであるledに接続することを意味しています．\\verb|unsigned|の1bitですので\\verb|std_logic|に型変換しています．次のprocess文では，clkが立ち上がることにcounterに1を足すことを意味しています．すなわち，(3)で追加した部分では，clkの立ち上がり8M回毎にledの\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;が反転する回路を定義していることになります．\nまずは合成してみる ファイルの編集がおわったら合成してみましょう．といっても，左サイドにあるFlow Navigatorの中にあるRun Synthesisをクリックするだけです．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_07_02.png} \\end{center} \\caption{Run Synthesisをクリックすると合成開始ダイアログが開く．OKをクリックして合成を開始} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_07_16.png} \\end{center} \\caption{合成中は，Running Synth_designの横に，ぐるぐるアニメーションが表示される} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_08_08.png} \\end{center} \\caption{合成が完了した} \\end{figure}\nI/Oの設定 合成が完了したことでデザインがVivadoに受け付けられることが確認できました．しかし，これでそのままFPGAでデザインが動くわけではありません．I/Oピンの設定をしていないからです．HDLのデザイン上は，入力ポートclkと出力ポートのledを定義しましたが，Vivadoは，このポートをFPGAのどのピンに割り当てていいか分かりません．FPGAを使った開発では人手でこの割り当てを決める必要があります．\nピンの割当ては合成結果を下敷にGUIで行なうことができます．まずは，合成結果を表示します．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_08_14.png} \\end{center} \\caption{合成後のダイアログで，``Open Synthesized Design\u0026rdquo;を選択し，OKをクリックする} \\end{figure}\nもし，うっかり合成後のダイアログを閉じてしまったり，ピン配置を指定しないまま次のステップにすすんでしまった場合には，Flow Navigatorの中にあるOpen Synthesized Designをクリックしましょう．\n合成結果が表示できたら，LayoutのI/O PlanningをクリックしてI/O設定用のモードに変更します． \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_09_32.png} \\end{center} \\caption{LayoutのI/O PlanningをクリックしてI/O設定用のモードに変更} \\end{figure}\n画面下のI/O割当て表でピン配置を決定します．clkとledのPackage pinを，それぞれ，K17とM14に決め，どちらもI/O stdをLVCMOS33を選択します． \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_45_27.png} \\end{center} \\caption{I/Oのピン割り当てを決める} \\end{figure}\n合成・配置配線 ピン配置がおわったので，FPGA向けの書き込みファイルを作成します．Flow Navigatorの中にあるGenerate bitstreamをクリックするだけです．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_15_52.png} \\end{center} \\caption{Flow Navigatorの中にあるGenerate bitstreamをクリックする．必要な合成・配置配線は一気通貫に実行される \\label{fig:file_save_dialog}} \\end{figure}\n制約ファイルの保存 おそらく先のピン配置の変更が保存されていないので，図\\ref{fig:file_save_dialog}のダイアログが開くことでしょう．もちろん保存してください．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_15_59.png} \\end{center} \\caption{ピン配置の変更が保存されてないために表示されるダイアログ．Saveをクリック． \\label{fig:file_save_dialog}} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_16_26.png} \\end{center} \\caption{ファイル保存すると合成の結果が無効になるよという警告．OKで閉じる．} \\end{figure}\n制約ファイルの指定(最初だけ) はじめは，保存先のファイルが用意されていないので，図\\ref{fig:xdc_config}のダイアログが開きます．ここでは，HDLモジュールと同じ名前のtopというファイル名にします．なお，拡張子はxdcで自動的に付与されます．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_16_35.png} \\end{center} \\caption{ピン配置を保存するファイルの作成を促すダイアログ．topという名前にしてOKをクリック \\label{fig:xdc_config}} \\end{figure}\n合成・配置配線の開始 指定したピン配置の設定によって合成からやりなおしになります．``Yes\u0026rdquo;をクリックしてフローをすすめます．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_16_41.png} \\end{center} \\caption{合成からやりなおし} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_16_46.png} \\end{center} \\caption{合成開始ダイアログ．OKで合成を開始．} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_20_45.png} \\end{center} \\caption{合成が無事に完了した．メインウインドウにCompleteという文字と緑のチェックマークがついている \\label{fig:completed}} \\end{figure}\n配置配線結果の確認 配置配線後，どのようにFPGA上に回路が配置されたかを確認することができます．今回は指定していませんが，動作クロックの指定を行った場合などには，正しくクロックの指定ができているか，その指定にあった回路ができているか，を確認する必要があります．\n今回は，まず雰囲気だけみてみましょう．合成後の図\\ref{fig:completed}のダイアログで，Open Implementation DesignにチェックをいれてOKをクリックするか，Navigator FlowでOpen Implemnetation Designをクリックします．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_21_16.png} \\end{center} \\caption{配置配線結果を開いてみたところ．右側の水色部分が使用しているハードウェアリソース} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_22_24.png} \\end{center} \\caption{接続パスを表示し，拡大してみたところ} \\end{figure}\n実機での動作確認 できあがったデータをFPGAボードにダウンロードして動作させてみましょう．\nまずは，FPGAとパソコンをUSBケーブルで接続します．ここで，JP5のジャンパをJTAGに，JP16のジャンパをUSB側にセットしておいてください．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/IMG_0002.JPG} \\end{center} \\caption{FPGAとパソコンをUSBケーブルで接続．JP5とJP16の位置にも注意} \\end{figure}\n書き込みの手順は次の通りです．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_34_35.png} \\end{center} \\caption{Navigator FlowでOpen Hardwareをクリックしたところ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_34_45.png} \\end{center} \\caption{Open Targetをクリックし，Auto Connectをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter03_figures/VirtualBox_Windows10_19_03_2018_00_51_49.png} \\end{center} \\caption{FPGAボードと接続できたら，Program Deviceをクリック．開いたファイルダイアログでOKをクリック．} \\end{figure}\nこれでFPGAボード上のLED LD0が点滅するはずです．\n課題  点滅の間隔を変えてみよう FPGA上のほかのLEDも点滅させてみよう  "});index.add({'id':3,'href':'/learning_fpga/docs/book01/simulation/','title':"シミュレーション",'content':" この章では，``Lチカ\u0026rdquo;を題材に設計したデザインがどのように動いているのか，Vivado付属のシミュレータを使ったシミュレーションによって確認する方法を学びます．\nはじめに 実際の開発現場で不具合を解析するときにもシミュレーションは大変有用な手段です．\nHDLで記述したアプリケーション回路をFPGA上で動作させるためには，合成や配置配線を実行してFPGA書き込み用のコンフィギュレーション情報のファイルを生成する必要があります．回路規模が大きくなると，コンフィギュレーション情報を作成するのにも長い時間が必要になります．しかし，シミュレーションの場合は簡単なコンパイルでおしまいです．デバッグなどで，何度もソース・コードを変更するような場合には，シミュレータで動作を確認できれば圧倒的に短時間で済みます．\nまた，FPGAで動作しているアプリケーション回路の各信号が，どのように変化しているか，外から観測するのはなかなか難しいものです．一方で，シミュレーションでは自由に記述したロジックの信号の変化を観察できます．\nそのため，シミュレーションを使用した内部の信号の観測がHDLレベルでの論理的なデバッグに有効です．この章では，このHDLコードの動作をVivadoシミュレータでシミュレーションする方法を学びましょう．\nシミュレーションに必要なもの \u0026mdash; テスト・ベンチ CPUを買ってきても，マザーボードがないとパソコンとして動かないように，FPGAも周辺部品の載った``マザーボード\u0026rdquo;がないと動きません．FPGAもFPGA単体では動作せず，MicroBoardやDE0 nanoに搭載されているような回路を駆動するクロック信号やリセット信号が必須です．\n実際にFPGAを使ったシステムでは，クロックは外から与えられるものですが，シミュレーションでは，FPGAに実装したHDLモジュールが動作するのに必要なクロック信号やリセット信号なども自前で用意しなければなりません(図\\ref{fig:test_bench_image})．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.95\\textwidth]{chapter04_figures/test_bench_image.png} \\end{center} \\caption{設計したモジュールを実機で動作させる場合(a)とシミュレーションする場合(b)の違い．シミュレーションする場合にはテスト・ベンチを用意する必要がある．\\label{fig:test_bench_image}} \\end{figure}\nといっても，とりたてて新しく特別なことを覚える必要があるわけではありません．外から与えられるべきクロック信号やリセット信号もHDLで記述できます．これをシミュレーション・コードやテスト・ベンチと呼びます．シミュレーション対象のモジュールで必要となる信号は，すべてテスト・ベンチで生成します．テスト・ベンチの記述方法はHDLソースとほとんど同じで，違いは下記の3つになります．\n エンティティの中身(モジュールの入出力信号)が空である 時間を表す構文を使って信号の振る舞いを規定する ハードウェアでは実現できない仮想的な機能を利用できる  設計したHDLモジュールを動作させるのには必要な，マザーボードに相当する部分をすべて記述しなければなりません．逆にいうと，テスト・ベンチは外部との入出力があってはいけないということです．そのため，VHDLの場合はテスト・ベンチのエンティティの中身が，Verilog HDLの場合moduleの引数が空になるというわけです．\nテスト・ベンチでは 時間 を表現する必要がある 「スイッチを10秒押してから離す」や「50MHzの信号」などの振る舞いは時間を扱うので，HDLのビヘイビア・モデル（動作記述）を用いて記述します．\nたとえば，「10nsの時間を待つ」という動作はHDLで次のように記述します．この記述はビヘイビア・モデルの基本中の基本です． VHDLで記述する場合は， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] wait for 10ns; \\end{Verbatim} \\end{quote} \\end{figure} Verilog HDLで記述する場合には，初めにtimescaleを使って， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] timescale 1ns / 1ps \\end{Verbatim} \\end{quote} \\end{figure} と，シミュレーションの単位時間を指定して，時間を挿入したい個所で \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] #10 \\end{Verbatim} \\end{quote} \\end{figure} と記述すると，指定した単位時間分の時間(この例では10ns)を作ることができます．\nテストベンチの書き方 またか!!という感も否めませんが，「LEDチカチカ」に再び登場してもらいましょう．コードは次の通りです．前章で利用したコードといくつかの違いがあります．\nresetの追加 回路を初期化するための入力信号としてresetを追加しています．\nLEDに出力するbitを変更 実機ではカウンタの23bit目をledに接続しましたが，クロックの立ち上がりを8M回待つのは大変なので3bit目をledの出力に接続しています．\nモジュールのタイプをRTLに変更 モジュールのタイプをBehaviorではなくRTLとしています．実際のところ今のVivadoでは，ここのキーワードは特に意味をなさないのですがシミュレーションのためのテストベンチをBehavior，合成してハードウェア化もするファイルはRTLと分けておくと見分けるのが容易になります．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top;\narchitecture RTL of top is\nsignal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;);\nbegin\n\u0026ndash; カウンタの3bit目をledに接続(実機では23bit目を使った) led \u0026lt;= std_logic(counter(3));\nprocess(clk) \u0026ndash; クロックの変化で動作するプロセス begin if rising_edge(clk) then \u0026ndash; クロックの立ち上がりであれば if reset = \u0026lsquo;1\u0026rsquo; then counter \u0026lt;= (others =\u0026gt; \u0026lsquo;0\u0026rsquo;); else counter \u0026lt;= counter + 1; \u0026ndash; カウンタをインクリメント end if; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\caption{シミュレーション対象のコード\\label{fig:target_list}} \\end{figure}\nFPGA上に実装する場合には，第3章で紹介したように，3つの入出力信号をFPGA上の適切なI/Oに接続しなければなりません．一方，ソフトウェアで動作をシミュレーションするためには，これらの信号テスト・ベンチで生成して外から与える，ことにします．\nクロックを生成するテスト・ベンチ 順序回路の要がクロック信号です．従って，クロック信号の生成はテスト・ベンチの基本中の基本です．\nカウンタ・モジュールの動作をシミュレーションするために， \\verb|clk|に50MHzのクロック信号，すなわち10nsごとに\\verb|‘1’|と\\verb|‘0’|を繰り返す信号をテスト・ベンチで生成してみましょう． 記述方法は，次の通りです．\nVHDLで記述する場合 信号\\verb|clk_i|を定義し，\\verb|clk_i|に‘1’を代入して10ns待ちます．その10ns後\\verb|clk_i|に‘0’を代入，その10n後に再び‘1’を\\verb|clk_i|に代入，…ということを繰り返すことで，10nsで周期的に0→1→0→1\u0026hellip;と変化する信号，すなわち50MHzのクロック信号が生成できます． VHDLのコードで素直に実装すると，「10ns待つ」処理に相当する「wait for 10ns」を使って， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] process begin clk_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; wait for 10ns; clk_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait for 10ns; clk_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; wait for 10ns; clk_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait for 10ns; \u0026hellip; end process; \\end{Verbatim} \\end{quote} \\end{figure} となります．\nこの\\verb|process|文には，きっかけになる信号なしで，シミュレーションの開始同時にすぐさま処理が開始されます． もちろん，これでもよいのですが，実はプロセス文は最後まで到達すると，また先頭から開始されるので \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] process begin clk_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; wait for 10ns; clk_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait for 10ns; end process; \\end{Verbatim} \\end{quote} \\end{figure} という記述で，ずっとクロック信号を作り続けることができます．\nVerilog HDLで記述する場合 Verilog HDLでは，「単位時間XXが経過」を「\\verb|#XX|」で表現できますから，\\verb|clk_i|に\u0026rsquo;1\u0026rsquo;を代入したあと， 「単位時間10が経過」の後\\verb|clk_i|に\u0026rsquo;0\u0026rsquo;を代入して，また「単位時間10が経過」の後\\verb|clk_i|に\u0026rsquo;1\u0026rsquo;を代入\u0026hellip; と繰り返すことで，1→0→1→\u0026hellip;というシーケンスが定義できます．\nVerilog HDLでは，initial文で，シミュレーション実行開始時に一度だけ処理されるブロックを定義できます． すなわち，次のコード片で，シミュレーション開始後から単位時間10毎に信号を反転させる処理，つまり50MHzのクロック信号を生成できます． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] initial begin clk_i = 0; #10; clk_i = 1; #10; \u0026hellip; forever #10 clk_i = !clk_i; end \\end{Verbatim} \\end{quote} \\end{figure}\nずっと繰り返す処理を意味する\\verb|forever|を使って， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] initial begin clk_i = 0; forever #10 clk_i = !clk_i; end \\end{Verbatim} \\end{quote} \\end{figure} と記述することもできます．\n必要な入力信号を生成する 図\\ref{fig:target_list}に示したリストの動作をシミュレーションするにはクロック信号clk以外に，人間が「えいやっ」とリセット・ボタンを押すことに相当するreset信号もテスト・ベンチで生成しなければいけません．\nところで，人間がリセット・ボタンを押すのは，いつ，どのくらいの時間でしょうか？「リセット・ボタンは電源投入の5秒後に10ミリ秒間押される」などと決められるわけではありません．\n従って，テスト・ベンチでは，シミュレーション対象の回路に対して，それらしい信号を想定して生成する必要があります．リセット・ボタンが押されるタイミング，であれば，特に制約があるわけではありませんので，電源投入後の適当な時刻に検知できる時間だけの信号が与えられる，という想定で十分でしょう．\nリセット信号を生成する方法は，\n クロックと同じプロセス・ブロックで記述する 別のプロセスのブロック内で記述する  の2種類が考えられます．\nここでは，クロックとは別のプロセス・ブロック内で，変数\\verb|reset_i|の値を0→1→0と変化させることで，リセット・ボタンが押されたことに相当する信号を生成することにします．Verilog HDLであれば，リセットに相当するレジスタ変数\\verb|reset_i|が適当なタイミングで変化するように記述できます． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] initial begin reset_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; \u0026ndash; 最初はリセット信号は\u0026rsquo;0\u0026rsquo; wait for 5ns; reset_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; \u0026ndash; 5n秒後にリセット信号を\u0026rsquo;1\u0026rsquo;に wait for 100ns; reset_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; \u0026ndash; しばらくしたら(100n秒後)，リセット信号を\u0026rsquo;0\u0026rsquo;に wait; \u0026ndash; 以降は何もしない end \\end{Verbatim} \\end{quote} \\end{figure}\nテスト・ベンチとシミュレーション対象のモジュールを接続する FPGA上に書き込んだ回路に信号を与えるためには，物理的にクロックやスイッチの端子を配線することになります． シミュレーションする場合には，シミュレーション対象のモジュールとテスト・ベンチで生成した信号をHDL的に接続する必要があります．\n一般的には，テスト・ベンチをトップ・モジュールとして， その中でカウンタ・モジュールをサブモジュールとして呼び出すことにします． これはマザー・ボードがあって，その中にFPGAがあって回路が動いている，という物理的な構造に上手くマッチします． VHDLもVerilog HDLも，モジュールを階層的に定義する仕組みをもっています．\nVHDLでは，\n LEDチカチカ回路のインターフェースを宣言 LEDチカチカ回路のインスタンスを生成する  の2段階で，サブモジュールとして回路を呼び出すことができます．\n具体的には，はじめに，次のように， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; サブ・モジュールであるtestの素性を記述 component test port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end component; \\end{Verbatim} \\end{quote} \\end{figure} \\verb|component|として，使用するモジュールの素性を宣言したあとで，次のように \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; サブ・モジュールをインスタンス化する U: test port map( clk =\u0026gt; clk_i, reset =\u0026gt; reset_i led =\u0026gt; led, ); \\end{Verbatim} \\end{quote} \\end{figure} このモジュールのインスタンスを生成，配線関係を記述します．\nプログラミング言語Cでも，関数を呼び出す時には，関数の素性を明らかにするために「プロトタイプ宣言」をした上で， 関数呼び出し文を書きますよね．VHDLでも同じようなものだな，と考えてもらえればよいでしょう．\nテスト・ベンチの全容 説明が長くなりましたが，図\\ref{fig:target_list}のリストをシミュレーションするためのテスト・ベンチの全容は， 図\\ref{fig:simulation_list}のようになります．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top_sim is end top_sim; architecture Behavioral of top_sim is \u0026ndash; シミュレーション対象のモジュールを宣言 component top Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end component top; \u0026ndash; シミュレーション対象のモジュールの信号用の変数を宣言 signal clk_i : std_logic := \u0026lsquo;0\u0026rsquo;; signal reset_i : std_logic := \u0026lsquo;0\u0026rsquo;; signal led_i : std_logic := \u0026lsquo;0\u0026rsquo;; begin \u0026ndash; シミュレーション対象のモジュールのインスタンス生成 U : top port map( clk =\u0026gt; clk_i, reset =\u0026gt; reset_i, led =\u0026gt; led_i ); \u0026ndash; クロックを生成 process begin clk_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; wait for 10ns; clk_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait for 10ns; end process; \u0026ndash; リセット信号の生成 process begin reset_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait for 5ns; reset_i \u0026lt;= \u0026lsquo;1\u0026rsquo;; wait for 100ns; reset_i \u0026lt;= \u0026lsquo;0\u0026rsquo;; wait; end process; end Behavioral; \\end{Verbatim} \\end{quote} \\caption{図\\ref{fig:target_list}をシミレーションするためのVHDLによるテスト・ベンチ\\label{fig:simulation_list}} \\end{figure}\nシミュレーションの実行手順 シミュレーションのテスト用に新しくプロジェクトを作成しましょう． プロジェクト名は，\\verb|project_2|としました．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_11_59_40.png} \\end{center} \\caption{新しく作成したプロジェクト} \\end{figure}\n前章と同様にtopモジュールを作成・追加してプロジェクトを作成したら， topモジュールの中身を図\\ref{fig:target_list}のように変更しておきます．\n以降の手順は次の通りです．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_11_59_46.png} \\end{center} \\caption{Sourcesの中のSimulation Sourcesの上で右クリックしてAdd Sourcesを選択} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_11_59_52.png} \\end{center} \\caption{``Add or create simulation sources\u0026rdquo;にチェックが入っていることを確認してNextをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_00_00.png} \\end{center} \\caption{ファイル追加ダイアログで，Create Fileを選択} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_01_34.png} \\end{center} \\caption{VHDLファイルとして，top_simという名前のモジュールを作成する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_01_42.png} \\end{center} \\caption{リストに追加された} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_01_49.png} \\end{center} \\caption{ポートの指定ダイアログ．今回は何もせずにOKをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_01_54.png} \\end{center} \\caption{変更ないことを確認されるのでYesをクリックして，作業ステップをすすめる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_02_05.png} \\end{center} \\caption{シミュレーション用のモジュールがプロジェクトに追加された} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_06_25.png} \\end{center} \\caption{シミュレーションコードをtop_simに反映したところ．top_simからtopのモジュールがUという名前でインスタンス化されている様子が階層化されて表示される．} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_06_33.png} \\end{center} \\caption{Flow NavigatorのRun Simulationでシミュレーションの開始} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_06_40.png} \\end{center} \\caption{Run Behavioral Simultaionを選択} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_06_45.png} \\end{center} \\caption{シミュレーション開始には少し時間がかかる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_07_37.png} \\end{center} \\caption{シミュレーションが開始された} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_07_58.png} \\end{center} \\caption{シミュレーション時間を指定して，シミュレーションステップをすすめる} \\end{figure}\n指定した時間のシミュレーションが終わるとストップします．いつまでもストップしない場合には，一時停止アイコンをクリックして，強制的に止めることができます．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_05.png} \\end{center} \\caption{指定した時間のシミュレーションが終了} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_09.png} \\end{center} \\caption{波形表示画面に全シミュレーション結果を表示(FIT)させたところ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_29.png} \\end{center} \\caption{一部分を拡大した様子．3bit目をledに接続しているため8クロック毎にledがON/OFFしている様子がみてとれる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_38.png} \\end{center} \\caption{内部モジュール(今回でいうとtopの中身を確認することもできる)} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_48.png} \\end{center} \\caption{topモジュールのcounterを波形表示画面に追加．ただし，内部の値の多くは非表示状態では保存されていないので，そのままでは値の変化を確認できない} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_52.png} \\end{center} \\caption{シミュレーションを一度リセット} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_08_58.png} \\end{center} \\caption{再度シミュレーション．今度は時間指定なくシミューレションしてみる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_09_04.png} \\end{center} \\caption{いつまでも終わらないので一時停止アイコンでシミュレーションをストップ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_09_10.png} \\end{center} \\caption{ストップした箇所のソースコードが表示される} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter04_figures/VirtualBox_Windows10_19_03_2018_12_09_39.png} \\end{center} \\caption{波形を確認してみると，内部のcounterがclkにあわせてインクリメントしていること，counterの3bit目がledの\u0026rsquo;0\u0026rsquo;/\u0026lsquo;1\u0026rsquo;と同じであることが確認できる} \\end{figure}\n課題  点滅の間隔を変えてみたときの様子をシミュレーションしてみよう resetを適当なタイミングで変化させてみて，counterやledの振る舞いを観察してみよう  "});index.add({'id':4,'href':'/learning_fpga/docs/book01/basics/','title':"基本実験",'content':" かんたんな実験を通じてFPGAでのハードウェア作りの基礎力を手に入れましょう．\nはじめに いくつかの簡単なHDLコードを書いて，FPGAでのハードウェア作りの基礎力を手に入れましょう．実際にHDLコードを書き，シミュレーションして，実機動作を確認することは，より複雑なハードウェアを設計するための第一歩です．\nILAを使ってFPGA内部の信号を観測する FPGAは，FPGAの中で回路がどのように動作しているのかを知るためのILA(Internal Logic Analyzer)という仕組みを持っています．実験コードを書きはじめる前に，このILAの使い方を学んでみましょう．\nLチカでILAの動作を学ぶ 三度目の登場ですが，LチカでILAの動作を学びましょう．第4章で利用した\\verb|project_2|を使用します．\n準備 ILAを使ってデバッグするために，topモジュールのソースコードを次のように書き変えてください．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top;\narchitecture RTL of top is\nattribute mark_debug : string; \u0026ndash; (1) 追加 signal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;); attribute mark_debug of counter : signal is \u0026ldquo;true\u0026rdquo;; \u0026ndash; (2) 追加\nbegin\n\u0026ndash; カウンタの3bit目をledに接続(実機では23bit目を使った) led \u0026lt;= std_logic(counter(3));\nprocess(clk) \u0026ndash; クロックの変化で動作するプロセス begin if rising_edge(clk) then \u0026ndash; クロックの立ち上がりであれば if reset = \u0026lsquo;1\u0026rsquo; then counter \u0026lt;= (others =\u0026gt; \u0026lsquo;0\u0026rsquo;); else counter \u0026lt;= counter + 1; \u0026ndash; カウンタをインクリメント end if; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\caption{ILA実験用に変更したリストの例} \\end{figure}\n(1)と(2)が追加ポイントです．(1)で\\verb|mark_debug|というattributeを利用することを宣言し，(2)でcounterに\\verb|mark_debug|というattributeを付与しています．attributeは，ツールに対する指示子です．Vivadoでは，\\verb|mark_debug|を付与した信号はデバッグ対象の可能性があるとして特別扱いします．\nコードが準備できたら，一度合成してピン配置まで終わらせてしまいましょう．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_59_41.png} \\end{center} \\caption{I/O Planningでclk，reset，ledのピン配置を決定する} \\end{figure}\nILAのセットアップと利用方法 準備ができたらILAを追加して，その動作の様子を確認してみましょう．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_57_01.png} \\end{center} \\caption{一度合成する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_13_58_37.png} \\end{center} \\caption{合成が終わったらOpen Synthesized Designで合成結果を開く} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_00_09.png} \\end{center} \\caption{LayoutメニューのDebugをクリックしてデバッグビューに変更する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_37.png} \\end{center} \\caption{ILA設定用の画面 \\label{fig:debug_mode_view}} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_43.png} \\end{center} \\caption{下にある虫みたいなアイコンをクリックしてILA設定用のウィザードを開く} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_03_58.png} \\end{center} \\caption{ILA設定用ウィザードの開始} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_03.png} \\end{center} \\caption{mark_debugを付与したcounterがリストに追加されているので，そのままNextですすむ．ここで新たにILAによる観測対象を追加したい場合には+アイコンをクリックすると信号を選ぶことができる．逆にリストにある信号を対象から取り除きたい場合には，取り除きたい信号を選択して-をクリックする} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_08.png} \\end{center} \\caption{ILAで取得するデータ数の設定など．今回はそのままにしてNextですすむ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_13.png} \\end{center} \\caption{サマリの表示．Finishで完了} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_28.png} \\end{center} \\caption{ウィザードが閉じてILAの設定は完了．ILAが追加できていることがわかる．あとは，Generate Bitstreamでビットファイルを作成すればよい．} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_33.png} \\end{center} \\caption{ILAの設定情報をxdcファイルに保存してよいかの確認．Yesで次のステップにすすむ．} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_44.png} \\end{center} \\caption{Generate bitstreamの前に依存する他のタスクを実行します，という確認ダイアログ．Yesで次のステップへ} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_04_49.png} \\end{center} \\caption{合成と配置配線の開始} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_23_17.png} \\end{center} \\caption{無事に合成と配置配線が終了しビットファイルができあがったところ．Open Hardware Managerを選択してOKをクリックすることで，ハードウェアマネージャの起動の手間を省くことができる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_23_59.png} \\end{center} \\caption{FPGAとパソコンをUSBケーブルで接続してAuto connectで認識させた後，Program Deviceをクリック} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_06.png} \\end{center} \\caption{bitファイルはFPGAに，ILAのパソコン側の定義ファイルであるilxはVivadoに読み込ませる．} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_16.png} \\end{center} \\caption{書き込み中} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_38.png} \\end{center} \\caption{FPGAへのダウンロードが終了した．また，ILAによる動作のモニタ画面が表示された} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_24_53.png} \\end{center} \\caption{二重矢印のアイコンをクリックすると，その時点での値をキャプチャしてくれる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_07.png} \\end{center} \\caption{虫眼鏡アイコンで拡大すると，値が1ずつ増えていることが確認できる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_21.png} \\end{center} \\caption{実機デバッガでは値をキャプチャする条件(トリガ条件)を指定する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_27.png} \\end{center} \\caption{counterの値をトリガ条件に使用することとする} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_34.png} \\end{center} \\caption{counterの値がトリガ条件として登録された} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_25_50.png} \\end{center} \\caption{counterが00001000になった時点でキャプチャするように設定．トリガ値を指定したら三角アイコンでキャプチャを開始する} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_27_49.png} \\end{center} \\caption{counterが00001000になった時点のデータをキャプチャすることができた} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_28_03.png} \\end{center} \\caption{トリガにはドントケア(X)を指定することも可能．ここでは下位16bitが3000になるデータを取得するように指定してみる} \\end{figure}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_28_15.png} \\end{center} \\caption{上位16bitは指定なく，下位16bitが3000の時点のデータがキャプチャできていることがわかる} \\end{figure}\nILA挿入すると回路は変わる 重要な点ですが，ILAを挿入すると，挿入前とは異なるハードウェアになることを理解しておく必要があります．ILA向けのリソース使用量が増えるのはもちろん，観測対象の信号の接続関係も変化します．また観測のために残すべきレジスタの都合で最適化の結果もかわってきます．\nたとえば，図\\ref{fig:without_mark_debug}は，counterにmark_debugアトリビュートを付与せずに合成した場合のデバッグビューです．3bit目をledに接続し，それ以上のbit数の値は利用さていないため，ばっさりと回路が小さくなっていることがわかります．\nしかし，mark_debugアトリビュートを付与して合成した場合には，もちろん最適化するわけにはいかないため，図\\ref{fig:debug_mode_view}のように要/不要にかかわらず32bit分すべてのレジスタが回路として生成されています．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter05_figures/VirtualBox_Windows10_19_03_2018_14_00_24.png} \\end{center} \\caption{counterにmark_debugがない場合 \\label{fig:without_mark_debug}} \\end{figure}\n基本実験の準備 FPGAを使った実験をする前に，動作の様子を確認しながら実験できるように簡単なテンプレートモジュールを用意しておくことにします． ここで作るのは，図\\ref{fig:experiment_template}のように4bitの入力と4bitの出力ポートで構成されるモジュールです． ZYBOのDIPスイッチSW0〜SW3を4bitの入力に，LED LD0〜LD3を4bitの出力にマッピングすることにします．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.6\\textwidth]{chapter05_figures/experiment_template.png} \\end{center}\n\\caption{実験用の簡単なテンプレートモジュール \\label{fig:experiment_template}} \\end{figure}\n次のような内容のVHDLファイルを用意します．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee;\nuse ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top;\narchitecture RTL of top is\nsignal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0);\nbegin\nLD \u0026lt;= sw_d1;\nprocess(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nピン定義も用意しましょう．第3章で紹介したようにGUIで設定することもできますが，スクリプトファイルでピン定義を決めることもできます．実験に使用するZYBO Z7-20の全てのI/O定義は\\url{https://github.com/Digilent/digilent-xdc/blob/master/Zybo-Z7-Master.xdc}にまとまっています．URL先の情報に基づいて，使用するピンの定義をまとめると次のようになります．top.xdcなどと，拡張子を.xdcとしてファイルに保存します． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33 } [get_ports {CLK}]; create_clock -add -name clk_pin -period 8.00 -waveform {0 4} [get_ports {CLK}];\nset_property -dict {PACKAGE_PIN G15 IOSTANDARD LVCMOS33} [get_ports {SW[0]}]; set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS33} [get_ports {SW[1]}]; set_property -dict {PACKAGE_PIN W13 IOSTANDARD LVCMOS33} [get_ports {SW[2]}]; set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports {SW[3]}];\nset_property -dict {PACKAGE_PIN M14 IOSTANDARD LVCMOS33} [get_ports {LD[0]}]; set_property -dict {PACKAGE_PIN M15 IOSTANDARD LVCMOS33} [get_ports {LD[1]}]; set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {LD[2]}]; set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS33} [get_ports {LD[3]}]; \\end{Verbatim} \\end{quote} \\end{figure}\n作成したVHDLファイルと定義ファイルをプロジェクトに追加して合成し，できあがったbitファイルをZYBO Z7-20に書きこみましょう．DIPスイッチをオン・オフすることでLEDが点灯，消灯するはずです．\n基本演算の動作を確認してみよう 基本的な論理演算である，AND/OR/XORの動作を実機のILAを使って確認してみましょう．\nAND/OR/XOR/NOTの動作を確認するためのモジュールとして次のようなモジュールを用意します． 名前は\\verb|logic_test.vhd|として保存することにします． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee;\nuse ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity logic_test is port ( CLK : in std_logic; a, b : in std_logic; q_and : out std_logic; q_or : out std_logic; q_xor : out std_logic; q_not : out std_logic ); end entity logic_test;\narchitecture RTL of logic_test is\nattribute mark_debug : string;\nq_and_i : std_logic; q_or_i : std_logic; q_xor_i : std_logic\nattribute mark_debug of q_and_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of q_or_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of q_xor_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of q_not_i : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\nq_and \u0026lt;= q_and_i; q_or \u0026lt;= q_or_i; q_xor \u0026lt;= q_xor_i; q_not \u0026lt;= q_not_i;\nprocess(CLK) begin if rising_edge(CLK) then q_and_i \u0026lt;= a and b; q_or_i \u0026lt;= a or b; q_xor_i \u0026lt;= a and b; q_not_i \u0026lt;= xor a; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n先に用意したテンプレートに組み込んで，実機で動作を確認するために，\\verb|top.vhd|を次のように変更します．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee;\nuse ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top;\narchitecture RTL of top is\nsignal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0);\ncomponent logic_test port ( CLK : in std_logic; a, b : in std_logic; q_and : out std_logic; q_or : out std_logic; q_xor : out std_logic; q_not : out std_logic ); end component logic_test;\nbegin\n\u0026ndash; LD \u0026lt;= sw_d1;\nprocess(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process;\nU : logic_test port map( CLK =\u0026gt; CLK, a =\u0026gt; sw_d1(0), b =\u0026gt; sw_d1(1), q_and =\u0026gt; LD(0), q_or =\u0026gt; LD(1), q_xor =\u0026gt; LD(2), q_not =\u0026gt; LD(3) );\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nランダムな振る舞いを実現する擬似乱数の生成 ゲームなどで，ランダムな振る舞いをさせたいときに用いられるのが乱数です．本物の乱数を作るのは非常に難しいため，一般的には数式で導いた擬似乱数で代用します．ソフトウェアで乱数を作成する場合は，rand関数などを呼び出すことで乱数系列に従って生成された値を利用できます．\n乱数系列の作り方には，いろいろな方法があります．今回は，ビット操作の練習として，シフトとXOR演算のみで構成できるXORSHIFT法(参考文献1)に基づく乱数生成器を実装してみましょう．32ビットのXORSHIFT法による乱数生成をCで記述すると， \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] unsigned long xor() { static unsigned long y=2463534242; y ^= (y \u0026lt;\u0026lt; 13); y ^= (y \u0026gt;\u0026gt; 17); return (y ^= (y\u0026lt;\u0026lt;5)); } \\end{Verbatim} \\end{quote} \\end{figure} という関数になります． この関数と同等の操作をするハードウェア・モジュールを作成し，シミュレーションと実機で動作を確認してみましょう．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee;\nuse ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity xorshift is port ( CLK : in std_logic; Q : out std_logic_vector(31 downto 0) ); end entity xorshift;\narchitecture RTL of xorshift is\nattribute mark_debug : string;\n\u0026ndash; 2463534242 = 0x92d68ca2 signal y : std_logic_vector(63 downto 0) := X\u0026rdquo;0000000092d68ca2\u0026rdquo;; signal y0_d, y1_d : std_logic_vector(63 downto 0);\nattribute mark_debug of y : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of y0_d : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of y1_d : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\nQ \u0026lt;= y(31 downto 0);\nprocess(CLK) variable y0 : std_logic_vector(63 downto 0); variable y1 : std_logic_vector(63 downto 0); begin if rising_edge(CLK) then \u0026ndash; y ^= (y \u0026lt;\u0026lt; 13); y0 := y xor (y(63-13 downto 0) \u0026amp; \u0026ldquo;0000000000000\u0026rdquo;); \u0026ndash; y ^= (y \u0026gt;\u0026gt; 17); y1 := y0 xor (\u0026ldquo;00000000000000000\u0026rdquo; \u0026amp; y0(63 downto 17)); \u0026ndash; y ^= (y \u0026lt;\u0026lt; 5); y \u0026lt;= y1 xor (y1(63-5 downto 0) \u0026amp; \u0026ldquo;00000\u0026rdquo;);\n -- to debug y0_d \u0026lt;= y0; y1_d \u0026lt;= y1; end if;  end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee;\nuse ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top;\narchitecture RTL of top is\nsignal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0);\ncomponent xorshift port ( CLK : in std_logic; Q : out std_logic_vector(31 downto 0) ); end component xorshift;\nbegin\n\u0026ndash; LD \u0026lt;= sw_d1;\nprocess(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process;\nU : xorshift port map( CLK =\u0026gt; CLK, Q(3 downto 0) =\u0026gt; LD(3 downto 0), Q(31 downto 4) =\u0026gt; open );\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nビット加算器を作ってみよう ビット加算器，つまり足算の基本要素を作ってみましょう．ビット加算器では，足される数，足す数，および，繰り上がりの3bitの入力から，その桁の結果と繰り上がりの2bitを出力します．全加算器は半加算器2個とORで作ることができます． 以下のリストを参考に，加算器が正しく動作することをシミュレータおよびILAを使って実機で確認してください．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; 半加算器 library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity half_addr is port ( a : in std_logic; b : in std_logic; s : out std_logic; c : out std_logic ); end half_addr;\narchitecture RTL of half_addr is\nattribute mark_debug : string;\nsignal s_i : std_logic; signal c_i : std_logic;\nattribute mark_debug of s_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of c_i : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\ns \u0026lt;= s_i; c \u0026lt;= c_i;\nprocess(a, b) begin s_i \u0026lt;= a xor b; c_i \u0026lt;= a and b; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; 全加算器 library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity full_addr is Port ( a : in std_logic; b : in std_logic; ci : in std_logic; s : out std_logic; co : out std_logic ); end full_addr;\narchitecture RTL of full_addr is\nattribute mark_debug : string;\nsignal s_i : std_logic; signal co_i : std_logic;\nattribute mark_debug of s_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of co_i : signal is \u0026ldquo;true\u0026rdquo;;\ncomponent half_addr Port ( a : in std_logic; b : in std_logic; s : out std_logic; c : out std_logic ); end component half_addr;\nsignal s0 : std_logic; signal c0 : std_logic; signal c1 : std_logic;\nbegin\ns \u0026lt;= s_i; co \u0026lt;= co_i;\nU0: half_addr port map( a =\u0026gt; a, b =\u0026gt; b, s =\u0026gt; s0, c =\u0026gt; c0); U1: half_addr port map( a =\u0026gt; s0, b =\u0026gt; ci, s =\u0026gt; s_i, c =\u0026gt; c1); co_i \u0026lt;= c0 or c1;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nHDLの四則演算を試してみよう VHDLやVerilog HDLでは，加算器のレベルでハードウェアを設計する必要はなく，実際には定義されている算術演算を利用することができます．+/-/*の動作をシミュレータおよび実機で確認してみてください．\nたとえば，次のようなVHDLコードを書いて試すことができます． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity arith_test is port ( a : in std_logic_vector(1 downto 0); b : in std_logic_vector(1 downto 0); q_a_add_b : out std_logic_vector(2 downto 0); q_a_sub_b : out std_logic_vector(2 downto 0); q_a_mult_b : out std_logic_vector(3 downto 0) ); end arith_test;\narchitecture RTL of arith_test is\nattribute mark_debug : string;\nsignal q_a_add_b_i : unsigned(2 downto 0); signal q_a_sub_b_i : unsigned(2 downto 0); signal q_a_mult_b_i : unsigned(3 downto 0);\nattribute mark_debug of q_a_add_b_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of q_a_sub_b_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of q_a_mult_b_i : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\nq_a_add_b \u0026lt;= std_logic_vector(q_a_add_b_i); q_a_sub_b \u0026lt;= std_logic_vector(q_a_sub_b_i); q_a_mult_b \u0026lt;= std_logic_vector(q_a_mult_b_i);\nprocess(a, b) begin q_a_add_b_i \u0026lt;= unsigned(\u0026lsquo;0\u0026rsquo; \u0026amp; a) + unsigned(\u0026lsquo;0\u0026rsquo; \u0026amp; b); q_a_sub_b_i \u0026lt;= unsigned(\u0026lsquo;0\u0026rsquo; \u0026amp; a) - unsigned(\u0026lsquo;0\u0026rsquo; \u0026amp; b); q_a_mult_b_i \u0026lt;= unsigned(a) * unsigned(b); end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n合計値の計算 算術演算の応用問題として，与えられたデータ(たとえば32ビットのビット列)の中に，1がいくつあるかを数えて値を返すというモジュールを作成してみましょう．たとえば，0x00000001の場合はビット列の中に1は1個，0xAAAAAAAAの場合は16個という値を出力する，モジュールです．\nもちろん逐次的に，1クロックで1bitずつ\u0026rsquo;0\u0026rsquo;か\u0026rsquo;1\u0026rsquo;かを検査するという，ソフトウェア的な実装も考えられますが，ここでは，入力された値に対して即座に結果を返す組み合わせ回路として設計し，シミュレーションと実機で動作を確認してみてください．\nたとえば，次のようなVHDLコードを書いて試すことができます． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity bitcount is port ( a : in std_logic_vector(31 downto 0); q : out std_logic_vector(4 downto 0) ); end bitcount;\narchitecture RTL of bitcount is\nattribute mark_debug : string;\nsignal q_i : unsigned(4 downto 0); attribute mark_debug of q_i : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\nq \u0026lt;= std_logic_vector(q_i);\nprocess(a) variable sum : integer := 0; begin sum := 0; for i in 0 to a\u0026rsquo;length-1 loop if a(i) = \u0026lsquo;1\u0026rsquo; then sum := sum + 1; end if; end loop; q_i \u0026lt;= to_unsigned(sum, q_i\u0026rsquo;length); end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nPWM ある値を，1bitの信号の\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;の幅で表現するPWMという変調方式があります． ディジタルで簡単に信号の強度を変える方法としてもよく利用されます．\n次のVHDLコードは，PWMを実装してみた例です． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity pwm is port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end pwm;\narchitecture RTL of pwm is\nattribute mark_debug : string;\nsignal counter : unsigned(3 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;); signal q_i : std_logic := \u0026lsquo;0\u0026rsquo;;\nattribute mark_debug of q_i : signal is \u0026ldquo;true\u0026rdquo;; attribute mark_debug of counter : signal is \u0026ldquo;true\u0026rdquo;;\nbegin\nq \u0026lt;= q_i;\nprocess(clk) begin if rising_edge(clk) then counter \u0026lt;= counter + 1; if counter \u0026gt;= unsigned(a) and unsigned(a) \u0026lt; 15 then q_i \u0026lt;= d; else q_i \u0026lt;= not d; end if; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n次のようにスイッチをPWMの幅に，出力をLEDに割り当てて合成したときの動作を 実機で確認してみましょう． \\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top;\narchitecture RTL of top is signal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0); component pwm port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end component pwm; signal pwm_q : std_logic; begin\nprocess(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process;\nU: pwm port map( clk =\u0026gt; clk, a =\u0026gt; sw_d1, d =\u0026gt; \u0026lsquo;1\u0026rsquo;, q =\u0026gt; pwm_q ); LD(0) \u0026lt;= pwm_q; LD(1) \u0026lt;= pwm_q; LD(2) \u0026lt;= pwm_q; LD(3) \u0026lt;= pwm_q; end RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nステートマシンの作り方と利用方法 基本実験の最後に，ハードウェア・プログラミングで逐次的に処理するために必要不可欠な概念であるステート・マシンと，その実装方法を学びましょう．ハードウェアでは処理を並列に実行できますが，世の中には順番にしか実行できない物事もたくさんあります．たとえば，そうめんを茹でるとき，鍋の水がまだ湯になる前に並行してそうめんを鍋に入れても，とても食べられるものはできあがりません．何事でも順序を守ることが大事なときもありますよね．\n料理は逐次的な処理 何かを実行し，その次に何かを実行し，その次に\u0026hellip;，という決まった手順に従った処理の実装は，ソフトウェアによく見られます．たとえば，そうめんをゆでるときには，\n 鍋に水を入れる 鍋を火にかける 沸騰するまで待つ そうめんを入れる 1分くらい待つ 十分やわらかいか確認する やわらかくなったら取り出して，できあがり  という手順が必要となります．ソフトウェアであれば，このような手順をそのままプログラミング言語で記述して実装できます．しかし，ハードウェア・プログラミングでは逐次的な処理をそのまま記述できません．逐次的に処理を進めることそのものを自分で記述する必要があります．これを簡単に扱う道具がステート・マシン(状態遷移機械)です．\nステート・マシンとは 図\\ref{fig:statemachine_example}は，そうめんをゆでる手順をステート・マシン的に表現した例です．楕円は「状態」を矢印は「状態遷移」を示しています．矢印に条件が書かれている場合は，その条件が満たされたときだけ状態が遷移する，ということを意味します．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.6\\textwidth]{chapter05_figures/statemachine_example.png} \\end{center}\n\\caption{そうめんを茹でる流れをステートマシン的に表現してみた例．\\label{fig:statemachine_example}} \\end{figure}\nステート・マシンとは，処理を「状態」と「状態遷移」で抽象化した概念です．列挙された状態を定義された状態遷移に従って順々にたどっていくことで所望の処理が実現できます．各状態での処理を定義することで，逐次的な処理をステート・マシンを使って記述できます．\nハードウェア・プログラミングと相性の良いステート・マシン ステート・マシンをハードウェア・プログラミングで実装するのは意外と簡単です．そうめんを茹でる手順をハードウェア記述言語の一つであるVHDLで記述した擬似コードを示します． 各状態を\\verb|std_logic_vector|型の変数stateで管理しています．stateの値が各状態に対応しています．変数stateをクロックごとに参照し，その時点で実行すべき処理を判断します．各状態では，次の状態に遷移するための条件判断と，遷移のための状態変数の更新を行います．\n\\begin{figure}[H] \\begin{quote}\n\\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; そうめんをゆでるステートマシンの擬似コード architecture RTL of somen\nsignal state : std_logic_vector(2 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;);\nprocess(clk) begin if rising_edge(clk) then case conv_integer(state) \u0026ndash; 変数「state」によって状態の場合分けをする when 0 =\u0026gt; 鍋に水をいれる state \u0026lt;= conv_std_logic_vector(1, 3); when 1 =\u0026gt; 鍋を火をかける state \u0026lt;= conv_std_logic_vector(2, 3); when 2 =\u0026gt; if 水が湧いたか？ = true then state \u0026lt;= conv_std_logic_vector(3, 3); end if; when 3 =\u0026gt; そうめんをいれる state \u0026lt;= conv_std_logic_vector(4, 3); when 4 =\u0026gt; if 時間 = 1分 then state \u0026lt;= conv_std_logic_vector(5, 3); end if; when 5 =\u0026gt; if やわらかさが十分か？ = true then state \u0026lt;= conv_std_logic_vector(6, 3); end if; when 6 =\u0026gt; \u0026ndash; おしまい when others =\u0026gt; \u0026ndash; 「上記以外のその他」に相当．これで，全条件を列挙できた． null; end case; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\nところで，リスト1のコードには，0，1，2，\u0026hellip;という状態を識別するための番号が振られています．これらの値に意味はなく，単にほかと区別するために便宜的に付けられたマジック・ナンバです．マジック・ナンバはコードの可読性を下げ，後の変更を加えづらくします．ソフトウェアでもマジック・ナンバは忌み嫌われるように，ハードウェア・プログラミングでもできれば避けたいものです．\nVHDLでは自分で型を定義することで，Verilogではdefineやlocalparamを使って値に名前を付けることで，ソース・コードからマジック・ナンバを取り除くことができます．VHDLで状態を表す型を定義して，マジック・ナンバをなくした例が次の通りです．\n\\begin{figure}[H] \\begin{quote}\n\\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.8] \u0026ndash; そうめんをゆでるステートマシンの擬似コード\n\u0026ndash; 状態変数のための型を定義しマジックナンバをなくしたバージョン architecture RTL of somen\n\u0026ndash; 状態を表わす型を定義する．これは，enumのような列挙型に相当． type StateType is (WATER, FIRE, HOT_WATER, PUT_SOMEN, WAIT_A_MIN, BOIL, FIN) signal state : StateType := WATER;\nprocess(clk) begin if rising_edge(clk) then case conv_integer(state) when WATER =\u0026gt; 鍋に水をいれる state \u0026lt;= FIRE; when FIRE =\u0026gt; 鍋を火をかける state \u0026lt;= HOT_WATER; when HOT_WATER =\u0026gt; if \u0026ldquo;水が湧いたか？ = true\u0026rdquo; then state \u0026lt;= PUT_SOMEN; end if; when PUT_SOMEN =\u0026gt; そうめんをいれる state \u0026lt;= WAIT_A_MIN; when WAIT_A_MIN =\u0026gt; if 時間 = 1分 then state \u0026lt;= BOIL end if; when BOIL =\u0026gt; if やわらかさが十分か？ = true then state \u0026lt;= conv_std_logic_vector(6, 3); end if; when FIN =\u0026gt; \u0026ndash; おしまい when others =\u0026gt; null; end case; end if; end process;\nend RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n次のリストを参考に，ステートマシンを利用したハードウェアを設計し，動作をシミュレーションとILAで確認してみてください．\n\\begin{figure}[H] \\begin{quote} \\begin{Verbatim}[frame=single, numbers=left, baselinestretch=0.6] library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;\nentity stmt_test is port ( clk : in std_logic; a,b : in std_logic; led : out std_logic_vector(2 downto 0) ); end stmt_test;\narchitecture RTL of stmt_test is attribute mark_debug : string;\nsignal led_i : std_logic_vector(2 downto 0) := (others =\u0026gt; \u0026lsquo;0\u0026rsquo;); attribute mark_debug of led_i : signal is \u0026ldquo;true\u0026rdquo;;\ntype StateType is (BLACK, RED, GREEN, BLUE); signal state : StateType := BLACK;\nsignal a_d, b_d : std_logic := \u0026lsquo;0\u0026rsquo;; signal a_rising, b_rising : std_logic := \u0026lsquo;0\u0026rsquo;;\nbegin\nled \u0026lt;= led_i; a_rising \u0026lt;= \u0026lsquo;1\u0026rsquo; when a_d = \u0026lsquo;0\u0026rsquo; and a = \u0026lsquo;1\u0026rsquo; else \u0026lsquo;0\u0026rsquo;; b_rising \u0026lt;= \u0026lsquo;1\u0026rsquo; when b_d = \u0026lsquo;0\u0026rsquo; and b = \u0026lsquo;1\u0026rsquo; else \u0026lsquo;0\u0026rsquo;;\nprocess(clk) begin if rising_edge(clk) then a_d \u0026lt;= a; b_d \u0026lt;= b;\n case state is when BLACK =\u0026gt; led_i \u0026lt;= \u0026quot;000\u0026quot;; if a_rising = '1' then state \u0026lt;= RED; elsif b_rising = '1' then state \u0026lt;= BLUE; end if; when RED =\u0026gt; led_i \u0026lt;= \u0026quot;001\u0026quot;; if a_rising = '1' then state \u0026lt;= GREEN; elsif b_rising = '1' then state \u0026lt;= BLACK; end if; when GREEN =\u0026gt; led_i \u0026lt;= \u0026quot;010\u0026quot;; if a_rising = '1' then state \u0026lt;= BLUE; elsif b_rising = '1' then state \u0026lt;= RED; end if; when BLUE =\u0026gt; led_i \u0026lt;= \u0026quot;100\u0026quot;; if a_rising = '1' then state \u0026lt;= BLACK; elsif b_rising = '1' then state \u0026lt;= GREEN; end if; when others =\u0026gt; led_i \u0026lt;= \u0026quot;000\u0026quot;; state \u0026lt;= BLACK; end case; end if;  end process; end RTL; \\end{Verbatim} \\end{quote} \\end{figure}\n参考文献  George Marsaglia, \u0026ldquo;Xorshift RNGs\u0026rdquo;, The Florida State University, \\url{http://www.jstatsoft.org/v08/i14}  "});index.add({'id':5,'href':'/learning_fpga/docs/book01/experiments/','title':"実験",'content':" HDLのいろいろな記述方法を使って，少し複雑なモジュールの設計に取り組んでみましょう．\nはじめに これまでに学んできた内容を利用して，少し応用的な実験に取り組んでみましょう．\nストップウォッチを作ってみよう ここでは，\n アクションボタンを押すとミリ秒毎のカウントアップを開始する カウント中に，アクションボタンを押すとカウントを一時停止する 一時停止中に，アクションボタンを押すとカウントを再開する リセットボタンを押すとカウントを0にクリアする  という機能をもったストップウォッチを作ってみましょう．\n残念ながら，ZYBO Z7-20には，7セグメントLEDのような数字を表示する分かりやすい表示器はありませんので，4つのLEDと2つの3色LEDを使って数を表現するとよいでしょう．\n次のリストはストップウォッチを実装するためのトップモジュールの例です．3色LEDの明るさを適当に調節するために，PWMモジュールを使って出力を変調しています．PWMモジュールによって，たとえば\\verb|\u0026lsquo;1\u0026rsquo;|を出力する場合でも，適当なタイミングで\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;がまぜられることで明るさを抑えることができます．\nlibrary ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity stopwatch_z7_20 is port ( CLK : in std_logic; led6_r : out std_logic; led6_g : out std_logic; led6_b : out std_logic; led5_r : out std_logic; led5_g : out std_logic; led5_b : out std_logic; LD : out std_logic_vector(3 downto 0); btn : in std_logic_vector(1 downto 0) ); end entity stopwatch_z7_20; architecture RTL of stopwatch_z7_20 is attribute ASYNC_REG : string; attribute mark_debug : string; component stopwatch generic ( FREQ_MHz : integer := 125 ); port ( clk : in std_logic; reset : in std_logic; action : in std_logic; msec_out : out std_logic_vector(9 downto 0); sec_out : out std_logic_vector(5 downto 0); min_out : out std_logic_vector(5 downto 0); hour_out : out std_logic_vector(4 downto 0) ); end component stopwatch; component pwm port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end component pwm; signal btn_d0 : std_logic_vector(1 downto 0); signal btn_d1 : std_logic_vector(1 downto 0); attribute ASYNC_REG of btn_d0, btn_d1 : signal is \u0026quot;TRUE\u0026quot;; signal msec_out : std_logic_vector(9 downto 0); signal sec_out : std_logic_vector(5 downto 0); signal min_out : std_logic_vector(5 downto 0); signal hour_out : std_logic_vector(4 downto 0); attribute mark_debug of msec_out : signal is \u0026quot;true\u0026quot;; attribute mark_debug of sec_out : signal is \u0026quot;true\u0026quot;; attribute mark_debug of min_out : signal is \u0026quot;true\u0026quot;; attribute mark_debug of hour_out : signal is \u0026quot;true\u0026quot;; begin process(CLK) begin if rising_edge(CLK) then btn_d0 \u0026lt;= btn; btn_d1 \u0026lt;= btn_d0; end if; end process; U: stopwatch generic map( FREQ_MHz =\u0026gt; 125 ) port map( clk =\u0026gt; CLK, reset =\u0026gt; btn_d1(0), action =\u0026gt; btn_d1(1), msec_out =\u0026gt; msec_out, sec_out =\u0026gt; sec_out, min_out =\u0026gt; min_out, hour_out =\u0026gt; hour_out ); LD \u0026lt;= sec_out(3 downto 0); PWM0 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(0), q =\u0026gt; led5_r); PWM1 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(1), q =\u0026gt; led5_g); PWM2 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(2), q =\u0026gt; led5_b); PWM3 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(3), q =\u0026gt; led6_r); PWM4 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(4), q =\u0026gt; led6_g); PWM5 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026quot;1100\u0026quot;, d =\u0026gt; msec_out(5), q =\u0026gt; led6_b); end RTL;  stopwatchモジュールを実装して，完成させてみましょう．\nシリアル通信に挑戦してみよう 最近のパソコンの外部機器のI/OのほとんどはUSBです．ノート・パソコンは勿論，省スペースのデスクトップ・パソコンにさえ，RS-232-Cのシリアル通信のポートが搭載されなくなってきました．それでも，送信と受信の2本で通信可能なRS-232-Cは，パソコンとFPGAの間やFPGAとFPGAの間でデータを手軽にやりとりする手段として基本的かつ必要不可欠な存在です．\nシリアル・ポートのないノート・パソコンでも，市販のUSB-シリアル変換ケーブルやBluetooth-シリアル変換モジュールを使って簡単に接続できます．\nシリアル通信のしくみ シリアル通信では，受信と送信で独立したポートを持ちます．機器を直結する場合には，お互いの送受信ポートをクロスして結線します(図\\ref{fig:serial_comm})．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.6\\textwidth]{chapter06_figures/serial_comm.eps} \\end{center}\n\\caption{シリアル通信の結線\\label{fig:serial_comm}} \\end{figure}\nRS-232-Cでは，図\\ref{fig:serial_comm_format}のように，8ビットのデータにスタート・ビット（\u0026rsquo;0\u0026rsquo;）とストップ・ビット（\u0026rsquo;1\u0026rsquo;）を付加してデータを通信します．接続した機器同士であらかじめ決めた速度(たとえば19200bpsなど)で信号を送受信することで，共通したクロックを持つことなくデータの送受信ができます．\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.6\\textwidth]{chapter06_figures/serial_comm_format.eps} \\end{center}\n\\caption{シリアル通信の信号の伝送方式\\label{fig:serial_comm_format}} \\end{figure}\n送信モジュール 決められた速度で信号をパタパタと変化させるだけです．ただし，一般に，シリアル通信の速度は回路の動作クロックに対して，とても遅いので，データを送信している途中に送るべき信号を更新してしまわないようにブロックする仕組みが必要です．VHDLによる実装例を示します．\nlibrary ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity uart_tx is -- 定数宣言 generic ( sys_clk : integer := 14000000; --クロック周波数 rate : integer := 9600 --転送レート,単位はbps(ビット毎秒) ); -- 入出力ポート宣言 port ( clk : in std_logic; -- クロック reset : in std_logic; -- リセット wr : in std_logic; -- 送信要求 din : in std_logic_vector(7 downto 0); --送信データ dout : out std_logic; --シリアル出力 ready : out std_logic --送信要求を受け付けられるか ); end uart_tx; architecture rtl of uart_tx is -- クロック分周モジュールの呼び出しの準備 component clk_div is port (clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic); end component; -- 内部変数定義 signal in_din : std_logic_vector(7 downto 0); -- 送信データ一時保存用レジスタ signal buf : std_logic_vector(7 downto 0); -- 一時的にしようするバッファ signal load : std_logic := '0'; -- 送信データを読み込んだかどうか signal cbit : unsigned(2 downto 0) := (others =\u0026gt; '0'); -- 送信するビット番号 signal run : std_logic := '0'; -- 送信状態にあるかどうか signal tx_en : std_logic; -- 送信用クロック signal tx_en_d : std_logic := '0'; -- 送信用クロックの立ち上がり検出用 signal tx_div : std_logic_vector(15 downto 0); -- クロック分周の倍率 signal status : unsigned(1 downto 0); -- 状態遷移用レジスタ begin -- クロック分周モジュールの呼び出し -- clk_divの入出力ポートにこのモジュールの内部変数を接続 tx_div \u0026lt;= std_logic_vector(to_unsigned((sys_clk / rate) - 1, 16)); U0 : clk_div port map (clk=\u0026gt;clk, rst=\u0026gt;reset, div=\u0026gt;tx_div, clk_out=\u0026gt;tx_en); -- readyへの代入, 常時値を更新している ready \u0026lt;= '1' when (wr = '0' and run = '0' and load = '0') else '0'; process(clk) --変化を監視する信号を記述する, この場合クロック begin if rising_edge(clk) then --クロックの立ち上がり時の動作 if reset = '1' then --リセット時の動作, 初期値の設定 load \u0026lt;= '0'; else if(wr = '1' and run = '0') then --送信要求があり，かつ送信中でない場合 load \u0026lt;= '1'; --データを取り込んだフラグを立てる in_din \u0026lt;= din; --一時保存用レジスタに値を格納 end if; if(load = '1' and run = '1') then --送信中で，かつデータを取り込んだ --ことを示すフラグが立っている場合 load \u0026lt;= '0'; --データを取り込んだフラグを下げる end if; end if; end if; end process; process(clk) --変化を監視する信号(クロック) begin if rising_edge(clk) then if reset = '1' then --リセット時の動作, 初期値の設定 dout \u0026lt;= '1'; cbit \u0026lt;= (others =\u0026gt; '0'); status \u0026lt;= (others =\u0026gt; '0'); run \u0026lt;= '0'; tx_en_d \u0026lt;= '0'; else tx_en_d \u0026lt;= tx_en; if tx_en = '1' and tx_en_d = '0' then -- tx_enの立ち上がりで動作 case to_integer(status) is --statusの値に応じて動作が異なる when 0 =\u0026gt; --初期状態 cbit \u0026lt;= (others =\u0026gt; '0'); --カウンタをクリア if load = '1' then -- データを取り込んでいる場合 dout \u0026lt;= '0'; -- スタートビット0を出力 status \u0026lt;= status + 1; -- 次の状態へ buf \u0026lt;= in_din; -- 送信データを一時バッファに退避 run \u0026lt;= '1'; -- 送信中の状態へ遷移 else --なにもしない状態へ遷移 dout \u0026lt;= '1'; run \u0026lt;= '0'; --送信要求受付可能状態へ end if; when 1 =\u0026gt; --データをLSBから順番に送信 cbit \u0026lt;= cbit + 1; -- カウンタをインクリメント dout \u0026lt;= buf(to_integer(cbit)); --一時バッファのcbit目を取出して出力 if(to_integer(cbit) = 7) then -- データの8ビット目を送信したら, -- ストップビットを送る状態へ遷移 status \u0026lt;= status + 1; end if; when 2 =\u0026gt; -- ストップビットを送信 dout \u0026lt;= '1'; --ストップビット1 status \u0026lt;= (others =\u0026gt; '0'); --初期状態へ when others =\u0026gt; --その他の状態の場合 status \u0026lt;= (others =\u0026gt; '0'); -- 初期状態へ遷移 end case; end if; end if; end if; end process; end rtl;  内部で利用しているclk_divの実装は次の通りです．\nlibrary ieee; use ieee.std_logic_1164.ALL; use ieee.numeric_std.all; entity clk_div is port( clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic ); end clk_div; architecture RTL of clk_div is signal counter : unsigned(15 downto 0) := (others =\u0026gt; '0'); begin process(clk) begin if(clk'event and clk = '1') then if(rst = '1') then counter \u0026lt;= (others =\u0026gt; '0'); elsif (counter = unsigned(div)) then counter \u0026lt;= (others =\u0026gt; '0'); clk_out \u0026lt;= '1'; else counter \u0026lt;= counter + 1; clk_out \u0026lt;= '0'; end if; end if; end process; end RTL;  clk_divモジュールで生成した，シリアル送信用の信号にあわせて，送信すべきデータを1bitずつ出力します． また，出力中はready信号を'0'にすることで，送信モジュールが動作中であることを上位のモジュールに伝えられるようになっています．\nこのモジュールの動作をシミュレーションで確認してみましょう．\n受信モジュール 受信モジュールは送信モジュールに比べて少し複雑になります．送信側は自分のタイミングで信号を送ればいいのに対し，受信側ではスタート・ビットを頼りにデータの開始を検出し，以降の信号を正しい間隔でビットに分割しなければならないからです．また，データにはノイズが乗っている可能性もあるので，データを正しく取得する仕組みも必要です． VHDLとVerilog HDLによる実装の例が次のリストです．この例では，通信速度の16倍のクロックでデータをサンプリング（一定間隔で読み込む）することで，データを受信しています．\nlibrary ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity uart_rx is -- 定数宣言 generic( sys_clk : integer := 14000000; --クロック周波数 rate : integer := 9600 --転送レート,単位はbps(ビット毎秒) ); -- 入出力ポート宣言 port( clk : in std_logic; -- クロック reset : in std_logic; -- リセット din : in std_logic; -- シリアル入力 rd : out std_logic; -- 受信完了を示す dout : out std_logic_vector(7 downto 0) -- 受信データ ); end uart_rx; architecture rtl of uart_rx is --クロック分周モジュールのインスタンス生成の準備 component clk_div is port( clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic ); end component; --内部変数宣言 signal buf : std_logic_vector(7 downto 0); --受信データ系列の一時保存用 signal receiving : std_logic; --受信しているかどうか signal cbit : integer range 0 to 150; -- データの取り込みタイミング用カウンタ signal rx_en : std_logic; --受信用クロック signal rx_en_d : std_logic := '0'; --受信用クロック立ち上がり判定用レジスタ signal rx_div : std_logic_vector(15 downto 0); --クロック分周の倍率 begin --クロック分周モジュールのインスタンス生成 --受信側は送信側の16倍の速度で値を取り込み処理を行う rx_div \u0026lt;= std_logic_vector(to_unsigned(((sys_clk / rate) / 16) - 1, 16)); U0 : clk_div port map (clk=\u0026gt;clk, rst=\u0026gt;reset, div=\u0026gt;rx_div, clk_out=\u0026gt;rx_en); process(clk) --変化を監視する信号を記述,この場合クロック begin if rising_edge(clk) then if reset = '1' then --リセット時の動作, 初期値の設定 receiving \u0026lt;= '0'; cbit \u0026lt;= 0; buf \u0026lt;= (others =\u0026gt; '0'); dout \u0026lt;= (others =\u0026gt; '0'); rd \u0026lt;= '0'; rx_en_d \u0026lt;= '0'; else rx_en_d \u0026lt;= rx_en; if rx_en = '1' and rx_en_d = '0' then --受信用クロック立ち上がり時の動作 if receiving = '0' then --受信中でない場合 if din = '0' then --スタートビット0を受信したら rd \u0026lt;= '0'; --受信完了のフラグをさげる receiving \u0026lt;= '1'; end if; else --受信中の場合 case cbit is --カウンタに合わせてデータをラッチ when 6 =\u0026gt; -- スタートビットのチェック if din = '1' then -- スタートビットが中途半端．入力をキャンセル receiving \u0026lt;= '0'; cbit \u0026lt;= 0; else cbit \u0026lt;= cbit + 1; end if; when 22 | 38 | 54 | 70 | 86 | 102 | 118 | 134 =\u0026gt; --data cbit \u0026lt;= cbit + 1; buf \u0026lt;= din \u0026amp; buf(7 downto 1); -- 新しい入力と受信済みデータを連結 when 150 =\u0026gt; --stop rd \u0026lt;= '1'; dout \u0026lt;= buf; receiving \u0026lt;= '0'; -- 受信完了 cbit \u0026lt;= 0; when others =\u0026gt; cbit \u0026lt;= cbit + 1; end case; end if; end if; end if; end if; end process; end RTL;  通信速度の16倍でデータをサンプリングしているので，スタート・ビットは16サイクル分が取得できるはずです．スタートビットのはじまりと思われる\u0026rsquo;0\u0026rsquo;というデータを確認してから6サイクル目のデータをもう一度取得し，そのデータがやっぱり\u0026rsquo;0\u0026rsquo;であれば，データ送信が開始されたと解釈します（ソース・コード中の状態1）．データが送信されていることを確認した後は，16サイクル毎にデータを取得します（ソース・コード中の状態2）．8bit分データを取得したら完了です．\n送信モジュールと同じように，テストベンチを書いてシミュレーションで動作を確認してみましょう．\n実機で動作確認 シリアル通信を実機で動作確認してみましょう．入出力にPMODコネクタJEの1ピンと7ピンを割当て，物理的に両者をジャンパピンで接続すれば，通信ができるはずです．動作をILAを使って確認してみましょう．{\\bf 注意: PMODコネクタの6ピンと12ピンは3.3V，5ピンと11ピンはGNDです．間違って6ピンと5ピンなどのように3.3VとGNDを直結しないようにしましょう．}\n\\begin{figure}[H] \\begin{center} \\includegraphics[width=.6\\textwidth]{chapter06_figures/IMG_0007.JPG} \\end{center} \\label{fig:serial_comm_test} \\caption{PMODコネクタのJEの1ピンと7ピンをジャンパケーブルで接続した様子} \\end{figure}\n音声信号を観測してみよう ZYBO Z7-20には音声入出力用のジャックが備わっています．これを利用すると外部からの音声信号を取り込みFPGAで処理することができます．信号は，SSM2603というICでA/D変換されます．SSM2603とFPGAはI2Sで音声データをやりとりすることができます．\nSSM2603とやりとりするI2S信号は図\\ref{fig:ssm2603_protocol}の通りです． \\begin{figure}[H] \\begin{center} \\includegraphics[width=.8\\textwidth]{chapter06_figures/zybo-z7-audio.png} \\end{center} \\label{fig:ssm2603_protocol} \\caption{SSM2603との通信インターフェース} \\end{figure} これを送受信するモジュールを実装して音声信号の入出力をやってみましょう． でてくる信号が少し増えて複雑にみえるかもしれませんが，方針はRS-232-Cの送受信と同じです．\nI2Sの送信 次のリストは，I2Sの送信モジュールの実装例です．シミュレーションによって，信号が図\\ref{fig:ssm2603_protocol}に示したように出力されることを確認してみましょう．\nlibrary ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity i2s_encoder is generic ( WIDTH : integer := 24 ); port ( CLK : in std_logic; -- BCLK 4x BCLK : in std_logic; LRC : in std_logic; DAT : out std_logic; LIN : in std_logic_vector(WIDTH-1 downto 0); RIN : in std_logic_vector(WIDTH-1 downto 0) ); end entity i2s_encoder; architecture RTL of i2s_encoder is attribute mark_debug : string; signal left_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; '0'); signal left_cnt : unsigned(7 downto 0) := (others =\u0026gt; '0'); signal right_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; '0'); signal right_cnt : unsigned(7 downto 0) := (others =\u0026gt; '0'); signal lrc_d : std_logic := '0'; signal bclk_d : std_logic := '0'; attribute mark_debug of left_data : signal is \u0026quot;true\u0026quot;; attribute mark_debug of left_cnt : signal is \u0026quot;true\u0026quot;; attribute mark_debug of right_data : signal is \u0026quot;true\u0026quot;; attribute mark_debug of right_cnt : signal is \u0026quot;true\u0026quot;; begin process(CLK) begin if rising_edge(CLK) then lrc_d \u0026lt;= LRC; bclk_d \u0026lt;= BCLK; if lrc_d = '1' and LRC = '0' then left_cnt \u0026lt;= (others =\u0026gt; '0'); left_data \u0026lt;= LIN; else if left_cnt \u0026lt;= 4*WIDTH-1 then left_cnt \u0026lt;= left_cnt + 1; if 3 \u0026lt;= left_cnt then DAT \u0026lt;= left_data(WIDTH-1); if left_cnt(1 downto 0) = \u0026quot;10\u0026quot; then left_data \u0026lt;= left_data(WIDTH-2 downto 0) \u0026amp; '0'; end if; end if; end if; end if; if lrc_d = '0' and LRC = '1' then right_cnt \u0026lt;= (others =\u0026gt; '0'); right_data \u0026lt;= RIN; else if right_cnt \u0026lt;= 4*WIDTH-1 then right_cnt \u0026lt;= right_cnt + 1; if 3 \u0026lt;= right_cnt then DAT \u0026lt;= right_data(WIDTH-1); if right_cnt(1 downto 0) = \u0026quot;10\u0026quot; then right_data \u0026lt;= right_data(WIDTH-2 downto 0) \u0026amp; '0'; end if; end if; end if; end if; end if; end process; end RTL;  I2Sの受信 次は受信モジュールです．送信モジュールと組み合わせてシミュレーションすることで，入力した音声信号をI2Sフォーマットに変換し，それが復号される様を観測することができます．\nlibrary ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity i2s_decoder is generic ( WIDTH : integer := 24 ); port ( CLK : in std_logic; BCLK : in std_logic; LRC : in std_logic; DAT : in std_logic; LOUT : out std_logic_vector(WIDTH-1 downto 0); ROUT : out std_logic_vector(WIDTH-1 downto 0); LOUT_VALID : out std_logic; ROUT_VALID : out std_logic ); end entity i2s_decoder; architecture RTL of i2s_decoder is attribute mark_debug : string; signal left_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; '0'); signal left_cnt : unsigned(5 downto 0) := (others =\u0026gt; '0'); signal left_valid : std_logic := '0'; signal right_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; '0'); signal right_cnt : unsigned(5 downto 0) := (others =\u0026gt; '0'); signal right_valid : std_logic := '0'; signal lrc_d : std_logic := '0'; attribute mark_debug of left_data : signal is \u0026quot;true\u0026quot;; attribute mark_debug of left_valid : signal is \u0026quot;true\u0026quot;; attribute mark_debug of left_cnt : signal is \u0026quot;true\u0026quot;; attribute mark_debug of right_data : signal is \u0026quot;true\u0026quot;; attribute mark_debug of right_valid : signal is \u0026quot;true\u0026quot;; attribute mark_debug of right_cnt : signal is \u0026quot;true\u0026quot;; signal bclk_d : std_logic := '0'; begin LOUT_VALID \u0026lt;= left_valid; ROUT_VALID \u0026lt;= right_valid; LOUT \u0026lt;= left_data; ROUT \u0026lt;= right_data; process(CLK) begin if rising_edge(CLK) then bclk_d \u0026lt;= BCLK; if bclk_d = '0' and BCLK = '1' then left_data \u0026lt;= left_data(WIDTH-2 downto 0) \u0026amp; DAT; right_data \u0026lt;= right_data(WIDTH-2 downto 0) \u0026amp; DAT; lrc_d \u0026lt;= LRC; if lrc_d = '1' and LRC = '0' then left_cnt \u0026lt;= (others =\u0026gt; '0'); else if left_cnt = WIDTH-1 then left_valid \u0026lt;= '1'; else left_valid \u0026lt;= '0'; end if; if left_cnt \u0026lt;= WIDTH-1 then left_cnt \u0026lt;= left_cnt + 1; end if; end if; if lrc_d = '0' and LRC = '1' then right_cnt \u0026lt;= (others =\u0026gt; '0'); else if right_cnt = WIDTH-1 then right_valid \u0026lt;= '1'; else right_valid \u0026lt;= '0'; end if; if right_cnt \u0026lt;= WIDTH-1 then right_cnt \u0026lt;= right_cnt + 1; end if; end if; end if; end if; end process; end RTL;  発展 紹介したアプリケーション実験を応用して，次のような課題に挑戦してみましょう．\n ストップウォッチモジュールを改造して，カウントダウンできるようにしてみましょう． いろいろな通信速度でRS-232-C通信を試してみましょう． 音声入出力ができるようになったので，たとえば，規定値より大きな値がきたときだけ音声を出力する，平滑化フィルタで音を滑らかにする，などが簡単には考えられるでしょう．  "});index.add({'id':6,'href':'/learning_fpga/docs/book01/ipi/','title':"IP Integrator入門",'content':"Vivado IP Integratorを使った，IPベースの設計手法を身につけてみましょう．大規模かつ複雑なデザインも小さな部品を組み合わせるボトムアップ設計で開発効率の向上が図れます．\n"});index.add({'id':7,'href':'/learning_fpga/docs/example/','title':"Example Site",'content':" Introduction Ferre hinnitibus erat accipitrem dixi Troiae tollens Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\n Pedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret  Est simul fameque tauri qua ad Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo;  Trepident sitimque Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"});index.add({'id':8,'href':'/learning_fpga/docs/example/table-of-contents/with-toc/','title':"With ToC",'content':" Caput vino delphine in tamen vias Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  Natus quaerere Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\n Phrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\n Limitibus misere sit Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"});index.add({'id':9,'href':'/learning_fpga/docs/example/table-of-contents/without-toc/','title':"Without ToC",'content':" At me ipso nepotibus nunc celebratior genus Tanto oblite Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.\nQuam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque. Exul Laurenti orantem modo, per densum missisque labor manibus non colla unum, obiectat. Tu pervia collo, fessus quae Cretenque Myconon crate! Tegumenque quae invisi sudore per vocari quaque plus ventis fluidos. Nodo perque, fugisse pectora sorores.\nSumme promissa supple vadit lenius Quibus largis latebris aethera versato est, ait sentiat faciemque. Aequata alis nec Caeneus exululat inclite corpus est, ire tibi ostendens et tibi. Rigent et vires dique possent lumina; eadem dixit poma funeribus paret et felix reddebant ventis utile lignum.\n Remansit notam Stygia feroxque Et dabit materna Vipereas Phrygiaeque umbram sollicito cruore conlucere suus Quarum Elis corniger Nec ieiunia dixit  Vertitur mos ortu ramosam contudit dumque; placabat ac lumen. Coniunx Amoris spatium poenamque cavernis Thebae Pleiadasque ponunt, rapiare cum quae parum nimium rima.\nQuidem resupinus inducto solebat una facinus quae Credulitas iniqua praepetibus paruit prospexit, voce poena, sub rupit sinuatur, quin suum ventorumque arcadiae priori. Soporiferam erat formamque, fecit, invergens, nymphae mutat fessas ait finge.\n Baculum mandataque ne addere capiti violentior Altera duas quam hoc ille tenues inquit Sicula sidereus latrantis domoque ratae polluit comites Possit oro clausura namque se nunc iuvenisque Faciem posuit Quodque cum ponunt novercae nata vestrae aratra  Ite extrema Phrygiis, patre dentibus, tonso perculit, enim blanda, manibus fide quos caput armis, posse! Nocendo fas Alcyonae lacertis structa ferarum manus fulmen dubius, saxa caelum effuge extremis fixum tumor adfecit bella, potentes? Dum nec insidiosa tempora tegit spirarunt. Per lupi pars foliis, porreximus humum negant sunt subposuere Sidone steterant auro. Memoraverit sine: ferrum idem Orion caelum heres gerebat fixis?\n"});index.add({'id':10,'href':'/learning_fpga/posts/creating-a-new-theme/','title':"Creating a New Theme",'content':" Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026quot;2014-09-28\u0026quot; title = \u0026quot;creating a new theme\u0026quot; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026quot;2014-09-28\u0026quot; title = \u0026quot;creating a new theme\u0026quot; +++ bah and humbug $  Some Definitions There are a few concepts that you need to understand before creating a theme.\nSkins Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta $ cd ~/Sites/zafta $ ls -l total 8 drwxr-xr-x 7 quoha staff 238 Sep 29 16:49 . drwxr-xr-x 3 quoha staff 102 Sep 29 16:49 .. drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $  Take a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose INFO: 2014/09/29 Using config file: config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $  The \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $  See that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public total 16 -rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml -rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml $  Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop  Connect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml sitemap.xml  That\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html]  That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes $ find themes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html -rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml $  The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml author = \u0026quot;michael d henderson\u0026quot; description = \u0026quot;a minimal working template\u0026quot; license = \u0026quot;MIT\u0026quot; name = \u0026quot;zafta\u0026quot; source_repo = \u0026quot;\u0026quot; tags = [\u0026quot;tags\u0026quot;, \u0026quot;categories\u0026quot;] :wq ## also edit themes/zafta/LICENSE.md and change ## the bit that says \u0026quot;YOUR_NAME_HERE\u0026quot;  Note that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html $  Update the Configuration File to Use the Theme Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml theme = \u0026quot;zafta\u0026quot; baseurl = \u0026quot;\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;zafta - totally refreshing\u0026quot; MetaDataFormat = \u0026quot;toml\u0026quot; :wq $  Generate the Site Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $  Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public total 16 drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css -rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html -rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js -rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml $  Notice four things:\n Hugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically.  The Home Page Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]  If it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html $  The Magic of Static Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld drwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes drwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js $  The Theme Development Cycle When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n Purge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4.  I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory. ## $ rm -rf public ## ## run hugo in watch mode ## $ hugo server --watch --verbose  Here\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public $ hugo server --watch --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Watching for changes in /Users/quoha/Sites/zafta/content Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop INFO: 2014/09/29 File System Event: [\u0026quot;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026quot;: MODIFY|ATTRIB] Change detected, rebuilding site WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 1 ms  Update the Home Page Template The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\n index.html _default/list.html _default/single.html  We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Build the web site and then verify the results.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt;  Live Reload Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://' + (location.host || 'localhost').split(':')[0] + ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/' + 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  When you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md ERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{} $  That wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md +++ Description = \u0026quot;\u0026quot; Tags = [] Categories = [] +++ :wq $ find themes/zafta/archetypes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md /Users/quoha/Sites/zafta/content/post/first.md created $ hugo --verbose new post/second.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/second.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md /Users/quoha/Sites/zafta/content/post/second.md created $ ls -l content/post total 16 -rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md -rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md $ cat content/post/first.md +++ Categories = [] Description = \u0026quot;\u0026quot; Tags = [] date = \u0026quot;2014-09-29T21:54:53-05:00\u0026quot; title = \u0026quot;first\u0026quot; +++ my first post $ cat content/post/second.md +++ Categories = [] Description = \u0026quot;\u0026quot; Tags = [] date = \u0026quot;2014-09-29T21:57:09-05:00\u0026quot; title = \u0026quot;second\u0026quot; +++ my second post $  Build the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;, \u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $  The output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html $  The new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\n range .Title end  The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l -rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html  We could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $  Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html $ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Notice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026quot;tag\u0026quot;:\u0026quot;tags\u0026quot;, \u0026quot;category\u0026quot;:\u0026quot;categories\u0026quot;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name '*.html' | xargs ls -l -rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/second/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;/post/first/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $  Create a Post Listing We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html  As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md +++ title = \u0026quot;about\u0026quot; description = \u0026quot;about this site\u0026quot; date = \u0026quot;2014-09-27\u0026quot; slug = \u0026quot;about time\u0026quot; +++ ## about us i'm speechless :wq  Generate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html  Notice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/theme/\u0026quot;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/about-time/\u0026quot;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/second-post/\u0026quot;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026quot;http://localhost:1313/post/first-post/\u0026quot;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt;document.write('\u0026lt;script src=\u0026quot;http://' + (location.host || 'localhost').split(':')[0] + ':1313/livereload.js?mindelay=10\u0026quot;\u0026gt;\u0026lt;/' + 'script\u0026gt;')\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Notice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026quot;post\u0026quot;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if eq .Type \u0026quot;page\u0026quot; }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq  Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html  Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml [permalinks] page = \u0026quot;/:title/\u0026quot; about = \u0026quot;/:filename/\u0026quot;  Generate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; :wq $ vi themes/zafta/layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq  Update the Home Page Template to Use the Partials The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026quot;theme/partials/header.html\u0026quot; . }}  versus\n{{ partial \u0026quot;header.html\u0026quot; . }}  Both pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026quot;post\u0026quot;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if or (eq .Type \u0026quot;page\u0026quot;) (eq .Type \u0026quot;about\u0026quot;) }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026quot;{{ .Permalink }}\u0026quot;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}  Posts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Generate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Now we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html {{ partial \u0026quot;header.html\u0026quot; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026quot;Mon, Jan 2, 2006\u0026quot; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026quot;footer.html\u0026quot; . }} :wq  Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n"});index.add({'id':11,'href':'/learning_fpga/posts/migrate-from-jekyll/','title':"Migrate to Hugo from Jekyll",'content':" Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ \u0026lt;root\u0026gt;/ ▾ images/ logo.png  should become\n▾ \u0026lt;root\u0026gt;/ ▾ static/ ▾ images/ logo.png  Additionally, you\u0026rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.\nCreate your Hugo configuration file Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.\nSet your configuration publish folder to _site The default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you\u0026rsquo;ll want to do one of two alternatives:\n Change your submodule to point to map gh-pages to public instead of _site (recommended).\ngit submodule deinit _site git rm _site git submodule add -b gh-pages git@github.com:your-username/your-repo.git public  Or, change the Hugo configuration to use _site instead of public.\n{ .. \u0026quot;publishdir\u0026quot;: \u0026quot;_site\u0026quot;, .. }   Convert Jekyll templates to Hugo templates That\u0026rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll\u0026rsquo;s template documentation if you need to refresh your memory on how you built your blog and Hugo\u0026rsquo;s template to learn Hugo\u0026rsquo;s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.\nConvert Jekyll plugins to Hugo shortcodes Jekyll has plugins; Hugo has shortcodes. It\u0026rsquo;s fairly trivial to do a port.\nImplementation As an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll\u0026rsquo;s plugin:\nmodule Jekyll class ImageTag \u0026lt; Liquid::Tag @url = nil @caption = nil @class = nil @link = nil // Patterns IMAGE_URL_WITH_CLASS_AND_CAPTION = IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;(\\s+)-\u0026gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i IMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;/i IMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i IMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i def initialize(tag_name, markup, tokens) super if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK @class = $1 @url = $3 @caption = $7 @link = $9 elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION @class = $1 @url = $3 @caption = $7 elsif markup =~ IMAGE_URL_WITH_CAPTION @url = $1 @caption = $5 elsif markup =~ IMAGE_URL_WITH_CLASS @class = $1 @url = $3 elsif markup =~ IMAGE_URL @url = $1 end end def render(context) if @class source = \u0026quot;\u0026lt;figure class='#{@class}'\u0026gt;\u0026quot; else source = \u0026quot;\u0026lt;figure\u0026gt;\u0026quot; end if @link source += \u0026quot;\u0026lt;a href=\\\u0026quot;#{@link}\\\u0026quot;\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;img src=\\\u0026quot;#{@url}\\\u0026quot;\u0026gt;\u0026quot; if @link source += \u0026quot;\u0026lt;/a\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;figcaption\u0026gt;#{@caption}\u0026lt;/figcaption\u0026gt;\u0026quot; if @caption source += \u0026quot;\u0026lt;/figure\u0026gt;\u0026quot; source end end end Liquid::Template.register_tag('image', Jekyll::ImageTag)  is written as this Hugo shortcode:\n\u0026lt;!-- image --\u0026gt; \u0026lt;figure {{ with .Get \u0026quot;class\u0026quot; }}class=\u0026quot;{{.}}\u0026quot;{{ end }}\u0026gt; {{ with .Get \u0026quot;link\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt;{{ end }} \u0026lt;img src=\u0026quot;{{ .Get \u0026quot;src\u0026quot; }}\u0026quot; {{ if or (.Get \u0026quot;alt\u0026quot;) (.Get \u0026quot;caption\u0026quot;) }}alt=\u0026quot;{{ with .Get \u0026quot;alt\u0026quot;}}{{.}}{{else}}{{ .Get \u0026quot;caption\u0026quot; }}{{ end }}\u0026quot;{{ end }} /\u0026gt; {{ if .Get \u0026quot;link\u0026quot;}}\u0026lt;/a\u0026gt;{{ end }} {{ if or (or (.Get \u0026quot;title\u0026quot;) (.Get \u0026quot;caption\u0026quot;)) (.Get \u0026quot;attr\u0026quot;)}} \u0026lt;figcaption\u0026gt;{{ if isset .Params \u0026quot;title\u0026quot; }} {{ .Get \u0026quot;title\u0026quot; }}{{ end }} {{ if or (.Get \u0026quot;caption\u0026quot;) (.Get \u0026quot;attr\u0026quot;)}}\u0026lt;p\u0026gt; {{ .Get \u0026quot;caption\u0026quot; }} {{ with .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt; {{ end }} {{ .Get \u0026quot;attr\u0026quot; }} {{ if .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/figcaption\u0026gt; {{ end }} \u0026lt;/figure\u0026gt; \u0026lt;!-- image --\u0026gt;  Usage I simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were \u0026quot;having fun\u0026quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; -\u0026gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %}  to this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{% fig class=\u0026quot;full\u0026quot; src=\u0026quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\u0026quot; title=\u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; link=\u0026quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\u0026quot; %}}  As a bonus, the shortcode named parameters are, arguably, more readable.\nFinishing touches Fix content Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\nClean up You\u0026rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn\u0026rsquo;t used, delete it.\nA practical example in a diff Hey, it\u0026rsquo;s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.\n"});index.add({'id':12,'href':'/learning_fpga/docs/example/table-of-contents/','title':"Table of Contents",'content':" Ubi loqui Mentem genus facietque salire tempus bracchia Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  Placabilis coactis nega ingemuit ignoscat nimia non Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; }  Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':13,'href':'/learning_fpga/docs/example/2nd/','title':"2nd",'content':" 2nd Level of Menu Cognita laeva illo fracta Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':14,'href':'/learning_fpga/docs/','title':"Docs",'content':""});index.add({'id':15,'href':'/learning_fpga/','title':"Introduction",'content':"FPGA入門\n"});index.add({'id':16,'href':'/learning_fpga/posts/','title':"Posts",'content':""});index.add({'id':17,'href':'/learning_fpga/posts/goisforlovers/','title':"(Hu)go Template Primer",'content':" Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.\nThis document is a brief primer on using Go templates. The Go docs provide more details.\nIntroduction to Go Templates Go templates provide an extremely simple template language. It adheres to the belief that only the most basic of logic belongs in the template or view layer. One consequence of this simplicity is that Go templates parse very quickly.\nA unique characteristic of Go templates is they are content aware. Variables and content will be sanitized depending on the context of where they are used. More details can be found in the Go docs.\nBasic Syntax Golang templates are HTML files with the addition of variables and functions.\nGo variables and functions are accessible within {{ }}\nAccessing a predefined variable \u0026ldquo;foo\u0026rdquo;:\n{{ foo }}  Parameters are separated using spaces\nCalling the add function with input of 1, 2:\n{{ add 1 2 }}  Methods and fields are accessed via dot notation\nAccessing the Page Parameter \u0026ldquo;bar\u0026rdquo;\n{{ .Params.bar }}  Parentheses can be used to group items together\n{{ if or (isset .Params \u0026quot;alt\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;) }} Caption {{ end }}  Variables Each Go template has a struct (object) made available to it. In hugo each template is passed either a page or a node struct depending on which type of page you are rendering. More details are available on the variables page.\nA variable is accessed by referencing the variable name.\n\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt;  Variables can also be defined and referenced.\n{{ $address := \u0026quot;123 Main St.\u0026quot;}} {{ $address }}  Functions Go template ship with a few functions which provide basic functionality. The Go template system also provides a mechanism for applications to extend the available functions with their own. Hugo template functions provide some additional functionality we believe are useful for building websites. Functions are called by using their name followed by the required parameters separated by spaces. Template functions cannot be added without recompiling hugo.\nExample:\n{{ add 1 2 }}  Includes When including another template you will pass to it the data it will be able to access. To pass along the current context please remember to include a trailing dot. The templates location will always be starting at the /layout/ directory within Hugo.\nExample:\n{{ template \u0026quot;chrome/header.html\u0026quot; . }}  Logic Go templates provide the most basic iteration and conditional logic.\nIteration Just like in Go, the Go templates make heavy use of range to iterate over a map, array or slice. The following are different examples of how to use range.\nExample 1: Using Context\n{{ range array }} {{ . }} {{ end }}  Example 2: Declaring value variable name\n{{range $element := array}} {{ $element }} {{ end }}  Example 2: Declaring key and value variable name\n{{range $index, $element := array}} {{ $index }} {{ $element }} {{ end }}  Conditionals If, else, with, or, \u0026amp; and provide the framework for handling conditional logic in Go Templates. Like range, each statement is closed with end.\nGo Templates treat the following values as false:\n false 0 any array, slice, map, or string of length zero  Example 1: If\n{{ if isset .Params \u0026quot;title\u0026quot; }}\u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt;{{ end }}  Example 2: If -\u0026gt; Else\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{else}} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }}  Example 3: And \u0026amp; Or\n{{ if and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}}  Example 4: With\nAn alternative way of writing \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent.\nThe first example above could be simplified as:\n{{ with .Params.title }}\u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt;{{ end }}  Example 5: If -\u0026gt; Else If\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{ else if isset .Params \u0026quot;caption\u0026quot; }} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }}  Pipes One of the most powerful components of Go templates is the ability to stack actions one after another. This is done by using pipes. Borrowed from unix pipes, the concept is simple, each pipeline\u0026rsquo;s output becomes the input of the following pipe.\nBecause of the very simple syntax of Go templates, the pipe is essential to being able to chain together function calls. One limitation of the pipes is that they only can work with a single value and that value becomes the last parameter of the next pipeline.\nA few simple examples should help convey how to use the pipe.\nExample 1 :\n{{ if eq 1 1 }} Same {{ end }}  is the same as\n{{ eq 1 1 | if }} Same {{ end }}  It does look odd to place the if at the end, but it does provide a good illustration of how to use the pipes.\nExample 2 :\n{{ index .Params \u0026quot;disqus_url\u0026quot; | html }}  Access the page parameter called \u0026ldquo;disqus_url\u0026rdquo; and escape the HTML.\nExample 3 :\n{{ if or (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Stuff Here {{ end }}  Could be rewritten as\n{{ isset .Params \u0026quot;caption\u0026quot; | or isset .Params \u0026quot;title\u0026quot; | or isset .Params \u0026quot;attr\u0026quot; | if }} Stuff Here {{ end }}  Context (aka. the dot) The most easily overlooked concept to understand about Go templates is that {{ . }} always refers to the current context. In the top level of your template this will be the data set made available to it. Inside of a iteration it will have the value of the current item. When inside of a loop the context has changed. . will no longer refer to the data available to the entire page. If you need to access this from within the loop you will likely want to set it to a variable instead of depending on the context.\nExample:\n {{ $title := .Site.Title }} {{ range .Params.tags }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026quot;{{ $baseurl }}/tags/{{ . | urlize }}\u0026quot;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; - {{ $title }} \u0026lt;/li\u0026gt; {{ end }}  Notice how once we have entered the loop the value of {{ . }} has changed. We have defined a variable outside of the loop so we have access to it from within the loop.\nHugo Parameters Hugo provides the option of passing values to the template language through the site configuration (for sitewide values), or through the meta data of each specific piece of content. You can define any values of any type (supported by your front matter/config format) and use them however you want to inside of your templates.\nUsing Content (page) Parameters In each piece of content you can provide variables to be used by the templates. This happens in the front matter.\nAn example of this is used in this documentation site. Most of the pages benefit from having the table of contents provided. Sometimes the TOC just doesn\u0026rsquo;t make a lot of sense. We\u0026rsquo;ve defined a variable in our front matter of some pages to turn off the TOC from being displayed.\nHere is the example front matter:\n--- title: \u0026quot;Permalinks\u0026quot; date: \u0026quot;2013-11-18\u0026quot; aliases: - \u0026quot;/doc/permalinks/\u0026quot; groups: [\u0026quot;extras\u0026quot;] groups_weight: 30 notoc: true ---  Here is the corresponding code inside of the template:\n {{ if not .Params.notoc }} \u0026lt;div id=\u0026quot;toc\u0026quot; class=\u0026quot;well col-md-4 col-sm-6\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; {{ end }}  Using Site (config) Parameters In your top-level configuration file (eg, config.yaml) you can define site parameters, which are values which will be available to you in chrome.\nFor instance, you might declare:\nparams: CopyrightHTML: \u0026quot;Copyright \u0026amp;#xA9; 2013 John Doe. All Rights Reserved.\u0026quot; TwitterUser: \u0026quot;spf13\u0026quot; SidebarRecentLimit: 5  Within a footer layout, you might then declare a \u0026lt;footer\u0026gt; which is only provided if the CopyrightHTML parameter is provided, and if it is given, you would declare it to be HTML-safe, so that the HTML entity is not escaped again. This would let you easily update just your top-level config file each January 1st, instead of hunting through your templates.\n{{if .Site.Params.CopyrightHTML}}\u0026lt;footer\u0026gt; \u0026lt;div class=\u0026quot;text-center\u0026quot;\u0026gt;{{.Site.Params.CopyrightHTML | safeHtml}}\u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt;{{end}}  An alternative way of writing the \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent:\n{{with .Site.Params.TwitterUser}}\u0026lt;span class=\u0026quot;twitter\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;https://twitter.com/{{.}}\u0026quot; rel=\u0026quot;author\u0026quot;\u0026gt; \u0026lt;img src=\u0026quot;/images/twitter.png\u0026quot; width=\u0026quot;48\u0026quot; height=\u0026quot;48\u0026quot; title=\u0026quot;Twitter: {{.}}\u0026quot; alt=\u0026quot;Twitter\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt;{{end}}  Finally, if you want to pull \u0026ldquo;magic constants\u0026rdquo; out of your layouts, you can do so, such as in this example:\n\u0026lt;nav class=\u0026quot;recent\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;Recent Posts\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{{.RelPermalink}}\u0026quot;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{end}}\u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt;  "});index.add({'id':18,'href':'/learning_fpga/categories/','title':"Categories",'content':""});index.add({'id':19,'href':'/learning_fpga/categories/development/','title':"Development",'content':""});index.add({'id':20,'href':'/learning_fpga/tags/development/','title':"development",'content':""});index.add({'id':21,'href':'/learning_fpga/posts/hugoisforlovers/','title':"Getting Started with Hugo",'content':" Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.\nSave it somewhere specific as we will be using it in the next step.\nMore complete instructions are available at Install Hugo\nStep 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.\nFollow the following steps:\n Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313  Corresponding pseudo commands:\ngit clone https://github.com/spf13/hugo cd hugo /path/to/where/you/installed/hugo server --source=./docs \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Press ctrl+c to stop  Once you\u0026rsquo;ve gotten here, follow along the rest of this page on your local build.\nStep 3. Change the docs site Stop the Hugo process by hitting Ctrl+C.\nNow we are going to run hugo again, but this time with hugo in watch mode.\n/path/to/hugo/from/step/1/hugo server --source=./docs --watch \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Watching for changes in /Users/spf13/Code/hugo/docs/content \u0026gt; Press ctrl+c to stop  Open your favorite editor and change one of the source content pages. How about changing this very file to fix the typo. How about changing this very file to fix the typo.\nContent files are found in docs/content/. Unless otherwise specified, files are located at the same relative location as the url, in our case docs/content/overview/quickstart.md.\nChange and save this file.. Notice what happened in your terminal.\n\u0026gt; Change detected, rebuilding site \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 26 ms  Refresh the browser and observe that the typo is now fixed.\nNotice how quick that was. Try to refresh the site before it\u0026rsquo;s finished building. I double dare you. Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.\nStep 4. Have fun The best way to learn something is to play with it.\n"});index.add({'id':22,'href':'/learning_fpga/tags/go/','title':"go",'content':""});index.add({'id':23,'href':'/learning_fpga/categories/golang/','title':"golang",'content':""});index.add({'id':24,'href':'/learning_fpga/tags/golang/','title':"golang",'content':""});index.add({'id':25,'href':'/learning_fpga/tags/hugo/','title':"hugo",'content':""});index.add({'id':26,'href':'/learning_fpga/tags/','title':"Tags",'content':""});index.add({'id':27,'href':'/learning_fpga/tags/templates/','title':"templates",'content':""});index.add({'id':28,'href':'/learning_fpga/tags/themes/','title':"themes",'content':""});index.add({'id':29,'href':'/learning_fpga/docs/book01/introduction_figures/readme/','title':"R E a D M E",'content':""});index.add({'id':30,'href':'/learning_fpga/docs/example/2nd/3rd/4th/','title':"4th",'content':" 4th Level of Menu Caesorum illa tu sentit micat vestes papyriferi Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"});index.add({'id':31,'href':'/learning_fpga/docs/example/2nd/3rd/','title':"3rd",'content':" 3rd Level of Menu Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);  "});index.add({'id':32,'href':'/learning_fpga/docs/example/hidden/','title':"Hidden",'content':" This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired));  "});index.add({'id':33,'href':'/learning_fpga/docs/shortcodes/','title':"Shortcodes",'content':""});index.add({'id':34,'href':'/learning_fpga/docs/shortcodes/buttons/','title':"Buttons",'content':" Buttons Buttons are styled links that can lead to local page or external link.\n{{\u0026lt; button relref=\u0026quot;/\u0026quot; [class=\u0026quot;...\u0026quot;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026quot;https://github.com/alex-shpak/hugo-book\u0026quot; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Example  Get Home  Contribute  "});index.add({'id':35,'href':'/learning_fpga/docs/shortcodes/columns/','title':"Columns",'content':" Columns Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic sparator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}}  Example Left Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.  Mid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!  Right Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.   "});index.add({'id':36,'href':'/learning_fpga/docs/shortcodes/expand/','title':"Expand",'content':" Expand Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample Default {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Expand ↕  Markdown content Lorem markdownum insigne\u0026hellip;    With Custom Label {{\u0026lt; expand \u0026quot;Custom Label\u0026quot; \u0026quot;...\u0026quot; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}}   Custom Label ...  Markdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.    "});index.add({'id':37,'href':'/learning_fpga/docs/shortcodes/hints/','title':"Hints",'content':" Hints Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}}  Example Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa  "});index.add({'id':38,'href':'/learning_fpga/docs/shortcodes/katex/','title':"Katex",'content':" KaTeX KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample {{\u0026lt; katex [class=\u0026quot;text-center\u0026quot;] \u0026gt;}} x = \\begin{cases} a \u0026amp;\\text{if } b \\\\ c \u0026amp;\\text{if } d \\end{cases} {{\u0026lt; /katex \u0026gt;}}    \n$$ x = \\begin{cases} a \u0026\\text{if } b \\\\ c \u0026\\text{if } d \\end{cases} $$   "});index.add({'id':39,'href':'/learning_fpga/docs/shortcodes/mermaid/','title':"Mermaid",'content':" Mermaid Chart Mermaid is library for generating svg charts and diagrams from text.\nExample {{\u0026lt; mermaid [class=\u0026quot;text-center\u0026quot;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}}    sequenceDiagram Alice-Bob: Hello Bob, how are you? alt is sick Bob-Alice: Not so good :( else is well Bob-Alice: Feeling fresh like a daisy end opt Extra response Bob-Alice: Thanks for asking end   "});index.add({'id':40,'href':'/learning_fpga/docs/shortcodes/tabs/','title':"Tabs",'content':" Tabs Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026quot;uniqueid\u0026quot; \u0026gt;}} {{\u0026lt; tab \u0026quot;MacOS\u0026quot; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026quot;Linux\u0026quot; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026quot;Windows\u0026quot; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}  Example MacOS  MacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Linux  Linux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n Windows  Windows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n  "});})();