'use strict';(function(){const indexCfg=;indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/learning_fpga/docs/book01/','title':"RTL編",'content':""});index.add({'id':1,'href':'/learning_fpga/docs/book02/','title':"高位合成編",'content':""});index.add({'id':2,'href':'/learning_fpga/docs/book01/introduction/','title':"イントロダクション",'content':" イントロダクション ○○を制御したいけどソフトウェアじゃ難しい 実験などのために，何かの入力を観測しながら，それに応じて何かの処理をする，という機会がありませんか？そのような場合，パソコンやマイコンで実装してみようとしても\n モータやセンサをたくさんつなぎたいから100個くらい自由に使える入出力があればいいのに システムを乾電池1本で動作しないかなあ 決められた時間内できちんと処理を終わらせたい/繰り返したい 処理専用の特別な命令を実行できたら高速化できるのにな いくつもの処理を並行して実行できたらいいのにな 361ビットの値の演算が一発でできたらすっきり書けるのに など，ソフトウェアではあと一息痒いところに手が届かず，歯痒い思いをしたことはないでしょうか．  プロセッサがプログラムを実行する パソコンはもちろんのこと，今やテレビや携帯電話，自動車などのあらゆる製品の中でソフトウェアが動作しています．それらのソフトウェアは，実現したいアプリケーションや動作させる環境に応じて，さまざまなプログラミング言語で記述されています．たとえば，JavaScriptはWebアプリケーションを便利に華やかにしてくれますし，Cで記述されたプログラムはシステムを細やかに制御し，高速に動作させることができます．\n近年のソフトウェアが動作する環境は，プログラミング言語やオペレーティング・システム，ライブラリなどにより上手に隠蔽されていますので，抽象化された世界の上でプログラムを書けるソフトウェア・エンジニアは，ハードウェアを意識することが少ないかもしれませんが，どのような言語を使ったプログラムでも，ハードウェアであるプロセッサで処理が実行されます．\nたとえば，パソコン上で動作するソフトウェアはIntelのCore i7などのプロセッサの上で動作し，スマートフォンの上のソフトはARMプロセッサの上で動作しています．また，組み込み機器でも各種マイコンの上で処理が実行されています．一般に，マイコンは，演算装置に加え様々なデバイスを制御するためのI/Oコントローラを備えているためセンサの入力を読み取ったり，モーターを回したりといった処理をソフトウェアで操作できます． 「プロセッサ」や「マイコン」はデバイスそのものがアプリケーションに応じて変化するわけではなく，図1のように，ソフトウェアによって処理させる内容をその時々で決めることができるため，幅広い用途に活用されています．\n 図1: ソフトウェアプログラムはプロセッサの上で処理される．どんなプログラムを実行する場合でもプロセッサの構造は変わらない\n  一方で，自由に設計できるようにみえるソフトウェアも，実際に動作するときには，常にプロセッサの制約を受けます．たとえば，プロセッサの処理能力の限界を越えるような速さでの計算や，プロセッサがもっていないI/Oを操作するといったことはできません． しかし，デバイスそのものをアプリケーションに応じて変化させて，冒頭に挙げたような「もし○○なプログラムが書けたなら」の希望を現実にできる手段があれば，今まで手を出しにくかったアプリケーションが実現できるのではないでしょうか．\nハードウェア・デバイスを作るための便利な仕組み そんなときには，オリジナルのハードウェアを作るという解決策があります．ハードウェアを作るといっても，げじげじの足が付いたデバイスを一つずつはんだ付けしたり，半導体工場に製作を依頼する必要はありません．ハードウェア記述言語（HDL；Hardware Description Language）を用いて作成したハードウェア・イメージを専用のデバイス（FPGA）に書き込むだけでオリジナルのハードウェア・デバイスを作る便利な仕組みがあります． FPGAは，図2のように，論理回路になる素や，論理回路同士を接続する素がパッケージされたLSIです．\n 図2: FPGAは，論理回路の素や配線回路の素がパッケージされたLSI\n  用途によって，とにかく短い時間で処理をしたい，低消費電力で処理をさせたい，同時にたくさんのI/Oにアクセスしたいといったことが求められることもあるでしょう．FPGAは，そんな要求に応えることができる，やりたい処理をさせるための専用ハードウェアを自在に作れる柔らかいプログラム可能なハードウェア・デバイスです(図3)．\n 図2: FPGAは，実現したい処理向けの専用ロジックを自分で作ることができる\n  FPGAには小さなメモリ(LUT)がたくさん入っている FPGAの中身はどのようになっているのか，もう少し詳しくのぞいてみましょう．図3は，代表的なFPGAメーカーであるXilinxとIntelのFPGAの内部構造です．多少違いはありますが，基本的な構成要素は，LUT(Look-up Table)と記憶素子(D-FF)で構成されるロジック・セルです．\n 図3: FPGAの内部構造\n  好きな論理演算を実現する鍵はLUTで，これは小規模なメモリのようなものです．入力されたデータに対して出力する信号を決定するためのテーブルの役割を持ちます．\nたとえば，図3のように，アドレス0に0，それ以外のアドレス1〜63には，1と書いてあるLUTの場合には，6入力1出力のOR回路に相当します．同様に，アドレス0〜62に0をアドレス63に1と書いておけば，6入力1出力のAND回路を作ることができます．また，1が奇数個のアドレス，たとえば，アドレス1，2，4，7など，のみに1と書いておけば，6入力1出力のXOR回路になります．\n入力ビット幅の範囲で好きな論理演算を決められるLUTと，複数のLUTを好きに接続できる接続テーブルによって，大規模な論理演算を好きに構成することができますね．\nハードウェアと記述言語 LUTと接続テーブルを設定して，ハードウェアを自由に設計できるといっても，ソフトウェアでは簡単に書ける足し算や引き算といった基本的な演算を，一つ一つ論理回路で構成するのは骨が折れる作業です．そこで利用するのがハードウェア記述言語(HDL; Hardware Description Language)です．\nHDLは，Cプログラミングなどと同じように変数への加減算や条件分岐などを用いてハードウェアを設計できるプログラミング言語です．ユーザは，まるでプログラムをロードするように，ハードウェア・データをFPGAに書き込むことで所望のデバイスを作ることができます．\nハードウェア・プログラミングを理解する三つのポイント オリジナルのハードウェアを作成するための手段が，ハードウェア・プログラミングです．ソフトウェア・プログラミングでは，プロセッサ(というハードウェア)を動作させるための命令列を設計するのに対し，ハードウェア・プログラミングは，ハードウェアそのものを設計します．ハードウェア・プログラミングにチャレンジするにあたり，ハードウェアの基本概念となる「演算の決め方」と「データの単位」，「処理の動作方式」についてソフトウェア・プログラミングと比較しながら説明します．\n演算の決め方 ソフトウェア・プログラミングでは，演算はプロセッサのもつ命令として決められています．一方でハードウェア・プログラミングでは，論理演算を組み合わせて自分で演算を決めることができます．\nソフトウェア・プログラミング ソフトウェア・プログラミングは，プロセッサの演算ユニットが持つ機能をどのように利用するかを指示します．プロセッサの演算ユニットでは，足し算や掛け算などの算術演算や，比較演算，分岐などの処理を制御する命令を実行できます．また，信号処理を高速に処理できるように「掛け算して足し算」するといった命令を備えているプロセッサもありあます．実際にプロセッサの演算ユニットをどのように使うか，を決定するのはコンパイラの仕事で，プログラマは，普段ほとんど意識する必要はありません．\nハードウェア・プログラミング ハードウェア・プログラミングは，ハードウェアそのものを作成するので，ベースとなる演算ユニットというものは存在しません．演算処理は，基本的には，NOT，AND，ORの論理演算とそれらの組み合わせで実現します．\nデータの単位 ソフトウェア・プログラミングとハードウェア・プログラミングで取り扱い可能なデータの単位について比べてみます．\nソフトウェア・プログラミング 一般に，プロセッサの作業領域であるレジスタの幅は固定されていて，ソフトウェア・プログラミングではそのサイズでしかデータを取り扱えません．たとえば，レジスタ幅が32ビットのプロセッサでは，1という値も4294967295という大きな値も32ビット幅のデータとして処理されます．また，512ビットという大きな値を取り扱うためには，512÷32の16回分のデータ処理を必要とします．\nハードウェア・プログラミング ハードウェア・プログラミングでは，‘0’または‘1’の値である1ビット単位のデータを自由に組み合わせて利用できます．処理内容によって，好きなビット数のデータを定義できるので，大きいデータも小さいデータも自由に定義して処理できます．512ビットのデータも，ハードウェア・プログラミングなら1回のデータ処理で取り扱えます．\n処理の動作方式 ソフトウェア・プログラムは，プロセッサが記述した処理を順序よく実行してくれます．しかし，ハードウェア・プログラムは，生成されたハードウェア回路そのものがデータを処理します．そのため，処理の順序を守るための仕組みが必要な場合には自分でそのしくみを作る必要があります(図4)．\n 図4: ソフトウェア・プログラミングではプロセッサが処理順序を決めてくれる．ハードウェア・プログラミングでは，ハードウェアを構成する回路同士の接続関係や，いつデータを転送するかを全部自分で決める必要がある．\n  ソフトウェア・プログラミング 今日のプロセッサの基本的な構成方式は，図5に示すノイマン型アーキテクチャと呼ばれる方式です．ノイマン型アーキテクチャがプログラムを実行する手順はおよそ次の通りです．\n 命令を読み込む 読み込んだプログラムの命令を理解する 演算ユニット上で命令を実行する 必要に応じてメモリを読み書きする 1.に戻る  パソコンのプロセッサに見られる「クロック3GHz」といったスペックのプロセッサでは，プロセッサ内のユニットが3GHzのクロックに同期して，すなわち0.33n秒程度の時間で動作することで，このサイクルが繰り返されます．\n 図5: 今日のプロセッサの典型的な構成方式．処理性能向上のために，各ユニットは可能な限り並行に動作するように工夫されることが多い．\n  命令を実行する，演算ユニットでは，決められたビット幅の作業領域の値に足し算や掛け算などの演算を適用できます．高い処理性能を達成するために，複数の演算ユニットを持つプロセッサもあり，それらのプロセッサでは，演算ユニットの個数分だけ同時に命令を処理することができます．勿論，「演算Aの後に演算Bを計算しないと演算Aの結果が保存されない，とか，演算Bの入力が揃う前に計算をはじめてしまう」ということは普通はなく，プロセッサが演算の順番を守ってくれます．\nハードウェア・プログラミング ハードウェアの基本となる論理演算回路において，入力信号を与えてから出力信号が得られるまでの時間は，トランジスタの特性や論理演算の段数で決定されます．そのため，複雑にゲートが関係し合うような回路で，データが正しく到達することを考慮するのは大変困難です(図6)．\n 図6: 入力された信号に対して出力が確定するまでの時間は，論理演算回路を構成する論理演算の段数で決まる．\n  ハードウェア・プログラミングでは，これを解決するために大抵の場合，「同期順序回路」という構成方法を利用します．同期順序回路では，独立に動作するハードウェア中のモジュールのデータの入力のタイミングを，共通の信号「クロック」に合わせて制御します．ある単位処理を受けもつハードウェア・モジュールは，クロックが立ち上がりや立ち下がりから一定期間の間で必ず信号を読み取ることにします(図7)．全てのモジュールが，(1)クロックに間にあうように信号を決定し，(2)一定の期間値を変更しない，というルールさえ守れば，全体の演算が正しく動作します．\n 図7: 入力された信号に対して出力が確定するまでの時間は，論理演算回路を構成する論理演算の段数で決まる．\n  回路全体がクロックに合わせて動作するため，クロックの周期が短いほど全体が高速に動作します．しかし，やみくもにクロックを短くできるというわけではありません．\nハードウェア・プログラミングの流れ - 使用する言語と必要なツールは？ ハードウェア・プログラングの詳細は，以降の章で実例と共に紹介しますが，まずは全体の流れのイメージをつかんでみましょう．\nFPGAを使ったハードウェア・プログラミングは，図8のような流れで行ないます．流れ自体はソフトウェア・プログラミングとあまり変わりません．\n 図8: FPGAを使ったハードウェア・プログラミングの流れ．\n  ハードウェア・プログラミングには，ハードウェア記述言語(HDL; Hardware Description Language)を使用します．一般的に使用されているのは，VHDLとVerilog HDLの2種類です．記述自体は好きなテキストエディタで行なって構いません．図9は，emacsを使ってVHDLを記述している例です．\n 図9: emacsを使ってVHDLを記述している例．\n  HDLでハードウェアを設計したら，正しく動作を記述できているかRTLシミュレーションというフローで確認します．コマンドラインベースで使える簡単なシミュレーションツールや，回路の動作の流れを信号の変化をグラフィカルに表示するツールなどがあります．図10は，図9で記述したハードウェアをシミュレーションし信号の変化を描画した様子です．\n 図10: シミュレーション結果を確認している様子．\n  動作の確認ができたら，開発ツールの助けを借りてハードウェアに書き込む構成情報を生成します．開発ツールで行う作業は，合成と配置配線，構成情報生成の3段階です．必要なツールは，FPGAベンダである米国のIntel社とXilinx社の両方から，それぞれ専用のものが提供されています．また，最適化処理などに特色を持つサード・パーティ製の開発ツールもあり，必要に応じて使い分けるとよいでしょう．図11は，開発ツールの例です．\n 図11: 開発ツールを使って，合成・配置配線・構成情報の生成を行なう．\n  開発ツールの行う，ハードウェア・プログラミング特有の作業内容は次の通りです．\n 合成 - 論理回路に置き換える処理] 記述されたHDLを解釈し，論理回路に置き換えます．また，さまざまな最適化を適用し，小さく高速な回路を自動で生成します． [配置配線 - ロジック・セルの割り当てと接続を決定] 合成して生成した論理回路をFPGA内にあるロジック・セルを組み合わせて実現するための割り当てと接続関係を決定します．ここで，ユーザが「特定の回路同士を近付ける」や，「特定の出力を好きなピンにアサインする」などの設定を与えられます． [構成情報生成- 書き込み用ファイルを作る] 最後にFPGAに書き込み可能な構成情報を生成します．  ソフトウェア・プログラミングであれば，コンパイル，リンク，バイナル生成に相当するステップだと思えばよいでしょう．\n構成情報の生成が完了したら，そのデータを書き込みソフトウェアを使用してFPGAに書き込むことで設計したハードウェアを動かすことができます．\nさいごに 本章では，オリジナルのハードウェア・デバイスを設計する方法として，ハードウェア記述言語とFPGAを用いた開発のプロセスについて説明しました．特に，ソフトウェア・プログラミングとハードウェア・プログラミングを対比させながらその違いについて説明しました．ハードウェア設計は自由度が高い分，自分で面倒を見なければならない部分も多いのですが，プロセッサの制約に縛られずにアイデアを実現できる可能性を秘めています． FPGAとHDLによるハードウェア設計に興味を持って，はじめの一歩を踏み出してもらえると嬉しいです．\n"});index.add({'id':3,'href':'/learning_fpga/docs/book01/languages/','title':"VHDL/Veilog 入門",'content':" はじめに 本章では，ハードウェア記述言語(HDL; Hardware Description Language)のうち，よく使用されるVHDLとVerilog HDLの二つのHDLの基本文法を説明します．ちょっとした違いを発見しながら読み進めると面白いでしょう．\nソフトウェア・プログラミングで使用するCやJava，コミュニケーションで使用する英語についても，正しく使用するために文法の知識は欠かせません．同じようにHDLで設計する際も文法の知識が必要です．ここで，基本文法をしっかり押さえましょう．\nハードウェア記述言語の基本概念 プログラミング言語に多くの種類があるように，ハードウェア記述言語(HDL)にもさまざまな種類があります．その中でもよく利用されるのが，VHDLとVerilog HDLです．VHDLとVerilog HDLは，どちらも，ハードウェアを表現するための似たような概念を取り扱うことができる言語です．\nただし，似たような概念でもそれぞれの言語で使用する言葉が違うので注意が必要です．両方の言語に共通する概念と，言語の特徴について説明します．\n構造の基本 \u0026mdash; エンティティ/モジュール どの言語にも基本的な構造があります．たとえば，Cでは関数，Javaではクラスなどです．HDLでは，与えられた入力に対して出力を生成するブロックが基本的な単位です(図1)．このブロックをVHDLではエンティティ entity ，Verilog HDLではモジュール module と呼びます．ただし，この章では，特にVHDLやVerilog HDLに違いがない説明では，モジュールと呼ぶことにします．\n 図1: ハードウェア・プログラミングの基本的な単位\n  通常のプログラミング言語とHDLの大きな違いは，エンティティ/モジュールは，最初から最後まで与えられた入力に対する出力を生成し続けるということです．Cなどで関数を呼び出す場合，mainプログラムからその関数内へ処理が移ります(図2)．処理を終えると戻り値を呼び出し元に返し，mainプログラムが再び動き始めます．つまり，mainプログラムは，呼び出した関数の処理が完了するまで待たされます．これは，プログラム・カウンタが，プログラムを順々に呼び出して実行するからです．\n 図2: Cで記述した一般的なソフトウェア・プログラムの実行の様子\n  一方，HDLで記述されたエンティティ/モジュールには，共通のプログラム・カウンタのような，複数の演算回路の動作を制御する仕組みはありません．(図3)．どのモジュールも常に存在し，独立して動作します．したがって，特定の入力を与えると出力を返すというよりも，入力されているデータに対して出力するデータを作り続けているというイメージになります．複数のモジュール間で制御が必要であれば自分で，そのように設計する必要があります．\n 図3: ハードウェアは常に存在し，演算回路の動作が制御されることはない(制御が必要なら自分で記述する必要がある)\n  2種類の基本処理方法 \u0026mdash; 同時処理文と順次処理文 繰り返しになりますが，ハードウェア・プログラミングでは，独立して動作するモジュールを扱う必要があります．すなわちハードウェアを記述するための言語では，独立して動作する同時並行的な処理を記述できる必要があります．とはいえ，実現したい処理によっては，条件分岐のような依存関係のある処理の記述が望まれます．これらの要求を満たすため，VHDLとVerilog HDLのどちらも，同時処理文と順次処理文と呼ばれる二種類の記述方式をサポートしています．具体的な記述方法は後で説明しますが，それぞれの考え方を頭に入れておいてください．\n同時処理文 同時処理文とは，周りの処理に依存せず独立して動作する処理です．複数の同時処理文は，ある特定の時点で一斉に処理されます．そのため，記述順や各処理文の間には，構文的な順序が存在せず，「ある時点」で入力された値に従って出力が生成されます．出力が確定するまでの時間は，物理的にデバイスの中を電気が流れる速さや信号遅延に依存します．\n順次処理文 順次処理文は，複数の処理同士に構文などによって順序が規定された処理です．たとえば，ソフトウェアには欠かせない分岐などの制御文の表現には順序が必要になります．\n使用できる変数 \u0026mdash; 数値と信号 プログラミング言語と同じようにHDLでも変数を利用できます．VHDLでもVerilog HDLでも，変数はすべて型を持ちます．ハードウェアとして，基本的な型は1本の信号線です．また，信号線を束ねた配列もサポートされます．このほかに，整数や自分で定義した型も利用できます．\n変数は，英数字からなる名前を付けることができます．変数名の先頭は英字または「_」で始める必要があり，末尾を「_」にしてはいけません．Verilog HDLでは，大文字と小文字は区別されます．\n演算の基本 \u0026mdash; 算術/論理減算，比較，代入 VHDLおよびVerilog HDLでは加減算や論理演算，比較などの演算子を利用することができます．ソフトウェア・プログラミングの場合は演算子を使って記述された処理はプロセッサに与える命令に変換されますが，HDLの場合は，その演算に相当するハードウェア・ロジックとしてLUTやFFなどの組み合わせに合成されます．FPGAの中には，小さなディジタルシグナルプロセッサや乗算器を持つものがあり，条件にうまく合致すると，それらが使用されます．\nHDLでもソフトウェア・プログラミング同様に，演算した結果を代入演算を利用して，ほかの(あるいは同じ)変数に代入することができます．HDLの代入には，ブロッキング代入とノンブロッキング代入の2種類があります．ブロッキング代入は，その時点で値を代入して次に進む代入です．一方，ノンブロッキング代入は，複数の代入文において，それらの代入の同時実行を規定します．Cなどで記述した単一スレッドのソフトウェア・プログラムの代入は，HDLでいうところのブロッキング代入に相当します．\n値の基本 \u0026mdash; \u0026lsquo;0\u0026rsquo;，\u0026rsquo;1\u0026rsquo;，\u0026rsquo;Z\u0026rsquo;，\u0026rsquo;X\u0026rsquo; ハードウェアの値は\u0026rsquo;0\u0026rsquo;と\u0026rsquo;1\u0026rsquo;の値をとります．加えて，ハードウェアにはハイ・インピーダンスという，「抵抗が無限大」を意味する状態が存在します．VHDLやVerilog HDLでは\u0026rsquo;Z\u0026rsquo;で表されます．値として「抵抗が無限大」というのは，少しわかりにくいかもしれません．物理的には，図4のようにスイッチを切った状態をイメージしてください．複数の信号が一つにまとめられるとき，\u0026rsquo;Z\u0026rsquo;は，「ほかの値に影響を与えない」ということを意味します．\n 図4: HDLではハイ・インピーダンスでスイッチオフを記述できる．\n  また，\u0026rsquo;0\u0026rsquo;でも\u0026rsquo;1\u0026rsquo;のどちらでもいい値として不定値という概念があります．これは，\u0026rsquo;X\u0026rsquo;と表現されます．\nソフトウェア・プログラミングでは，通常，\u0026rsquo;0\u0026rsquo;と\u0026rsquo;1\u0026rsquo;の2値をとる値をビットと呼びますが，\u0026rsquo;Z\u0026rsquo;と\u0026rsquo;X\u0026rsquo;も加えた4つの値をとる信号が便宜上ビットと呼ばれることが多くあります．\n文末には「;」を付ける VHDLもVerilog HDLも，演算処理や変数定義などの文の終わりには「;」(セミコロン)を付けます．ただし，両言語ともソフトウェアのプログラミング言語では少し首をかしげてしまうような，「;」を付けないケースが存在するので注意が必要です．\nVHDLの基本文法のルール VHDLの基本的な文法を説明します．\nコメント 多くのソフトウェア・プログラミング言語と同様に，VHDLでもソースコード中にコメントを書くことができます．VHDLでは，「 -- 」から行末までがコメントになります．\nモジュールの構成 図5に，VHDLで記述するモジュールの概要を示します．VHDLでは，対象とするモジュールを大きく entity と architecture に分けて記述します． entity には外部に接続される入出力ポートの宣言などの回路の外枠を， architecture には使用する関数の定義や処理内容など，回路の内部を定義します．\n 図5: VHDLのモジュール定義はentityとarchitectureから構成される\n  即値の表現方法 VHDLでは，ソース・コードの中に定数の値を記述できます(表1)．複数の信号線を束ねた値は，信号線の本数分だけ各信号に相当する値を並べて表現します(たとえば4bitなら \u0026quot;0000\u0026quot; など)．また，「 X\u0026quot;01\u0026quot;」と記述することで16進数で数を表記できます．よく用いられる代表的な定数表現には，表1のようなものがあります．\n表1. VHDLで記述できる定数の例\n   説明 値の例     1本の信号線がとる信号の値 '1'，'0' ，'Z'，'X'   複数の信号線がとる信号の値 \u0026quot;111\u0026quot;，\u0026quot;0100\u0026quot; ，X\u0026quot;10\u0026quot;   整数 32，8 ，1000   真偽値 true，false    型 VHDLの変数はすべて型を持ちます．たくさんの型が定義されており，また，独自の型も定義できます．よく使用される5つの型を表2に示します．基本的には，std_logic，std_logic_vectorはハードウェアの信号に相当する型，signedやunsignedは加減算などの算術演算ができる値を表現するために用いる型，一般的な数値を表現できるintegerです．\n   型名 説明     std_logic 1bitの信号線   std_logic_vector(n-1 downto 0) n-bitの信号線   unsigned(n-1 downto 0) n-bitの符号なしの算術演算可能な値   signed(n-1 downto 0) n-bitの符号ありの算術演算可能な値   integer n to m nからmまでの整数    VHDLで用いられる型の例\n1-bitの信号 std_logic は，VHDLの基本となる1bitの信号に相当する型です．'0'，'1'のほかに，ハイ・インピーダンスを示す'Z'，不定値を示す'X'を値としてとれます．これらの値は，ハードウェアにそのまま対応します．\nn-bitの信号 std_logic_vector(n downto 0)は，std_logicがn個並んだn-bitの信号線に相当する型です．n-bitのstd_logi_vector型」と呼びます．std_logic_vector型の変数aの中の要素を，a(3)，a(4 downto 2)などとして取り出せます．前者はstd_logic型，後者は3bitのstd_logic_vector型です．「downto」はstd_logicの並びに，MSBから降順で番号を付けることを意味します．つまり，std_logic_vector(n-1 downto 0)のビット列の場合，MSBがstd_logic_vector(n-1)で，LSBがstd_logic_vector(0)です．toを使うことで逆順に並べることもできます．その場合は，std_logic_vector(n to 0)のように書きます．\nモジュールの外枠の記述 \u0026mdash; entity entityは，モジュールの外枠に相当し，モジュールの名前と入出力の信号で定義されます．たとえば， 次の記述は，入力信号にpClkとpReset，出力信号にQを持つtestという名前のモジュールの外枠の定義に相当します．\n1 2 3 4 5 6 7  entity test is port ( pClk : in std_logic; Q : out std_logic; pReset : in std_logic -- 最後の一つの後には\u0026#34;;\u0026#34;をつけない ); end entity;   ポートを定義する ポートは，ハードウェア・モジュールの入出力です．entityの中のport( 〜 );の中に信号を方向と型を指定して定義します．信号の方向にはin(入力)とout(出力)，inout(入出力)の3種類があります．各ポートは「名前 : 方向 型」で定義されます．たとえば，\n1  pClk : in std_logic   という記述は，pClkという名前の型がstd_logicの入力ポート(in)の定義に相当します．同じ方向，型の複数のポート名は「,」で並べて定義することもできます．たとえば，\n1  pR, pG, pB : in std_logic   として，3つの入力信号pR，pG，pBをまとめて定義できます．\n定数を定義する entityの中にモジュールの中で使用する定数を定義できます．\n1 2 3 4 5 6 7 8 9 10 11  entity test is generic ( width : integer := 640; height : integer := 480 ); port ( pClk : in std_logic; Q : out std_logic; pReset : in std_logic ); end test;   ここでは，widthという名前で値が640のinteger型，すなわち整数の定数を定義しています．この定数は entity 内部，および内部処理を記述する architecture の中で使用できます．\n内部処理の記述 \u0026mdash; architecture VHDLでは， architecture にモジュールの処理内容を記述します．記述の基本的な流れは次の通りです．\n1 2 3 4 5  architecture RTL of test is (ここに変数の定義などを書く) begin (ここに処理内容を記述する) end RTL;   上記は， test という名前のモジュールの中身を記述するためのブロックです．\n変数の定義 1  signal 名前 : 型 := 初期値;   たとえば，10ビットの配列は下記のように定義します．\n1  signal counter : std_logic_vector(9 downto 0);   また， generic で定義した値である width を使用して，幅widthの std_logic_vector 型の信号を次のように定義できます．ここで「 width−1 」の値は合成時に決定されます．\n1  signal counter : std_logic_vector(width-1 downto 0);   演算子と演算 代表的な演算子を表3にまとめます．論理演算子を std_logic_vector 型に定義した場合は，対応する各ビットの値同士に論理演算を適用した結果を返します．たとえば，「 \u0026quot;10\u0026quot; and \u0026quot;11\u0026quot; 」は「 \u0026quot;10\u0026quot; 」になり，「 \u0026quot;10\u0026quot; or \u0026quot;11\u0026quot; 」は「 \u0026quot;11\u0026quot; 」になります．比較演算の結果は， true か false の真偽値になります．よくあるプログラミング言語に備わっている演算が備わっていることがわかります．ただし，表3の説明に(*1)をつけている，算術演算や数値の大小を比較する演算では unsigned 型， signed 型あるいは integer の変数や定数，あるいは数値に相当する即値にしか利用できません．\n   種類 演算子 説明     論理演算 a and b 論理積．aとbが '1' なら '1' ．さもなければ '0' ．    a or b 論理和．aとbのどちらか又は両方が '1' なら '1' ．さもなければ '0' ．    a xor b 排他的論理積．aとbの一方だけが '1' なら '1' ．さもなければ '0' ．    not a 否定．aが '0' なら '1' ． '1' なら'0'   比較演算 a = b aとbが等しい場合 true ．さもなければ false    a /= b aとbが等しくなければ場合 true ．さもなければ false    a \u0026gt; b aがbがより大きいなら true ．さもなければ false ．(*1)    a \u0026lt; b aとbがより小さいなら true ．さもなければ false ．(*1)    a \u0026gt;= b aとb以上なら true ．さもなければ false ．(*1)    a \u0026lt;= b aとb以下なら true ．さもなければ false ．(*1)   算術演算 a + b aとbの足し算 (*1)    a - b aとbの引き算 (*1)    a * b aとbの引き算 (*1)    a / b aとbの割り算 (*1)    a ** b aのb乗 (*1)   配列操作 a \u0026amp; b aとbをこの順に並べた信号線の束を作る    a(b) aのb番目の信号を取り出す    a(b downto c) aのb番目からc番目の信号線の束を取り出す    演算結果の代入 演算の結果は代入文でほかの(あるいは同じ)変数へ代入できます．代入にはブロッキング代入とノンブロッキング代入があります．\n1 2  := ブロッキング代入 \u0026lt;= ノンブロッキング代入   たとえば，\n1  Q \u0026lt;= counter(width-1);   という記述は， std_logic_vector 型の変数 counter の (width-1) 番目を取り出し， Q に代入するハードウェアの記述に相当します．VHDLでは， signal 変数には，初期化時以外でブロッキング代入を使用することはできません．\n型の変換 VHDLは型の制約が強い言語で．代入は同じ型の変数同士でしか認められません．また演算子も適用可能な型があらかじめ決められています．そのため，幅の違う std_logic_vector 同士で値を定義する場合には，ビット幅を削る/足すなどして同じ幅にしなければいけません．たとえば，aとbが，それぞれ幅16-bit，8-bitの std_logic_vector 型であれば，\n1 2  a \u0026lt;= \u0026#34;00000000\u0026#34; \u0026amp; b; -- 足りない8bitを8bitの0(=\u0026#34;00000000\u0026#34;)で埋めている b \u0026lt;= a(7 downto 0); -- aの下位8bitだけをbに代入している   などとする必要があります．\n型の変換には専用の関数を利用します．たとえば， std_logic_vector を unsigned 型あるいは signed 型に変換するためには，それぞれ unsigned 関数あるいは signed を用います．\n1  unsigned(c);   と記述すると std_logic_vector 型の変数 c を unsigned 型に変換できます．\n逆に， unsigned 型や singed 型の変数を std_logic_vector 型に変換する場合には， std_logic_vector 関数を用います．\n1  std_logic_vector(d);   と記述すると unsigned 型の変数 d を std_logic_vector 型に変換できます．\ninteger 型の変数を unsigned 型や signed 型に変換する場合には， to_unsigned あるいは to_signed を使います．たとえば， integer 型の変数 k をn-bitの unsigned 型に変換する場合は，2番目の引数にビット数 n を指定して，\n1  to_unsigned(k, n);   と記述します．\n一般に，VHDLでは， std_logic_vector 型の変数に対して算術演算は記述できません．そのため， std_logic_vector と定数の加減算や比較演算する場合には，一度 unsigned 型に変換して演算する必要があります．たとえば，幅nの std_logic_vector の変数counterに定数 1 を加算する場合には，次のように，一度 unsigned 型に変換して演算した後で std_logic_vector 型に戻す必要があります．\n1  counter \u0026lt;= std_logic_vector(unsigned(counter) + 1);   シフト演算 VHDLには，ソフトウェア・プログラミング言語で一般的なシフト演算子に相当する演算子がありません．VHDLでは配列操作の演算を用いて似たような操作ができます．たとえば，幅n-bitの std_logic_vector 型の変数counterを右に1つシフトしたい場合には，次のように記述します．\n1  counter \u0026lt;= \u0026#39;0\u0026#39; \u0026amp; counter(n-1 downto 1);   左に2つシフトしたい場合には，\n1  counter \u0026lt;= counter(n-3 downto 0) \u0026amp; \u0026#34;00\u0026#34;;   となります．\n同時処理文 1 2  c \u0026lt;= a and b; e \u0026lt;= c and d;   と書いても，\n1 2  e \u0026lt;= c and d; c \u0026lt;= a and b;   と書いても，同じように図6の回路が合成されます．\n 図6: 同時処理文は，記述順によらず解析・合成される\n  順次処理文 \u0026mdash; process文 順次処理文では記述された順序に従って意味が解析され，回路が合成されます．そのため，複雑な制御構文を使用できます．VHDLでは， architecture 中で process を使って順次処理文を記述するためのブロックを作ることができます． process 文の基本的な構文を次に示します．\n1 2 3 4 5  process(a, b) begin c \u0026lt;= a and b; d \u0026lt;= a or b; end process;   ここで， process() の「 () 」内の変数のリストをセンシティビティ・リストといいます．このリストに列挙した変数の信号が変化すると process の中の回路が動作し出力値が変更されます．ノンブロッキング代入は，process内の記述が順に解釈された後で，同時に信号が確定します．このprocess文は，図7のような回路を生成します．あくまで文が順に解釈されるだけで，順に処理される回路が生成できるわけではない，ことに注意する必要があります．\n 図7: 順次処理文中の複数のノンブロッキング文は順に解釈され，最後に値が同時に確定する\n  process 文の中にでてくる入力変数(式の右辺にでてくる変数)がすべてセンシティビティ・リストに列挙されている場合，入力が変化する度に回路が動作し，出力変数(式の左辺)の値が変更されます．つまり，その process 文から生成される回路では，何も状態を保存する必要がありません．そのため，図8のような記憶素子を必要としない組み合わせ回路として構成されます．\nセンシティビティ・リストにない変数が右辺に使われる．次のようなprocess文を考えてみます．\n1 2 3 4 5  process(a) begin c \u0026lt;= a and b; d \u0026lt;= a or b; end process;   ここでは，センシティビティ・リストに「b」がなく，入力変数が全部列挙されていません．この回路では，bの値が変化しても出力先であるcとdの値は変化しません．つまり，図8のように，入力であるaとbを出力のcとdに直接接続することができず，cとdの値を保存する機構，記憶素子が必要となり，組み合わせ回路として合成されません．「同じように記述したつもりでも違う回路になるかもしれない」ということを覚えておいてください．\nVHDLの process 文では，ブロッキング代入可能な variable 変数を利用できます． variable 変数は，順次処理文において便宜的に一時的な値を格納しておくためのものです．長く複雑な演算を行う場合に，ソース・コードの見通しをよくできます． たとえば，次のように使います．\n1 2 3 4 5 6 7 8  process(a,b) variable tmp0 : std_logic; variable tmp1 : std_logic; begin tmp0 := a and b; tmp1 := a or b; c \u0026lt;= tmp0 xor tmp1; end process;   ここでは，tmp0とtmp1がvariable変数です．ブロッキング代入における演算の結果がそれぞれ代入されています．ブロッキング代入のため，合成ツールがこの構文に出会ったところで，tmp0の値は(a and b)に，tmp1の値は(a or b)にすぐさま置き換わります．つまり，これは， c \u0026lt;= (a and b) xor (a or b) という回路として合成されます．\n制御構文 VHDLでは，まるでソフトウェアを記述するように，条件分岐やCの switch 文のような制御構文が使えます．多くの制御構文は， process 文の中でのみ使用ができます．代表的なものを紹介します．\nwhen 〜 else 同時処理文中で記述可能な制御構文です．条件に従って出力する値を選択できます．下記は， a と b の値が等しい場合は X を，等しくない場合には Y を c に代入する例です．\n1  c \u0026lt;= X when a = b else Y;   制御構文というよりは，Cなどで， c = (a==b) ? X : Y と書く3項演算子に近いイメージですね．\nif 〜 then 〜 elsif 〜 else 〜 end if \u0026mdash; 条件分岐構文 process 文の中でのみ使用できる条件分岐構文です． 次は， a より b が大きい場合は処理文Xが，それ以外の場合は処理文Yが有効になります．また，処理文の中で if をネスト(入れ子に)することもできます．\n1 2 3 4 5  if a \u0026gt; b then 処理文X else 処理文Y end if;   また， elsif を使うと， else 節に重ねて次の条件を記述できます．\n1 2 3 4 5 6 7  if a \u0026gt; b then 処理文X elsif a \u0026lt; b then 処理文Y else 処理文Z end if;   VHDLでは，単に信号の値に対する条件だけでなく，信号が変化するタイミングを使用した条件式が書けます． たとえば，変数clkが変化するタイミングはclk\u0026rsquo;eventと書きますので，これを使って，\n1 2 3  if clk\u0026#39;event and clk = \u0026#39;1\u0026#39; then 処理文 end if;   のような条件文を作ることができます．この例では，「clkが変化し，かつ，clkが1」のときに処理文が実行されます．ハードウェアとしては，clk信号が立ち上がった瞬間に相当します．それ意外のタイミングでは，処理文は動作せず，値が保存し続けられます．これは，決まったタイミングで処理を実行する順序同期回路の設計に欠かせない表現です．\nただし，2018年現在では，多くの場合，直接「クロックの立ち上がり」を表す， rising_edge という関数を使って，\n1 2 3  if rising_edge(clk) then 処理文 end if;   という記述が好まれます．\ncase〜when \u0026mdash; 選択 CやJavaでいうところの switch 構文です．次に示す例では， std_logic_vector 型の変数aの値によって処理文X，Y，Zのどれかが実行されます．0，1，2という整数と一致させられるように， to_integer を使って a を integer 型に変換しています．ここで，VHDLの case ~ when 構文では，どれかの when に必ず該当するように記述する必要があることに注意しなければいけません．すべての when を列挙する代わりに「 others 」で残りすべての条件にマッチする場合を表現できます．\n1 2 3 4 5 6 7 8 9 10  case to_integer(unsigned(a)) when 0 =\u0026gt; 処理文X when 1 =\u0026gt; 処理文Y when 2 =\u0026gt; 処理文Z when others =\u0026gt; --そのほかのすべての場合 処理文W end case;   for 〜 in 〜 loop \u0026mdash; 繰り返し VHDLにおける繰り返し処理は，単に似たような処理を繰り返して記述する代わりに簡単に書けるようにするための構文です．実際には，合成時に繰り返し回数分のハードウェア回路が生成されます．\nたとえば，下記に示す処理は，5bitの std_logic_vector 型の変数 a と std_logic 型の変数 b が定義されているときに，\n1 2 3 4 5 6 7 8 9 10  process variable i : integer := 0; variable tmp : std_logic; begin tmp := \u0026#39;0\u0026#39; for i in 0 to 4 loop tmp := tmp or a(i); end loop; b \u0026lt;= tmp end process;   という記述は，次のような記述を簡単に記述したことに相当します．\n1 2 3 4 5 6 7 8 9 10 11 12  process variable i : integer := 0; variable tmp : std_logic; begin tmp := \u0026#39;0\u0026#39; tmp := tmp or a(0); tmp := tmp or a(1); tmp := tmp or a(2); tmp := tmp or a(3); tmp := tmp or a(4); b \u0026lt;= tmp end process;   作成した回路が動作する時ではなく，回路を作成する時点で繰り返し処理が解釈されることに注意してください．\n組み合わせ回路のサブモジュール VHDLでは，複雑な組み合わせ回路を生成するために， function というサブモジュールを記述できます． function は順次処理文で， if や case などの条件文を記述できますが，ノンブロッキング代入を用いることはできません． function は，次のように定義します．\n1 2 3 4 5 6 7 8 9 10 11  function f (a : in std_logic; b : in std_logic) return std_logic is variable Q : std_logic; begin if (a = b) then Q := \u0026#39;1\u0026#39;; else Q := \u0026#39;0\u0026#39;; end if; return Q; end f;   これは，1ビットの変数である a と b を入力とする名前 f の function の定義です．入力された二つの値が等しいときに1を，異なるときに0を出力する関数です．\n呼び出し側では，\n1  x \u0026lt;= f(x, y)   などとします．xとyは，関数呼び出しに対する実引き数になります．\nまた次のように，配列型の変数を入力あるいは出力する関数を定義できます．\n1 2 3 4 5 6 7 8  function g (x : in std_logic_vector(1 downto 0)) return std_logic_vector is variable Q : std_logic_vector(1 downto 0); begin Q(0) := x(1); Q(1) := x(0); return Q; end g;   Cなどのソフトウェア・プログラミング言語の関数とは違い，関数の計算が終了するまで呼び出し側の処理が待たされるということはありません． 複雑な組み合わせ回路を見通しよく記述できる書き方です．\nおまじない 実は，ここまで説明してきた std_logic などを利用するには，これらの機能が実装されたライブラリなどを読み込む必要があります． VHDLソース・コードの先頭に以下を記述します．\n1 2 3  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all;   Verilog HDLの基本文法のルール Verilog HDLの基本的な文法を説明します．\nコメント 多くのソフトウェア・プログラミング言語と同様に，Verilog HDLでもソースコード中にコメントを書くことができます．Verilog HDLでは，C++と同じように /* 〜 */ で囲んだ部分や // から行末までがコメントになります．\nモジュールの構成 図9に，Verlog HDLで記述するモジュールの概要を示します．VHDLでは，外枠の定義 entity と内部の定義 architecture が区別されていたのに対し，Verilog HDLにはそのような区別はありません． module の中に，外部と接続されるポートや関数内で使用する変数の宣言，処理内容などを記述します．\n 図9: Verilog HDLのモジュール定義の概要\n  値の表現方法 Verilog HDLでは，必要とするビット幅( w )と基数( f )を付けて「 w'f値 」という形式で即値を記述します．ビット幅は10進数で記述します．ビット幅と基数を省略すると10進数，32bitの値になります．表\\ref{tbl:verilog_value}に，基数と記号と表現される数の関係を示します．\n   基数(w) 基数記号(f) 例 10進数表記での値     2 b 8'b10 2   10 d 10'd10 10     10 10   16 h 8'h10 16    型 \u0026mdash; ネット型変数とレジスタ変数 Verilog HDLの変数には，ネット変数とレジスタ変数があります．どちらも1bitの信号に相当する変数と，複数bitの信号を束にした配列変数を作れます．ネット変数とレジスタ変数の違いは，ハードウェアに則したワイヤ(配線)とレジスタ(記憶素子)を想起させるものですが，後で説明するように使える場面と使い方に違いがあります．表\\ref{tbl:verilog_types}に，変数の型を示します．\n   型名 説明     wire 1-bitのネット変数   wire[n-1:0] n-bitのネット変数   reg n-bitのレジスタ変数   reg[n-1:0] n-bitのレジスタ変数    ネット変数 \u0026mdash; wire モジュールやゲート同士を接続する配線に名前を付けた変数が，ネット変数 wire です．ネット変数自身は値を保持することはできず，他から代入された値を次に伝達する役目を担う変数です．ハードウェアの配線そのものに相当します．\nレジスタ変数 \u0026mdash; reg レジスタ変数 reg は，値を保存する記憶素子になることができ，変数自身が値を保持できます．組み合わせ回路も順序回路も構成できます．\n配列変数 配列変数 wire[n-1:0] ， reg[n-1:0] は，それぞれ wire あるいは reg からなるn-bitの変数に相当します．幅 n のネット変数\n1 2  wire[n-1:0] a; reg[n-1:0] b;    と定義された変数aの各要素をa[0]，a[2:0]などとして取り出すことができます．前者はwire，後者はwire[2:0]の変数です．\nモジュールの外枠の記述 \u0026mdash; module Verilog HDLでは， module でハードウェア・モジュールの外枠を定義します．モジュールの名前と入出力の信号名を定義します．\n1  module test(pClk, pReset, Q);    この文では， pClk ， pReset ， Q という名前の入出力信号を持つ test という名前のモジュールを定義しています． Verilog HDLでは，この module 文から\n1  endmodule    というキーワードまでがモジュールの定義に相当します． moduleの末尾には‘;’(セミコロン)が必要ですが，endmoduleには付けないことに注意してください． ポート名だけを列挙する場合には，後で，各ポートの入出力方向と幅を定義する必要があります．\n少し前のVerilog-95\n1  module test(pClk, pReset, Q);    ポートの定義 ポートとは，モジュールの入出力信号のことです．ポートの名前は，モジュール名に続く()の中に記述します． それぞれのポートの入出力は，モジュールの中で，「方向 型 変数名;」で宣言します． 方向には， input (入力)と output (出力)， inout (入出力)の3種類があります． module 文の () 内に与えた信号線の型と入出力方向はモジュールの内部で定義します． たとえば， pClk と pReset が1bitの入力， Q が1bitの出力信号であれば，\n1 2 3 4 5 6 7 8  module test(pClk, pReset, Q); input wire pClk; input wire pReset; output wire Q; // 以降，モジュールの内部処理を記述する  endmodule    と記述されます．\n通常Verilog HDLでは，1bitのwire変数は定義せずに使えるため，wireが省略されることがあります． もちろん，n-bitのポートを定義することもでます．Qが幅n-bitの出力ポートであれば，\n1  output wire[n-1:0] Q    と書けます．\nVerilog-2001以降をサポートする処理系の場合には，VHDLのように信号名の定義に型と変数を付けることができます．\n1 2 3 4 5 6 7 8 9  module test( input wire pClk, input wire pReset, output wire Q ); // 以降，モジュールの内部処理を記述する  endmodule    と記述できます．\n定数を定義する module宣言の後に，各モジュール内で有効な定数をparameter文で定義できます．\n1 2 3  module test(pClk, pReset, Q); parameter width = 640; parameter height = 480;    上記に示したモジュールtestの中では，widthを640という値として利用できます．\n内部処理の記述 ポートの宣言に引き続いて，内部で使用する変数の宣言および処理本体を記述します．\n変数の定義 処理に必要な変数をあらかじめ定義しておく必要があります．変数は，ネット接続型あるいはレジスタ型の型を伴って定義されます．\n1 2  wire a; reg[15:0] b;    これは，ネット変数 a と幅16ビットのレジスタ変数 b を定義しています．\nまた， parameter で定義した定数 width を用いて，次のように変数を定義することもできます．\n1  reg[width-1:0] c;    演算子と演算 代表的な演算子を表\\ref{tbl:verilog_operator}にまとめました． 論理演算における真と偽は，ネット変数やレジスタ変数の場合は '1' と '0' に対応します． n-bitの配列変数 wire[n-1:0] あるいは reg[n-1:0] の場合には，配列中に一つでも '1' である要素があれば真，さもなければ偽として判定されます．ビット論理演算子を配列変数に適用する場合は，対応する各要素同士について演算が適用されます．\n   種類 演算子 説明     論理演算 a \u0026amp;\u0026amp; b 論理積．aとbが共に真なら真．さもなければ偽．    `a     !a 否定．aが真なら偽．偽なら真   ビット論理演算 a \u0026amp; b 論理積．aとbが共に\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;1\u0026rsquo;．さもなければ\u0026rsquo;0\u0026rsquo;．    `a b`    a ^ b 排他的論理和．aとbのどちらか一方が\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;1\u0026rsquo;．さもなければ\u0026rsquo;0\u0026rsquo;．    ~a 論理否定．aが\u0026rsquo;1\u0026rsquo;なら\u0026rsquo;0\u0026rsquo;．さもなければ\u0026rsquo;1\u0026rsquo;．   比較演算 a == b aとbが等しい場合 true ．さもなければ false    a != b aとbが等しくなければ場合 true ．さもなければ false    a \u0026gt; b aがbがより大きいなら true ．さもなければ false ．(*1)    a \u0026lt; b aとbがより小さいなら true ．さもなければ false ．(*1)    a \u0026gt;= b aとb以上なら true ．さもなければ false ．(*1)    a \u0026lt;= b aとb以下なら true ．さもなければ false ．(*1)   算術演算 a + b aとbの足し算    a - b aとbの引き算    a * b aとbの引き算    a / b aとbの割り算    a % b aとbの割り算の余り   シフト演算 a \u0026gt;\u0026gt; b aとbビット，右にシフト    a \u0026lt;\u0026lt; b aをbビット，左にシフト   条件演算 a ? b : c aが真の時b，偽のときc   配列操作 {a,b,c} aとbとcをこの順に並べた信号線の束を作る    a[b] aのb番目の信号を取り出す    a[b:c] aのb番目からc番目の信号線の束を取り出す    Verilog HDLで用いられる演算の例\n演算結果の代入 演算の結果をネット変数あるいはレジスタ変数に代入できます． ネット型変数への代入には assign 命令を使用して，下記のように記述します．\n1  assign c = a \u0026amp; b;    これは，ハードウェア的には，演算の結果を信号線に接続することに相当します． ネット変数の代入は後述の同時処理文としてしか記述できません．\n一方，レジスタ変数への代入では，ブロッキング代入とノンブロッキング代入の両方が使えます． Verilog HDLでは，それぞれ下記のように記述します．\n1 2  = // ブロッキング代入 \u0026lt;= // ノンブロッキング代入    たとえば， a + b の演算結果をノンブロッキング代入する場合には，\n1  c \u0026lt;= a + b;    のように記述します． レジスタ変数への値の代入は，ブロッキング代入とノンブロッキング代入のどちらも， 後で説明する順次処理文内でのみ使えます．\n型の変換 VHDLが型に対して厳格であるのに対して，Verilog HDLでは暗黙のうちに型が変換されます． 意識せずに異なるビット幅の変数を演算，代入できます．\nシフト演算 VHDLと異なり，Verilog HDLにはシフト演算子がありますが，シフト演算は大きな回路になってしまいます． 定数分のシフトを行いたい場合は，配列の結合演算を用いて実装する方が小さな回路として実現できます． たとえば，配列変数reg[n-1:0]のcounterを右に1bitシフトしたい場合は，下記のようになります．\n1  {1\u0026#39;b0, counter[n-1:1]};    また，左に2つシフトしたい場合には，\n1  {counter［n-3:0］, 2\u0026#39;b00};    のように記述します．\n同時処理文 ネット型変数の演算結果の代入は，同時処理文を記述します． 記述されたすべての同時処理文は，合成ツールにより同時に解析され，回路として合成されます． つまり，記述された内容は，その順序に依存しません．たとえば，\n1 2  assign c = a \u0026amp; b; assign e = c \u0026amp; d;    という同時処理文の列も，\n1 2  assign e = c \u0026amp; d; assign c = a \u0026amp; b;    の列も，同じように図8の回路が合成されます．\n順次処理文〜always文 always 文は，順次処理文を記述するためのブロックを作るものです．順次処理文では，記述された順序に従って意味が解析され， 回路が合成されます．そのため，複雑な制御構文を使用できます． 基本的な構文を下記に示します．変数 c ， d は reg 変数です．\n1 2 3 4  always @(a, b) begin c \u0026lt;= a \u0026amp; b; d \u0026lt;= a | b; end    ここで， always @() の「 () 」内の変数のリストをセンシティビティ・リストといいます． このリストに列挙した変数が変化すると，プロセス文の中の回路の値が変更されます． ノンブロッキング代入は，always内の処理の解釈がすべて完了したタイミングで，同時更新されることに注意してください． このalways文は，図10のような回路になります．\nalways 文の中にある入力変数(式の右辺にでてくる変数)がすべてセンシティビティ・リストに列挙されている場合， 入力が変化する度に回路が動作し，出力変数(式の左辺)の値が変更されます． つまり，その always 文は，何も状態を保存する必要がありません． そのため，記憶素子を必要としない組み合わせ回路として構成されます． ここで，入力に対して常に出力が生成されない場合とは，条件分岐などによって， 入力信号の値によって値の代入が発生しない出力信号がある場合です．\n次のような always 文を考えてみます．\n1 2 3 4  always @(a) begin c \u0026lt;= a \u0026amp; b; d \u0026lt;= a | b; end    ここでは，センシティビティ・リストに「 b 」がなく，入力変数が全部列挙されていません． この回路では，bの値が変化しても出力先であるcとdの値は変化しません． つまり，図10のように，入力であるaとbを出力のcとdに直接接続することができず， c と d の値を保存する機構，記憶素子が必要となり，組み合わせ回路としては合成されません． 「同じように記述したつもりでも違う回路になるかもしれない」ということを覚えておいてください．\nalways の中では， reg 変数にブロッキング代入することもできます． ブロッキング代入では， always 中のほかの代入に関係なく，その時点で代入が発生し値が置き換わります． たとえば，次のような always 文を考えます．ここで， tmp0 ， tmp1 ， c はすべて reg 変数とします．\n1 2 3 4 5  always @(a,b) begin tmp0 = a \u0026amp; b; tmp1 = a | b; c \u0026lt;= tmp0 ^ tmp1; end    この場合， tmp0 と tmp1 ともに，ブロッキング代入で演算の結果が代入されています． ブロッキング代入なので，合成ツールがこの構文に出会ったところで， tmp0 は (a \u0026amp; b) に， tmp1 は (a \\ b)|にすぐさま置き換わます．つまり，これは単に c \u0026lt;= (a \u0026amp; b) ^ (a \\ b)|という回路に合成されます．\nセンシティビティ・リストには， @(a and b) という条件式が記述できます． これはaとbのどちらかが変化した場合ではなく， (a and b) が変化した場合に always の中の処理を実行できるようにします． 条件式には，信号の立ち上がり，あるいは立ち下がり条件を使用することもできます． 立ち上がりは「posedge」，立ち下がりは「negedge」というキーワードを使います．\n1 2 3  alwasy @(posedge clk) begin 処理文 end    これは，「clkの立ち上がり」のときに処理文が実行されることを意味します． ハードウェア的には，clk信号が立ち上がった瞬間に相当し，それ意外のタイミングでは，処理文は動作せず，値が保存し続けられます． これは，決まったタイミングで処理を実行する順序同期回路の設計に欠かせない表現です．\n制御構文 ソフトウェア・プログミングのように，条件分岐のifやCでいう switch 構文のような制御構文が使えます． 多くの制御構文は， always 文の中でのみ使用することができます．代表的なものを次に説明します．\nif 〜 begin 〜 end else begin 〜 end \u0026mdash; 条件分岐構文 always 文の中でのみ使用できる条件分岐構文です． 次に示す例では， a が b より大きければ処理文 X が，それ以外の場合は処理文 Y が実行されます． また，処理文の中で，ifをネスト(入れ子)にすることもできます．\n1 2 3 4 5  if (a \u0026gt; b) begin 処理文X end else begin 処理文Y end    case \u0026mdash; 選択 CやJavaでいうところのswitch構文です． 次に示す例では，変数 a の値によって処理文X，Y，Zに分岐しています． case 構文では，どれかのケースに該当するように記述しましょう． もちろん，すべての条件を列挙してもよいのですが，「 default 」でどんな値にもマッチする場合を記述できます．\n1 2 3 4 5 6 7 8 9 10  case(a) 0 : 処理文X 1 : 処理文Y 2 : 処理文Z default : 処理文W endcase    繰り返し構文 \u0026mdash; for Verilog HDLにおける繰り返し処理は，単に似たような処理を繰り返して記述する代わりに簡単に書けるようにするための構文です． 実際には，繰り返し回数分のハードウェア回路が生成されます． たとえば，下記に示す処理ですが，\n1 2 3 4 5  tmp = 1\u0026#39;b0; for (i = 0; i \u0026lt; 5; i = i + 1) begin tmp = tmp | a[i]; end b \u0026lt;= tmp;    これは，次のような代入文を記述することに相当します．\n1 2 3 4 5 6 7  tmp = 1\u0026#39;b0; tmp = tmp | a[0]; tmp = tmp | a[1]; tmp = tmp | a[2]; tmp = tmp | a[3]; tmp = tmp | a[4]; b \u0026lt;= tmp;    組み合わせ回路のサブモジュール Verilog HDLでは，複雑な組み合わせ回路を生成するために， function というサブモジュールを記述できます． function は順次処理文で， if や case などの条件文を記述できますが， ノンブロッキング代入を用いることはできません． function は，次のように定義します．\n1 2 3 4 5 6 7 8 9 10 11  function f; input a; input b; begin if(a == b) begin f = 1\u0026#39;b1; end else begin f = 1\u0026#39;b0; end end endfunction    これは，1ビットのネット型信号である a と b を入力とする名前 f の function の定義です． function の中で f に値を代入すると，関数の返り値としてセットされます． この例は，入力された二つの値が等しいときに\u0026rsquo;1\u0026rsquo;を，異なるときに\u0026rsquo;0\u0026rsquo;を出力する関数です．\n呼び出し側では，\n1  assign x = f(x, y)    または，always文で\n1  x \u0026lt;= f(x, y)    などとして呼び出せます．ここで，xとyは，関数呼び出しに対する実引数になります．\nまた，次のように，配列型の変数を入力あるいは出力する関数を定義できます．\n1 2 3 4 5 6 7  function [1:0] g; input [1:0] x; begin g[0] = x[1]; g[1] = x[0]; end endfunction    ここで定義した function は，Cの関数とは違い，関数の計算が終了するまで呼び出し側の処理が待たされるような制御を伴うことはなく， 複雑な組み合わせ回路を見通し良く記述するための書き方です．\nまとめ ハードウェア記述言語であるVHDLとVerilog HDLの基本について説明しました． どちらも一般のソフトウェア・プログラミング言語ではなじみの薄い，\n ノンブロッキング代入とブロッキング代入 同時処理文や順次処理文  といった，ハードウェアを設計するための特有の特徴をもっています． とはいえ，分岐構文などを使うと，ハードウェアで実装したい処理をソフトウェア的に設計できます．\n今回は，基本的な文法の説明をかけあしで紹介しました． ソフトウェア・プログラミングを習得する際にはある程度，文法を覚えたあとは， 他人の書いたコードをたくさん読むことで，言語をスムーズに習得できます． ハードウェアを設計するためのHDLプログラミングでも同じです． たとえば，OpenCores.orgには，さまざまなHDLコードが投稿されており， また，米国Sun Microsystems社からは，SPARCプロセッサのHDLコードが公開されています． 習うより慣れろで，どんどん読み書きしてみましょう．\n参考文献  Douglas L.Perry(著)，メンター・グラフィックス・ジャパン株式会社(翻訳)；VHDL(Ascii software science—Language)，1996年10月，アスキー． Bhasker(著)，デザインウェーブ企画室(翻訳)；VHDL言語入門—ハードウェア記述言語によるロジック設計マスタリング(C\u0026amp;E TUTORIAL)，1995年7月，CQ出版社． 長谷川 裕恭；VHDLによるハードウェア設計入門—言語入力によるロジック回路設計手法を身につけよう，2004年4月，CQ出版社． 小林 優；入門Verilog HDL記述—ハードウェア記述言語の速習\u0026amp;実践 改訂，2004年5月，CQ出版社． 井倉 将実；FPGAボードで学ぶVerilog HDL，2007年2月，CQ出版社．  "});index.add({'id':4,'href':'/learning_fpga/docs/book01/quickstart/','title':"クイックスタート",'content':" FPGA開発におけるHello World Lチカ を通して，開発の手順に慣れよう\nはじめに この章では，FPGA開発におけるHello World，すなわち最初に試してみるサンプルとして Lチカ を題材に，開発の手順に慣れてみましょう． Lチカ とは，「LEDをチカチカさせる」の略です．\n単にLEDとチカチカさせるだけ，なのですが，開発の手順を身につけるには十分です．また，実際多くの信号制御は何かしらの規則にしたがって信号をON/OFFしていることですから，すべての信号制御はLチカの応用にあるとも言えます．簡単ですが大事ですよ．\n実習 プロジェクトの用意  図1: VivadoのFileメニューから，New Project\u0026hellip;を選択する\n   図2: プロジェクト作成ダイアログが開くので，Next\u0026gt;で次へ\n  プロジェクト名と格納先を決めます．ここでは，ホームディレクトリの下のVivadoというフォルダの下にプロジェクトを格納することとし，名前をproject_1としています．\n 図3: プロジェクト名と格納先を決めます\n   図4: プロジェクトタイプの指定です．RTLプロジェクトを指定します\n   図5: すでにソースコードがある場合にはここで追加できます．今回はないのでNext\u0026gt;で，そのまま次へ\n   図6: すでに制約ファイルがある場合にはここで追加できます．今回はないのでNext\u0026gt;で，そのまま次へ\n   図7: ターゲットとするFPGAの選択画面です．BoardタブをクリックしZybo Z7-20を選択してNext\u0026gt;で次へ\n   図8: 確認画面です．Finishをクリックするとプロジェクトの作成は完了です\n   図9: プロジェクト作成には少し時間がかかります\n  これでプロジェクトの完成です．Product FamilyがZynq-7000に，Project Summaryの表示を見ると，Project partがZybo Z7-20と，Z7-20向けのプロジェクトができていることがわかります．\n 図10: プロジェクトができあがりました．\n  ファイルの作成 作成したプロジェクトで，LEDをチカチカさせるためのデザインを追加していきます．ここではVivadoのウィザードを使ってデザインファイルを用意する方法ですすめていきます．\n 図11: SourcesのDesign Sourceの上で右クリックし，Add Sources\u0026hellip;を選択する\n   図12: ファイル追加ダイアログが開く\n   図13: 2番目のAdd or create design sources\u0026hellip;にチェックをいれてNext\u0026gt;をクリック\n   図14: ここで新しくファイルを作るので，Create Fileをクリック\n   図15: 使用言語とモジュール名を決めます．ここではVHDLを使うこととし，名前をtopと決めてOKをクリック\n   図16: 作成するファイルがリストに登録されたので，Finishをクリックします\n   図17: 新たに作成したtopモジュールのポートなどを定義することができます．あとで自分で書いてもいいのですが，入力ポートのclkと出力ポートのledを追加しましょう．OKをクリックします\n   図18: 作成したtopモジュールがプロジェクトに組み込まれました\n   図19: 組み込まれたtopをダブルクリックするとファイルを編集することができます\n  デザインの修正 ウィザードで作成したtopモジュールは雛形でしかないので，このままでは，もちろん所望の動作はしません．次の内容で書き変えてください．スペースの都合上，作成されたコメントは取り除いています．ファイルを編集するときには気をつけてください．また，リスト中のコメントは説明上のものですので，実際には入力する必要はありません．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  library IEEE; use IEEE.STD_LOGIC_1164.ALL; use ieee.numeric_std.all; -- 追加する．数値演算に必要(1)． entity top is Port ( clk : in STD_LOGIC; led : out STD_LOGIC); -- このPortはウィザードで作成された end top; architecture Behavioral of top is -- 次の行を追加．カウンタ変数の定義(2)． signal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); begin -- 追加，ここから(3) led \u0026lt;= std_logic(counter(23)); -- カウンタの23bit目をledに接続 process(clk) -- クロックの変化で動作するプロセス begin if rising_edge(clk) then -- クロックの立ち上がりであれば counter \u0026lt;= counter + 1; -- カウンタをインクリメント end if; end process; -- 追加，ここまで end Behavioral;   追加箇所は多くないので，少し詳しくみてみましょう．\n追加箇所(1) 数値演算に必要なライブラリ，今回の場合でいうと`+''演算を利用するためにuse ieee.numeric_std.all` という前置きをしています．\n追加箇所(2) LEDチカチカの，`チカチカ''というタイミングを制御するためのカウンタ変数を定義です．+演算を利用したいのでunsigned` 型で定義しています．\n追加箇所(3) いわば処理の本体です．一行目の代入文は，定義したcounter変数の23bit目を出力ポートであるledに接続することを意味しています． unsigned の1bitですので std_logic に型変換しています．次のprocess文では，clkが立ち上がることにcounterに1を足すことを意味しています．すなわち，(3)で追加した部分では，clkの立ち上がり8M回毎にledの\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;が反転する回路を定義していることになります．\nまずは合成してみる ファイルの編集がおわったら合成してみましょう．といっても，左サイドにあるFlow Navigatorの中にあるRun Synthesisをクリックするだけです．\n 図20: Run Synthesisをクリックすると合成開始ダイアログが開く．OKをクリックして合成を開始\n   図21: 合成中は，Running Synth_designの横に，ぐるぐるアニメーションが表示される\n   図22: 合成が完了した\n  I/Oの設定 合成が完了したことでデザインがVivadoに受け付けられることが確認できました．しかし，これでそのままFPGAでデザインが動くわけではありません．I/Oピンの設定をしていないからです．HDLのデザイン上は，入力ポートclkと出力ポートのledを定義しましたが，Vivadoは，このポートをFPGAのどのピンに割り当てていいか分かりません．FPGAを使った開発では人手でこの割り当てを決める必要があります．\nピンの割当ては合成結果を下敷にGUIで行なうことができます．まずは，合成結果を表示します．\n 図23: 合成後のダイアログで，``Open Synthesized Design\u0026rdquo;を選択し，OKをクリックする\n  もし，うっかり合成後のダイアログを閉じてしまったり，ピン配置を指定しないまま次のステップにすすんでしまった場合には，Flow Navigatorの中にあるOpen Synthesized Designをクリックしましょう．\n合成結果が表示できたら，LayoutのI/O PlanningをクリックしてI/O設定用のモードに変更します．\n 図24: LayoutのI/O PlanningをクリックしてI/O設定用のモードに変更\n  画面下のI/O割当て表でピン配置を決定します．clkとledのPackage pinを，それぞれ，K17とM14に決め，どちらもI/O stdをLVCMOS33を選択します．\n 図25: I/Oのピン割り当てを決める\n  合成・配置配線 ピン配置がおわったので，FPGA向けの書き込みファイルを作成します．Flow Navigatorの中にあるGenerate bitstreamをクリックするだけです．\n 図26: Flow Navigatorの中にあるGenerate bitstreamをクリックする．必要な合成・配置配線は一気通貫に実行される \\label{fig:file_save_dialog}\n  制約ファイルの保存 おそらく先のピン配置の変更が保存されていないので，図\\ref{fig:file_save_dialog}のダイアログが開くことでしょう．もちろん保存してください．\n 図27: ピン配置の変更が保存されてないために表示されるダイアログ．Saveをクリック． \\label{fig:file_save_dialog}\n   図28: ファイル保存すると合成の結果が無効になるよという警告．OKで閉じる．\n  制約ファイルの指定(最初だけ) はじめは，保存先のファイルが用意されていないので，図\\ref{fig:xdc_config}のダイアログが開きます．ここでは，HDLモジュールと同じ名前のtopというファイル名にします．なお，拡張子はxdcで自動的に付与されます．\n 図29: ピン配置を保存するファイルの作成を促すダイアログ．topという名前にしてOKをクリック \\label{fig:xdc_config}\n  合成・配置配線の開始 指定したピン配置の設定によって合成からやりなおしになります．``Yes\u0026rdquo;をクリックしてフローをすすめます．\n 図30: 合成からやりなおし\n   図31: 合成開始ダイアログ．OKで合成を開始．\n   図32: 合成が無事に完了した．メインウインドウにCompleteという文字と緑のチェックマークがついている \\label{fig:completed}\n  配置配線結果の確認 配置配線後，どのようにFPGA上に回路が配置されたかを確認することができます．今回は指定していませんが，動作クロックの指定を行った場合などには，正しくクロックの指定ができているか，その指定にあった回路ができているか，を確認する必要があります．\n今回は，まず雰囲気だけみてみましょう．合成後の図\\ref{fig:completed}のダイアログで，Open Implementation DesignにチェックをいれてOKをクリックするか，Navigator FlowでOpen Implemnetation Designをクリックします．\n 図33: 配置配線結果を開いてみたところ．右側の水色部分が使用しているハードウェアリソース\n   図34: 接続パスを表示し，拡大してみたところ\n  実機での動作確認 できあがったデータをFPGAボードにダウンロードして動作させてみましょう．\nまずは，FPGAとパソコンをUSBケーブルで接続します．ここで，JP5のジャンパをJTAGに，JP16のジャンパをUSB側にセットしておいてください．\n 図35: FPGAとパソコンをUSBケーブルで接続．JP5とJP16の位置にも注意\n  書き込みの手順は次の通りです．\n 図36: Navigator FlowでOpen Hardwareをクリックしたところ\n   図37: Open Targetをクリックし，Auto Connectをクリック\n   図38: FPGAボードと接続できたら，Program Deviceをクリック．開いたファイルダイアログでOKをクリック．\n  これでFPGAボード上のLED LD0が点滅するはずです．\n課題  点滅の間隔を変えてみよう FPGA上のほかのLEDも点滅させてみよう  "});index.add({'id':5,'href':'/learning_fpga/docs/book01/simulation/','title':"シミュレーション",'content':" この章では，Lチカ を題材に設計したデザインがどのように動いているのか，Vivado付属のシミュレータを使ったシミュレーションによって確認する方法を学びます．\nはじめに 実際の開発現場で不具合を解析するときにもシミュレーションは大変有用な手段です．\nHDLで記述したアプリケーション回路をFPGA上で動作させるためには，合成や配置配線を実行してFPGA書き込み用のコンフィギュレーション情報のファイルを生成する必要があります．回路規模が大きくなると，コンフィギュレーション情報を作成するのにも長い時間が必要になります．しかし，シミュレーションの場合は簡単なコンパイルでおしまいです．デバッグなどで，何度もソース・コードを変更するような場合には，シミュレータで動作を確認できれば圧倒的に短時間で済みます．\nまた，FPGAで動作しているアプリケーション回路の各信号が，どのように変化しているか，外から観測するのはなかなか難しいものです．一方で，シミュレーションでは自由に記述したロジックの信号の変化を観察できます．\nそのため，シミュレーションを使用した内部の信号の観測がHDLレベルでの論理的なデバッグに有効です．この章では，このHDLコードの動作をVivadoシミュレータでシミュレーションする方法を学びましょう．\nシミュレーションに必要なもの \u0026mdash; テスト・ベンチ CPUを買ってきても，マザーボードがないとパソコンとして動かないように，FPGAも周辺部品の載った マザーボード がないと動きません．FPGAもFPGA単体では動作せず，MicroBoardやDE0 nanoに搭載されているような回路を駆動するクロック信号やリセット信号が必須です．\n実際にFPGAを使ったシステムでは，クロックは外から与えられるものですが，シミュレーションでは，FPGAに実装したHDLモジュールが動作するのに必要なクロック信号やリセット信号なども自前で用意しなければなりません(図1)．\n 図l: 設計したモジュールを実機で動作させる場合(a)とシミュレーションする場合(b)の違い．シミュレーションする場合にはテスト・ベンチを用意する必要がある．\n  といっても，とりたてて新しく特別なことを覚える必要があるわけではありません．外から与えられるべきクロック信号やリセット信号もHDLで記述できます．これをシミュレーション・コードやテスト・ベンチと呼びます．シミュレーション対象のモジュールで必要となる信号は，すべてテスト・ベンチで生成します．テスト・ベンチの記述方法はHDLソースとほとんど同じで，違いは下記の3つになります．\n エンティティの中身(モジュールの入出力信号)が空である 時間を表す構文を使って信号の振る舞いを規定する ハードウェアでは実現できない仮想的な機能を利用できる  設計したHDLモジュールを動作させるのには必要な，マザーボードに相当する部分をすべて記述しなければなりません．逆にいうと，テスト・ベンチは外部との入出力があってはいけないということです．そのため，VHDLの場合はテスト・ベンチのエンティティの中身が，Verilog HDLの場合moduleの引数が空になるというわけです．\nテスト・ベンチでは 時間 を表現する必要がある 「スイッチを10秒押してから離す」や「50MHzの信号」などの振る舞いは時間を扱うので，HDLのビヘイビア・モデル（動作記述）を用いて記述します．\nたとえば，「10nsの時間を待つ」という動作はHDLで次のように記述します．この記述はビヘイビア・モデルの基本中の基本です． VHDLで記述する場合は，\n1  wait for 10ns;   Verilog HDLで記述する場合には，初めに `timescaleを使って，\n1  `timescale 1ns / 1ps   と，シミュレーションの単位時間を指定して，時間を挿入したい個所で\n1  #10   と記述すると，指定した単位時間分の時間(この例では10ns)を作ることができます．\nテストベンチの書き方 またか!!という感も否めませんが，前章で利用した「LEDチカチカ」に再び登場してもらいましょう．\nシミュレーション用に(実験のために)修正 今回はシミュレーションの動作を知ることを目的にコードを少し修正します．実際の開発の際には，シミュレーションのために実装コードを変える，ということは基本的にはしないはずです．\nresetの追加 回路を初期化するための入力信号としてresetを追加しています．\nLEDに出力するbitを変更 実機ではカウンタの23bit目をledに接続しましたが，クロックの立ち上がりを8M回待つのは大変なので3bit目をledの出力に接続しています．\nモジュールのタイプをRTLに変更 モジュールのタイプをBehaviorではなくRTLとしています．実際のところ今のVivadoでは，ここのキーワードは特に意味をなさないのですがシミュレーションのためのテストベンチをBehavior，合成してハードウェア化もするファイルはRTLと分けておくと見分けるのが容易になります．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top; architecture RTL of top is signal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); begin -- カウンタの3bit目をledに接続(実機では23bit目を使った) led \u0026lt;= std_logic(counter(3)); process(clk) -- クロックの変化で動作するプロセス begin if rising_edge(clk) then -- クロックの立ち上がりであれば if reset = \u0026#39;1\u0026#39; then counter \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); else counter \u0026lt;= counter + 1; -- カウンタをインクリメント end if; end if; end process; end RTL;   FPGA上に実装する場合には，第3章で紹介したように，3つの入出力信号をFPGA上の適切なI/Oに接続しなければなりません．一方，ソフトウェアで動作をシミュレーションするためには，これらの信号テスト・ベンチで生成して外から与える，ことにします．\nクロックを生成するテスト・ベンチ 順序回路の要がクロック信号です．従って，クロック信号の生成はテスト・ベンチの基本中の基本です．\nカウンタ・モジュールの動作をシミュレーションするために， clk に50MHzのクロック信号，すなわち10nsごとに ‘1’ と ‘0’ を繰り返す信号をテスト・ベンチで生成してみましょう． 記述方法は，次の通りです．\nVHDLで記述する場合 信号 clk_i を定義し， clk_i に‘1’を代入して10ns待ちます．その10ns後 clk_i に‘0’を代入，その10n後に再び‘1’を clk_i に代入，…ということを繰り返すことで，10nsで周期的に0→1→0→1\u0026hellip;と変化する信号，すなわち50MHzのクロック信号が生成できます． VHDLのコードで素直に実装すると，「10ns待つ」処理に相当する「wait for 10ns」を使って， 1 2 3 4 5 6 7 8 9 10 11  process begin clk_i \u0026lt;= \u0026#39;1\u0026#39;; wait for 10ns; clk_i \u0026lt;= \u0026#39;0\u0026#39;; wait for 10ns; clk_i \u0026lt;= \u0026#39;1\u0026#39;; wait for 10ns; clk_i \u0026lt;= \u0026#39;0\u0026#39;; wait for 10ns; ... end process;   となります．\nこの process 文には，きっかけになる信号なしで，シミュレーションの開始同時にすぐさま処理が開始されます． もちろん，これでもよいのですが，実はプロセス文は最後まで到達すると，また先頭から開始されるので 1 2 3 4  process begin clk_i \u0026lt;= \u0026#39;1\u0026#39;; wait for 10ns; clk_i \u0026lt;= \u0026#39;0\u0026#39;; wait for 10ns; end process;   という記述で，ずっとクロック信号を作り続けることができます．\nVerilog HDLで記述する場合 Verilog HDLでは，「単位時間XXが経過」を「 #XX 」で表現できますから， clk_i に\u0026rsquo;1\u0026rsquo;を代入したあと， 「単位時間10が経過」の後 clk_i に\u0026rsquo;0\u0026rsquo;を代入して，また「単位時間10が経過」の後 clk_i に\u0026rsquo;1\u0026rsquo;を代入\u0026hellip; と繰り返すことで，1→0→1→\u0026hellip;というシーケンスが定義できます．\nVerilog HDLでは，initial文で，シミュレーション実行開始時に一度だけ処理されるブロックを定義できます． すなわち，次のコード片で，シミュレーション開始後から単位時間10毎に信号を反転させる処理，つまり50MHzのクロック信号を生成できます． 1 2 3 4 5 6  initial begin clk_i = 0; #10; clk_i = 1; #10; ... forever #10 clk_i = !clk_i; end  \nずっと繰り返す処理を意味する forever を使って， 1 2 3 4  initial begin clk_i = 0; forever #10 clk_i = !clk_i; end   と記述することもできます．\n必要な入力信号を生成する 図\\ref{fig:target_list}に示したリストの動作をシミュレーションするにはクロック信号clk以外に，人間が「えいやっ」とリセット・ボタンを押すことに相当するreset信号もテスト・ベンチで生成しなければいけません．\nところで，人間がリセット・ボタンを押すのは，いつ，どのくらいの時間でしょうか？「リセット・ボタンは電源投入の5秒後に10ミリ秒間押される」などと決められるわけではありません．\n従って，テスト・ベンチでは，シミュレーション対象の回路に対して，それらしい信号を想定して生成する必要があります．リセット・ボタンが押されるタイミング，であれば，特に制約があるわけではありませんので，電源投入後の適当な時刻に検知できる時間だけの信号が与えられる，という想定で十分でしょう．\nリセット信号を生成する方法は，\n クロックと同じプロセス・ブロックで記述する 別のプロセスのブロック内で記述する  の2種類が考えられます．\nここでは，クロックとは別のプロセス・ブロック内で，変数 reset_i の値を0→1→0と変化させることで，リセット・ボタンが押されたことに相当する信号を生成することにします．Verilog HDLであれば，リセットに相当するレジスタ変数 reset_i が適当なタイミングで変化するように記述できます． 1 2 3 4 5 6 7 8  initial begin reset_i \u0026lt;= \u0026#39;0\u0026#39;; -- 最初はリセット信号は\u0026#39;0\u0026#39; wait for 5ns; reset_i \u0026lt;= \u0026#39;1\u0026#39;; -- 5n秒後にリセット信号を\u0026#39;1\u0026#39;に wait for 100ns; reset_i \u0026lt;= \u0026#39;0\u0026#39;; -- しばらくしたら(100n秒後)，リセット信号を\u0026#39;0\u0026#39;に wait; -- 以降は何もしない end  \nテスト・ベンチとシミュレーション対象のモジュールを接続する FPGA上に書き込んだ回路に信号を与えるためには，物理的にクロックやスイッチの端子を配線することになります． シミュレーションする場合には，シミュレーション対象のモジュールとテスト・ベンチで生成した信号をHDL的に接続する必要があります．\n一般的には，テスト・ベンチをトップ・モジュールとして， その中でカウンタ・モジュールをサブモジュールとして呼び出すことにします． これはマザー・ボードがあって，その中にFPGAがあって回路が動いている，という物理的な構造に上手くマッチします． VHDLもVerilog HDLも，モジュールを階層的に定義する仕組みをもっています．\nVHDLでは，\n LEDチカチカ回路のインターフェースを宣言 LEDチカチカ回路のインスタンスを生成する  の2段階で，サブモジュールとして回路を呼び出すことができます．\n具体的には，はじめに，次のように， 1 2 3 4 5 6 7 8  -- サブ・モジュールであるtestの素性を記述 component test port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end component;   component として，使用するモジュールの素性を宣言したあとで，次のように 1 2 3 4 5 6  -- サブ・モジュールをインスタンス化する U: test port map( clk =\u0026gt; clk_i, reset =\u0026gt; reset_i led =\u0026gt; led, );   このモジュールのインスタンスを生成，配線関係を記述します．\nプログラミング言語Cでも，関数を呼び出す時には，関数の素性を明らかにするために「プロトタイプ宣言」をした上で， 関数呼び出し文を書きますよね．VHDLでも同じようなものだな，と考えてもらえればよいでしょう．\nテスト・ベンチの全容 説明が長くなりましたが，図\\ref{fig:target_list}のリストをシミュレーションするためのテスト・ベンチの全容は， 図\\ref{fig:simulation_list}のようになります．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top_sim is end top_sim; architecture Behavioral of top_sim is -- シミュレーション対象のモジュールを宣言 component top Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end component top; -- シミュレーション対象のモジュールの信号用の変数を宣言 signal clk_i : std_logic := \u0026#39;0\u0026#39;; signal reset_i : std_logic := \u0026#39;0\u0026#39;; signal led_i : std_logic := \u0026#39;0\u0026#39;; begin -- シミュレーション対象のモジュールのインスタンス生成 U : top port map( clk =\u0026gt; clk_i, reset =\u0026gt; reset_i, led =\u0026gt; led_i ); -- クロックを生成 process begin clk_i \u0026lt;= \u0026#39;1\u0026#39;; wait for 10ns; clk_i \u0026lt;= \u0026#39;0\u0026#39;; wait for 10ns; end process; -- リセット信号の生成 process begin reset_i \u0026lt;= \u0026#39;0\u0026#39;; wait for 5ns; reset_i \u0026lt;= \u0026#39;1\u0026#39;; wait for 100ns; reset_i \u0026lt;= \u0026#39;0\u0026#39;; wait; end process; end Behavioral;   シミュレーションの実行手順 シミュレーションのテスト用に新しくプロジェクトを作成しましょう． プロジェクト名は， project_2 としました．\n 新しく作成したプロジェクト\n  前章と同様にtopモジュールを作成・追加してプロジェクトを作成したら， topモジュールの中身を図\\ref{fig:target_list}のように変更しておきます．\n以降の手順は次の通りです．\n Sourcesの中のSimulation Sourcesの上で右クリックしてAdd Sourcesを選択\n   Add or create simulation sourcesにチェックが入っていることを確認してNextをクリック\n   ファイル追加ダイアログで，Create Fileを選択\n   VHDLファイルとして，top_simという名前のモジュールを作成する\n   リストに追加された\n   ポートの指定ダイアログ．今回は何もせずにOKをクリック\n   変更ないことを確認されるのでYesをクリックして，作業ステップをすすめる\n   シミュレーション用のモジュールがプロジェクトに追加された\n   シミュレーションコードをtop_simに反映したところ．top_simからtopのモジュールがUという名前でインスタンス化されている様子が階層化されて表示される．\n   Flow NavigatorのRun Simulationでシミュレーションの開始\n   Run Behavioral Simultaionを選択\n   シミュレーション開始には少し時間がかかる\n   シミュレーションが開始された\n   シミュレーション時間を指定して，シミュレーションステップをすすめる\n  指定した時間のシミュレーションが終わるとストップします．いつまでもストップしない場合には，一時停止アイコンをクリックして，強制的に止めることができます．\n 指定した時間のシミュレーションが終了\n   波形表示画面に全シミュレーション結果を表示(FIT)させたところ\n   一部分を拡大した様子．3bit目をledに接続しているため8クロック毎にledがON/OFFしている様子がみてとれる\n   内部モジュール(今回でいうとtopの中身を確認することもできる)\n   topモジュールのcounterを波形表示画面に追加．ただし，内部の値の多くは非表示状態では保存されていないので，そのままでは値の変化を確認できない\n   シミュレーションを一度リセット\n   再度シミュレーション．今度は時間指定なくシミューレションしてみる\n   いつまでも終わらないので一時停止アイコンでシミュレーションをストップ\n   ストップした箇所のソースコードが表示される\n   波形を確認してみると，内部のcounterがclkにあわせてインクリメントしていること，counterの3bit目がledの\u0026rsquo;0\u0026rsquo;/\u0026lsquo;1\u0026rsquo;と同じであることが確認できる\n  課題  点滅の間隔を変えてみたときの様子をシミュレーションしてみよう resetを適当なタイミングで変化させてみて，counterやledの振る舞いを観察してみよう  "});index.add({'id':6,'href':'/learning_fpga/docs/book01/basics/','title':"基本実験",'content':" かんたんな実験を通じてFPGAでのハードウェア作りの基礎力を手に入れましょう．\nはじめに いくつかの簡単なHDLコードを書いて，FPGAでのハードウェア作りの基礎力を手に入れましょう．実際にHDLコードを書き，シミュレーションして，実機動作を確認することは，より複雑なハードウェアを設計するための第一歩です．\nILAを使ってFPGA内部の信号を観測する FPGAは，FPGAの中で回路がどのように動作しているのかを知るためのILA(Internal Logic Analyzer)という仕組みを持っています．実験コードを書きはじめる前に，このILAの使い方を学んでみましょう．\nLチカでILAの動作を学ぶ 三度目の登場ですが，LチカでILAの動作を学びましょう．第4章で利用した\\verb|project_2|を使用します．\n準備 ILAを使ってデバッグするために，topモジュールのソースコードを次のように書き変えてください．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is Port ( clk : in std_logic; reset : in std_logic; led : out std_logic ); end top; architecture RTL of top is attribute mark_debug : string; -- (1) 追加 signal counter : unsigned(31 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); attribute mark_debug of counter : signal is \u0026#34;true\u0026#34;; -- (2) 追加 begin -- カウンタの3bit目をledに接続(実機では23bit目を使った) led \u0026lt;= std_logic(counter(3)); process(clk) -- クロックの変化で動作するプロセス begin if rising_edge(clk) then -- クロックの立ち上がりであれば if reset = \u0026#39;1\u0026#39; then counter \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); else counter \u0026lt;= counter + 1; -- カウンタをインクリメント end if; end if; end process; end RTL;   (1)と(2)が追加ポイントです．(1)で\\verb|mark_debug|というattributeを利用することを宣言し，(2)でcounterに\\verb|mark_debug|というattributeを付与しています．attributeは，ツールに対する指示子です．Vivadoでは，\\verb|mark_debug|を付与した信号はデバッグ対象の可能性があるとして特別扱いします．\nコードが準備できたら，一度合成してピン配置まで終わらせてしまいましょう．\n I/O Planningでclk，reset，ledのピン配置を決定する\n  ILAのセットアップと利用方法 準備ができたらILAを追加して，その動作の様子を確認してみましょう．\n 一度合成する\n   合成が終わったらOpen Synthesized Designで合成結果を開く\n   LayoutメニューのDebugをクリックしてデバッグビューに変更する\n   ILA設定用の画面 \\label{fig:debug_mode_view}\n   下にある虫みたいなアイコンをクリックしてILA設定用のウィザードを開く\n   ILA設定用ウィザードの開始\n   mark_debugを付与したcounterがリストに追加されているので，そのままNextですすむ．ここで新たにILAによる観測対象を追加したい場合には+アイコンをクリックすると信号を選ぶことができる．逆にリストにある信号を対象から取り除きたい場合には，取り除きたい信号を選択して-をクリックする\n   ILAで取得するデータ数の設定など．今回はそのままにしてNextですすむ\n   サマリの表示．Finishで完了\n   ウィザードが閉じてILAの設定は完了．ILAが追加できていることがわかる．あとは，Generate Bitstreamでビットファイルを作成すればよい．\n   ILAの設定情報をxdcファイルに保存してよいかの確認．Yesで次のステップにすすむ．\n   Generate bitstreamの前に依存する他のタスクを実行します，という確認ダイアログ．Yesで次のステップへ\n   合成と配置配線の開始\n   無事に合成と配置配線が終了しビットファイルができあがったところ．Open Hardware Managerを選択してOKをクリックすることで，ハードウェアマネージャの起動の手間を省くことができる\n   FPGAとパソコンをUSBケーブルで接続してAuto connectで認識させた後，Program Deviceをクリック\n   bitファイルはFPGAに，ILAのパソコン側の定義ファイルであるilxはVivadoに読み込ませる．\n   書き込み中\n   FPGAへのダウンロードが終了した．また，ILAによる動作のモニタ画面が表示された\n   二重矢印のアイコンをクリックすると，その時点での値をキャプチャしてくれる\n   虫眼鏡アイコンで拡大すると，値が1ずつ増えていることが確認できる\n   実機デバッガでは値をキャプチャする条件(トリガ条件)を指定する\n   counterの値をトリガ条件に使用することとする\n   counterの値がトリガ条件として登録された\n   counterが00001000になった時点でキャプチャするように設定．トリガ値を指定したら三角アイコンでキャプチャを開始する\n   counterが00001000になった時点のデータをキャプチャすることができた\n   トリガにはドントケア(X)を指定することも可能．ここでは下位16bitが3000になるデータを取得するように指定してみる\n   上位16bitは指定なく，下位16bitが3000の時点のデータがキャプチャできていることがわかる\n  ILA挿入すると回路は変わる 重要な点ですが，ILAを挿入すると，挿入前とは異なるハードウェアになることを理解しておく必要があります．ILA向けのリソース使用量が増えるのはもちろん，観測対象の信号の接続関係も変化します．また観測のために残すべきレジスタの都合で最適化の結果もかわってきます．\nたとえば，図\\ref{fig:without_mark_debug}は，counterにmark_debugアトリビュートを付与せずに合成した場合のデバッグビューです．3bit目をledに接続し，それ以上のbit数の値は利用さていないため，ばっさりと回路が小さくなっていることがわかります．\nしかし，mark_debugアトリビュートを付与して合成した場合には，もちろん最適化するわけにはいかないため，図\\ref{fig:debug_mode_view}のように要/不要にかかわらず32bit分すべてのレジスタが回路として生成されています．\n counterにmark_debugがない場合 \\label{fig:without_mark_debug}\n  基本実験の準備 FPGAを使った実験をする前に，動作の様子を確認しながら実験できるように簡単なテンプレートモジュールを用意しておくことにします． ここで作るのは，図\\ref{fig:experiment_template}のように4bitの入力と4bitの出力ポートで構成されるモジュールです． ZYBOのDIPスイッチSW0〜SW3を4bitの入力に，LED LD0〜LD3を4bitの出力にマッピングすることにします．\n n{実験用の簡単なテンプレートモジュール \\label{fig:experiment_template}\n  次のような内容のVHDLファイルを用意します．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top; architecture RTL of top is signal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0); begin LD \u0026lt;= sw_d1; process(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process; end RTL;   ピン定義も用意しましょう．第3章で紹介したようにGUIで設定することもできますが，スクリプトファイルでピン定義を決めることもできます．実験に使用するZYBO Z7-20の全てのI/O定義は\\url{https://github.com/Digilent/digilent-xdc/blob/master/Zybo-Z7-Master.xdc}にまとまっています．URL先の情報に基づいて，使用するピンの定義をまとめると次のようになります．top.xdcなどと，拡張子を.xdcとしてファイルに保存します． 1 2 3 4 5 6 7 8 9 10 11 12  set_property -dict {PACKAGE_PIN K17 IOSTANDARD LVCMOS33 } [get_ports {CLK}]; create_clock -add -name clk_pin -period 8.00 -waveform {0 4} [get_ports {CLK}]; set_property -dict {PACKAGE_PIN G15 IOSTANDARD LVCMOS33} [get_ports {SW[0]}]; set_property -dict {PACKAGE_PIN P15 IOSTANDARD LVCMOS33} [get_ports {SW[1]}]; set_property -dict {PACKAGE_PIN W13 IOSTANDARD LVCMOS33} [get_ports {SW[2]}]; set_property -dict {PACKAGE_PIN T16 IOSTANDARD LVCMOS33} [get_ports {SW[3]}]; set_property -dict {PACKAGE_PIN M14 IOSTANDARD LVCMOS33} [get_ports {LD[0]}]; set_property -dict {PACKAGE_PIN M15 IOSTANDARD LVCMOS33} [get_ports {LD[1]}]; set_property -dict {PACKAGE_PIN G14 IOSTANDARD LVCMOS33} [get_ports {LD[2]}]; set_property -dict {PACKAGE_PIN D18 IOSTANDARD LVCMOS33} [get_ports {LD[3]}];  \n作成したVHDLファイルと定義ファイルをプロジェクトに追加して合成し，できあがったbitファイルをZYBO Z7-20に書きこみましょう．DIPスイッチをオン・オフすることでLEDが点灯，消灯するはずです．\n基本演算の動作を確認してみよう 基本的な論理演算である，AND/OR/XORの動作を実機のILAを使って確認してみましょう．\nAND/OR/XOR/NOTの動作を確認するためのモジュールとして次のようなモジュールを用意します． 名前は\\verb|logic_test.vhd|として保存することにします． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity logic_test is port ( CLK : in std_logic; a, b : in std_logic; q_and : out std_logic; q_or : out std_logic; q_xor : out std_logic; q_not : out std_logic ); end entity logic_test; architecture RTL of logic_test is attribute mark_debug : string; q_and_i : std_logic; q_or_i : std_logic; q_xor_i : std_logic attribute mark_debug of q_and_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of q_or_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of q_xor_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of q_not_i : signal is \u0026#34;true\u0026#34;; begin q_and \u0026lt;= q_and_i; q_or \u0026lt;= q_or_i; q_xor \u0026lt;= q_xor_i; q_not \u0026lt;= q_not_i; process(CLK) begin if rising_edge(CLK) then q_and_i \u0026lt;= a and b; q_or_i \u0026lt;= a or b; q_xor_i \u0026lt;= a and b; q_not_i \u0026lt;= xor a; end if; end process; end RTL;  \n先に用意したテンプレートに組み込んで，実機で動作を確認するために，\\verb|top.vhd|を次のように変更します．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top; architecture RTL of top is signal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0); component logic_test port ( CLK : in std_logic; a, b : in std_logic; q_and : out std_logic; q_or : out std_logic; q_xor : out std_logic; q_not : out std_logic ); end component logic_test; begin -- LD \u0026lt;= sw_d1; process(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process; U : logic_test port map( CLK =\u0026gt; CLK, a =\u0026gt; sw_d1(0), b =\u0026gt; sw_d1(1), q_and =\u0026gt; LD(0), q_or =\u0026gt; LD(1), q_xor =\u0026gt; LD(2), q_not =\u0026gt; LD(3) ); end RTL;   ランダムな振る舞いを実現する擬似乱数の生成 ゲームなどで，ランダムな振る舞いをさせたいときに用いられるのが乱数です．本物の乱数を作るのは非常に難しいため，一般的には数式で導いた擬似乱数で代用します．ソフトウェアで乱数を作成する場合は，rand関数などを呼び出すことで乱数系列に従って生成された値を利用できます．\n乱数系列の作り方には，いろいろな方法があります．今回は，ビット操作の練習として，シフトとXOR演算のみで構成できるXORSHIFT法(参考文献1)に基づく乱数生成器を実装してみましょう．32ビットのXORSHIFT法による乱数生成をCで記述すると，\n1 2 3 4 5 6  unsigned long xor() { static unsigned long y=2463534242; y ^= (y \u0026lt;\u0026lt; 13); y ^= (y \u0026gt;\u0026gt; 17); return (y ^= (y\u0026lt;\u0026lt;5)); }   という関数になります． この関数と同等の操作をするハードウェア・モジュールを作成し，シミュレーションと実機で動作を確認してみましょう．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity xorshift is port ( CLK : in std_logic; Q : out std_logic_vector(31 downto 0) ); end entity xorshift; architecture RTL of xorshift is attribute mark_debug : string; -- 2463534242 = 0x92d68ca2 signal y : std_logic_vector(63 downto 0) := X\u0026#34;0000000092d68ca2\u0026#34;; signal y0_d, y1_d : std_logic_vector(63 downto 0); attribute mark_debug of y : signal is \u0026#34;true\u0026#34;; attribute mark_debug of y0_d : signal is \u0026#34;true\u0026#34;; attribute mark_debug of y1_d : signal is \u0026#34;true\u0026#34;; begin Q \u0026lt;= y(31 downto 0); process(CLK) variable y0 : std_logic_vector(63 downto 0); variable y1 : std_logic_vector(63 downto 0); begin if rising_edge(CLK) then -- y ^= (y \u0026lt;\u0026lt; 13); y0 := y xor (y(63-13 downto 0) \u0026amp; \u0026#34;0000000000000\u0026#34;); -- y ^= (y \u0026gt;\u0026gt; 17); y1 := y0 xor (\u0026#34;00000000000000000\u0026#34; \u0026amp; y0(63 downto 17)); -- y ^= (y \u0026lt;\u0026lt; 5); y \u0026lt;= y1 xor (y1(63-5 downto 0) \u0026amp; \u0026#34;00000\u0026#34;); -- to debug y0_d \u0026lt;= y0; y1_d \u0026lt;= y1; end if; end process; end RTL;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top; architecture RTL of top is signal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0); component xorshift port ( CLK : in std_logic; Q : out std_logic_vector(31 downto 0) ); end component xorshift; begin -- LD \u0026lt;= sw_d1; process(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process; U : xorshift port map( CLK =\u0026gt; CLK, Q(3 downto 0) =\u0026gt; LD(3 downto 0), Q(31 downto 4) =\u0026gt; open ); end RTL;   ビット加算器を作ってみよう ビット加算器，つまり足算の基本要素を作ってみましょう．ビット加算器では，足される数，足す数，および，繰り上がりの3bitの入力から，その桁の結果と繰り上がりの2bitを出力します．全加算器は半加算器2個とORで作ることができます． 以下のリストを参考に，加算器が正しく動作することをシミュレータおよびILAを使って実機で確認してください．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  -- 半加算器 library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity half_addr is port ( a : in std_logic; b : in std_logic; s : out std_logic; c : out std_logic ); end half_addr; architecture RTL of half_addr is attribute mark_debug : string; signal s_i : std_logic; signal c_i : std_logic; attribute mark_debug of s_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of c_i : signal is \u0026#34;true\u0026#34;; begin s \u0026lt;= s_i; c \u0026lt;= c_i; process(a, b) begin s_i \u0026lt;= a xor b; c_i \u0026lt;= a and b; end process; end RTL;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  -- 全加算器 library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity full_addr is Port ( a : in std_logic; b : in std_logic; ci : in std_logic; s : out std_logic; co : out std_logic ); end full_addr; architecture RTL of full_addr is attribute mark_debug : string; signal s_i : std_logic; signal co_i : std_logic; attribute mark_debug of s_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of co_i : signal is \u0026#34;true\u0026#34;; component half_addr Port ( a : in std_logic; b : in std_logic; s : out std_logic; c : out std_logic ); end component half_addr; signal s0 : std_logic; signal c0 : std_logic; signal c1 : std_logic; begin s \u0026lt;= s_i; co \u0026lt;= co_i; U0: half_addr port map( a =\u0026gt; a, b =\u0026gt; b, s =\u0026gt; s0, c =\u0026gt; c0); U1: half_addr port map( a =\u0026gt; s0, b =\u0026gt; ci, s =\u0026gt; s_i, c =\u0026gt; c1); co_i \u0026lt;= c0 or c1; end RTL;   HDLの四則演算を試してみよう VHDLやVerilog HDLでは，加算器のレベルでハードウェアを設計する必要はなく，実際には定義されている算術演算を利用することができます．+/-/*の動作をシミュレータおよび実機で確認してみてください．\nたとえば，次のようなVHDLコードを書いて試すことができます． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity arith_test is port ( a : in std_logic_vector(1 downto 0); b : in std_logic_vector(1 downto 0); q_a_add_b : out std_logic_vector(2 downto 0); q_a_sub_b : out std_logic_vector(2 downto 0); q_a_mult_b : out std_logic_vector(3 downto 0) ); end arith_test; architecture RTL of arith_test is attribute mark_debug : string; signal q_a_add_b_i : unsigned(2 downto 0); signal q_a_sub_b_i : unsigned(2 downto 0); signal q_a_mult_b_i : unsigned(3 downto 0); attribute mark_debug of q_a_add_b_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of q_a_sub_b_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of q_a_mult_b_i : signal is \u0026#34;true\u0026#34;; begin q_a_add_b \u0026lt;= std_logic_vector(q_a_add_b_i); q_a_sub_b \u0026lt;= std_logic_vector(q_a_sub_b_i); q_a_mult_b \u0026lt;= std_logic_vector(q_a_mult_b_i); process(a, b) begin q_a_add_b_i \u0026lt;= unsigned(\u0026#39;0\u0026#39; \u0026amp; a) + unsigned(\u0026#39;0\u0026#39; \u0026amp; b); q_a_sub_b_i \u0026lt;= unsigned(\u0026#39;0\u0026#39; \u0026amp; a) - unsigned(\u0026#39;0\u0026#39; \u0026amp; b); q_a_mult_b_i \u0026lt;= unsigned(a) * unsigned(b); end process; end RTL;  \n合計値の計算 算術演算の応用問題として，与えられたデータ(たとえば32ビットのビット列)の中に，1がいくつあるかを数えて値を返すというモジュールを作成してみましょう．たとえば，0x00000001の場合はビット列の中に1は1個，0xAAAAAAAAの場合は16個という値を出力する，モジュールです．\nもちろん逐次的に，1クロックで1bitずつ\u0026rsquo;0\u0026rsquo;か\u0026rsquo;1\u0026rsquo;かを検査するという，ソフトウェア的な実装も考えられますが，ここでは，入力された値に対して即座に結果を返す組み合わせ回路として設計し，シミュレーションと実機で動作を確認してみてください．\nたとえば，次のようなVHDLコードを書いて試すことができます． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity bitcount is port ( a : in std_logic_vector(31 downto 0); q : out std_logic_vector(4 downto 0) ); end bitcount; architecture RTL of bitcount is attribute mark_debug : string; signal q_i : unsigned(4 downto 0); attribute mark_debug of q_i : signal is \u0026#34;true\u0026#34;; begin q \u0026lt;= std_logic_vector(q_i); process(a) variable sum : integer := 0; begin sum := 0; for i in 0 to a\u0026#39;length-1 loop if a(i) = \u0026#39;1\u0026#39; then sum := sum + 1; end if; end loop; q_i \u0026lt;= to_unsigned(sum, q_i\u0026#39;length); end process; end RTL;  \nPWM ある値を，1bitの信号の\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;の幅で表現するPWMという変調方式があります． ディジタルで簡単に信号の強度を変える方法としてもよく利用されます．\n次のVHDLコードは，PWMを実装してみた例です． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity pwm is port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end pwm; architecture RTL of pwm is attribute mark_debug : string; signal counter : unsigned(3 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal q_i : std_logic := \u0026#39;0\u0026#39;; attribute mark_debug of q_i : signal is \u0026#34;true\u0026#34;; attribute mark_debug of counter : signal is \u0026#34;true\u0026#34;; begin q \u0026lt;= q_i; process(clk) begin if rising_edge(clk) then counter \u0026lt;= counter + 1; if counter \u0026gt;= unsigned(a) and unsigned(a) \u0026lt; 15 then q_i \u0026lt;= d; else q_i \u0026lt;= not d; end if; end if; end process; end RTL;  \n次のようにスイッチをPWMの幅に，出力をLEDに割り当てて合成したときの動作を 実機で確認してみましょう． 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity top is port ( CLK : in std_logic; SW : in std_logic_vector(3 downto 0); LD : out std_logic_vector(3 downto 0) ); end entity top; architecture RTL of top is signal sw_d0 : std_logic_vector(3 downto 0); signal sw_d1 : std_logic_vector(3 downto 0); component pwm port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end component pwm; signal pwm_q : std_logic; begin process(CLK) begin if rising_edge(CLK) then sw_d0 \u0026lt;= SW; sw_d1 \u0026lt;= sw_d0; end if; end process; U: pwm port map( clk =\u0026gt; clk, a =\u0026gt; sw_d1, d =\u0026gt; \u0026#39;1\u0026#39;, q =\u0026gt; pwm_q ); LD(0) \u0026lt;= pwm_q; LD(1) \u0026lt;= pwm_q; LD(2) \u0026lt;= pwm_q; LD(3) \u0026lt;= pwm_q; end RTL;  \nステートマシンの作り方と利用方法 基本実験の最後に，ハードウェア・プログラミングで逐次的に処理するために必要不可欠な概念であるステート・マシンと，その実装方法を学びましょう．ハードウェアでは処理を並列に実行できますが，世の中には順番にしか実行できない物事もたくさんあります．たとえば，そうめんを茹でるとき，鍋の水がまだ湯になる前に並行してそうめんを鍋に入れても，とても食べられるものはできあがりません．何事でも順序を守ることが大事なときもありますよね．\n料理は逐次的な処理 何かを実行し，その次に何かを実行し，その次に\u0026hellip;，という決まった手順に従った処理の実装は，ソフトウェアによく見られます．たとえば，そうめんをゆでるときには，\n 鍋に水を入れる 鍋を火にかける 沸騰するまで待つ そうめんを入れる 1分くらい待つ 十分やわらかいか確認する やわらかくなったら取り出して，できあがり  という手順が必要となります．ソフトウェアであれば，このような手順をそのままプログラミング言語で記述して実装できます．しかし，ハードウェア・プログラミングでは逐次的な処理をそのまま記述できません．逐次的に処理を進めることそのものを自分で記述する必要があります．これを簡単に扱う道具がステート・マシン(状態遷移機械)です．\nステート・マシンとは 図\\ref{fig:statemachine_example}は，そうめんをゆでる手順をステート・マシン的に表現した例です．楕円は「状態」を矢印は「状態遷移」を示しています．矢印に条件が書かれている場合は，その条件が満たされたときだけ状態が遷移する，ということを意味します．\n n{そうめんを茹でる流れをステートマシン的に表現してみた例．\\label{fig:statemachine_example}\n  ステート・マシンとは，処理を「状態」と「状態遷移」で抽象化した概念です．列挙された状態を定義された状態遷移に従って順々にたどっていくことで所望の処理が実現できます．各状態での処理を定義することで，逐次的な処理をステート・マシンを使って記述できます．\nハードウェア・プログラミングと相性の良いステート・マシン ステート・マシンをハードウェア・プログラミングで実装するのは意外と簡単です．そうめんを茹でる手順をハードウェア記述言語の一つであるVHDLで記述した擬似コードを示します． 各状態を\\verb|std_logic_vector|型の変数stateで管理しています．stateの値が各状態に対応しています．変数stateをクロックごとに参照し，その時点で実行すべき処理を判断します．各状態では，次の状態に遷移するための条件判断と，遷移のための状態変数の更新を行います．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  --------------------------------------------------------- -- そうめんをゆでるステートマシンの擬似コード --------------------------------------------------------- architecture RTL of somen signal state : std_logic_vector(2 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); process(clk) begin if rising_edge(clk) then case conv_integer(state) -- 変数「state」によって状態の場合分けをする when 0 =\u0026gt; 鍋に水をいれる state \u0026lt;= conv_std_logic_vector(1, 3); when 1 =\u0026gt; 鍋を火をかける state \u0026lt;= conv_std_logic_vector(2, 3); when 2 =\u0026gt; if 水が湧いたか？ = true then state \u0026lt;= conv_std_logic_vector(3, 3); end if; when 3 =\u0026gt; そうめんをいれる state \u0026lt;= conv_std_logic_vector(4, 3); when 4 =\u0026gt; if 時間 = 1分 then state \u0026lt;= conv_std_logic_vector(5, 3); end if; when 5 =\u0026gt; if やわらかさが十分か？ = true then state \u0026lt;= conv_std_logic_vector(6, 3); end if; when 6 =\u0026gt; -- おしまい when others =\u0026gt; -- 「上記以外のその他」に相当．これで，全条件を列挙できた． null; end case; end if; end process; end RTL;   ところで，リスト1のコードには，0，1，2，\u0026hellip;という状態を識別するための番号が振られています．これらの値に意味はなく，単にほかと区別するために便宜的に付けられたマジック・ナンバです．マジック・ナンバはコードの可読性を下げ，後の変更を加えづらくします．ソフトウェアでもマジック・ナンバは忌み嫌われるように，ハードウェア・プログラミングでもできれば避けたいものです．\nVHDLでは自分で型を定義することで，Verilogではdefineやlocalparamを使って値に名前を付けることで，ソース・コードからマジック・ナンバを取り除くことができます．VHDLで状態を表す型を定義して，マジック・ナンバをなくした例が次の通りです．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  --------------------------------------------------------- -- そうめんをゆでるステートマシンの擬似コード -- 状態変数のための型を定義しマジックナンバをなくしたバージョン --------------------------------------------------------- architecture RTL of somen -- 状態を表わす型を定義する．これは，enumのような列挙型に相当． type StateType is (WATER, FIRE, HOT_WATER, PUT_SOMEN, WAIT_A_MIN, BOIL, FIN) signal state : StateType := WATER; process(clk) begin if rising_edge(clk) then case conv_integer(state) when WATER =\u0026gt; 鍋に水をいれる state \u0026lt;= FIRE; when FIRE =\u0026gt; 鍋を火をかける state \u0026lt;= HOT_WATER; when HOT_WATER =\u0026gt; if \u0026#34;水が湧いたか？ = true\u0026#34; then state \u0026lt;= PUT_SOMEN; end if; when PUT_SOMEN =\u0026gt; そうめんをいれる state \u0026lt;= WAIT_A_MIN; when WAIT_A_MIN =\u0026gt; if 時間 = 1分 then state \u0026lt;= BOIL end if; when BOIL =\u0026gt; if やわらかさが十分か？ = true then state \u0026lt;= conv_std_logic_vector(6, 3); end if; when FIN =\u0026gt; -- おしまい when others =\u0026gt; null; end case; end if; end process; end RTL;   次のリストを参考に，ステートマシンを利用したハードウェアを設計し，動作をシミュレーションとILAで確認してみてください．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity stmt_test is port ( clk : in std_logic; a,b : in std_logic; led : out std_logic_vector(2 downto 0) ); end stmt_test; architecture RTL of stmt_test is attribute mark_debug : string; signal led_i : std_logic_vector(2 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); attribute mark_debug of led_i : signal is \u0026#34;true\u0026#34;; type StateType is (BLACK, RED, GREEN, BLUE); signal state : StateType := BLACK; signal a_d, b_d : std_logic := \u0026#39;0\u0026#39;; signal a_rising, b_rising : std_logic := \u0026#39;0\u0026#39;; begin led \u0026lt;= led_i; a_rising \u0026lt;= \u0026#39;1\u0026#39; when a_d = \u0026#39;0\u0026#39; and a = \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; b_rising \u0026lt;= \u0026#39;1\u0026#39; when b_d = \u0026#39;0\u0026#39; and b = \u0026#39;1\u0026#39; else \u0026#39;0\u0026#39;; process(clk) begin if rising_edge(clk) then a_d \u0026lt;= a; b_d \u0026lt;= b; case state is when BLACK =\u0026gt; led_i \u0026lt;= \u0026#34;000\u0026#34;; if a_rising = \u0026#39;1\u0026#39; then state \u0026lt;= RED; elsif b_rising = \u0026#39;1\u0026#39; then state \u0026lt;= BLUE; end if; when RED =\u0026gt; led_i \u0026lt;= \u0026#34;001\u0026#34;; if a_rising = \u0026#39;1\u0026#39; then state \u0026lt;= GREEN; elsif b_rising = \u0026#39;1\u0026#39; then state \u0026lt;= BLACK; end if; when GREEN =\u0026gt; led_i \u0026lt;= \u0026#34;010\u0026#34;; if a_rising = \u0026#39;1\u0026#39; then state \u0026lt;= BLUE; elsif b_rising = \u0026#39;1\u0026#39; then state \u0026lt;= RED; end if; when BLUE =\u0026gt; led_i \u0026lt;= \u0026#34;100\u0026#34;; if a_rising = \u0026#39;1\u0026#39; then state \u0026lt;= BLACK; elsif b_rising = \u0026#39;1\u0026#39; then state \u0026lt;= GREEN; end if; when others =\u0026gt; led_i \u0026lt;= \u0026#34;000\u0026#34;; state \u0026lt;= BLACK; end case; end if; end process; end RTL;   参考文献  George Marsaglia, \u0026ldquo;Xorshift RNGs\u0026rdquo;, The Florida State University, \\url{http://www.jstatsoft.org/v08/i14}  "});index.add({'id':7,'href':'/learning_fpga/docs/book01/experiments/','title':"実験",'content':" HDLのいろいろな記述方法を使って，少し複雑なモジュールの設計に取り組んでみましょう．\nはじめに これまでに学んできた内容を利用して，少し応用的な実験に取り組んでみましょう．\nストップウォッチを作ってみよう ここでは，\n アクションボタンを押すとミリ秒毎のカウントアップを開始する カウント中に，アクションボタンを押すとカウントを一時停止する 一時停止中に，アクションボタンを押すとカウントを再開する リセットボタンを押すとカウントを0にクリアする  という機能をもったストップウォッチを作ってみましょう．\n残念ながら，ZYBO Z7-20には，7セグメントLEDのような数字を表示する分かりやすい表示器はありませんので，4つのLEDと2つの3色LEDを使って数を表現するとよいでしょう．\n次のリストはストップウォッチを実装するためのトップモジュールの例です．3色LEDの明るさを適当に調節するために，PWMモジュールを使って出力を変調しています．PWMモジュールによって，たとえば\\verb|\u0026lsquo;1\u0026rsquo;|を出力する場合でも，適当なタイミングで\u0026rsquo;1\u0026rsquo;と\u0026rsquo;0\u0026rsquo;がまぜられることで明るさを抑えることができます．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity stopwatch_z7_20 is port ( CLK : in std_logic; led6_r : out std_logic; led6_g : out std_logic; led6_b : out std_logic; led5_r : out std_logic; led5_g : out std_logic; led5_b : out std_logic; LD : out std_logic_vector(3 downto 0); btn : in std_logic_vector(1 downto 0) ); end entity stopwatch_z7_20; architecture RTL of stopwatch_z7_20 is attribute ASYNC_REG : string; attribute mark_debug : string; component stopwatch generic ( FREQ_MHz : integer := 125 ); port ( clk : in std_logic; reset : in std_logic; action : in std_logic; msec_out : out std_logic_vector(9 downto 0); sec_out : out std_logic_vector(5 downto 0); min_out : out std_logic_vector(5 downto 0); hour_out : out std_logic_vector(4 downto 0) ); end component stopwatch; component pwm port ( clk : in std_logic; a : in std_logic_vector(3 downto 0); d : in std_logic; q : out std_logic ); end component pwm; signal btn_d0 : std_logic_vector(1 downto 0); signal btn_d1 : std_logic_vector(1 downto 0); attribute ASYNC_REG of btn_d0, btn_d1 : signal is \u0026#34;TRUE\u0026#34;; signal msec_out : std_logic_vector(9 downto 0); signal sec_out : std_logic_vector(5 downto 0); signal min_out : std_logic_vector(5 downto 0); signal hour_out : std_logic_vector(4 downto 0); attribute mark_debug of msec_out : signal is \u0026#34;true\u0026#34;; attribute mark_debug of sec_out : signal is \u0026#34;true\u0026#34;; attribute mark_debug of min_out : signal is \u0026#34;true\u0026#34;; attribute mark_debug of hour_out : signal is \u0026#34;true\u0026#34;; begin process(CLK) begin if rising_edge(CLK) then btn_d0 \u0026lt;= btn; btn_d1 \u0026lt;= btn_d0; end if; end process; U: stopwatch generic map( FREQ_MHz =\u0026gt; 125 ) port map( clk =\u0026gt; CLK, reset =\u0026gt; btn_d1(0), action =\u0026gt; btn_d1(1), msec_out =\u0026gt; msec_out, sec_out =\u0026gt; sec_out, min_out =\u0026gt; min_out, hour_out =\u0026gt; hour_out ); LD \u0026lt;= sec_out(3 downto 0); PWM0 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(0), q =\u0026gt; led5_r); PWM1 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(1), q =\u0026gt; led5_g); PWM2 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(2), q =\u0026gt; led5_b); PWM3 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(3), q =\u0026gt; led6_r); PWM4 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(4), q =\u0026gt; led6_g); PWM5 : pwm port map(clk =\u0026gt; clk, a =\u0026gt; \u0026#34;1100\u0026#34;, d =\u0026gt; msec_out(5), q =\u0026gt; led6_b); end RTL;   stopwatchモジュールを実装して，完成させてみましょう．\nシリアル通信に挑戦してみよう 最近のパソコンの外部機器のI/OのほとんどはUSBです．ノート・パソコンは勿論，省スペースのデスクトップ・パソコンにさえ，RS-232-Cのシリアル通信のポートが搭載されなくなってきました．それでも，送信と受信の2本で通信可能なRS-232-Cは，パソコンとFPGAの間やFPGAとFPGAの間でデータを手軽にやりとりする手段として基本的かつ必要不可欠な存在です．\nシリアル・ポートのないノート・パソコンでも，市販のUSB-シリアル変換ケーブルやBluetooth-シリアル変換モジュールを使って簡単に接続できます．\nシリアル通信のしくみ シリアル通信では，受信と送信で独立したポートを持ちます．機器を直結する場合には，お互いの送受信ポートをクロスして結線します(図\\ref{fig:serial_comm})．\n 図l: シリアル通信の結線\n  RS-232-Cでは，図\\ref{fig:serial_comm_format}のように，8ビットのデータにスタート・ビット（\u0026rsquo;0\u0026rsquo;）とストップ・ビット（\u0026rsquo;1\u0026rsquo;）を付加してデータを通信します．接続した機器同士であらかじめ決めた速度(たとえば19200bpsなど)で信号を送受信することで，共通したクロックを持つことなくデータの送受信ができます．\n 図2: シリアル通信の信号の伝送方式\n  送信モジュール 決められた速度で信号をパタパタと変化させるだけです．ただし，一般に，シリアル通信の速度は回路の動作クロックに対して，とても遅いので，データを送信している途中に送るべき信号を更新してしまわないようにブロックする仕組みが必要です．VHDLによる実装例を示します．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity uart_tx is -- 定数宣言 generic ( sys_clk : integer := 14000000; --クロック周波数 rate : integer := 9600 --転送レート,単位はbps(ビット毎秒) ); -- 入出力ポート宣言 port ( clk : in std_logic; -- クロック reset : in std_logic; -- リセット wr : in std_logic; -- 送信要求 din : in std_logic_vector(7 downto 0); --送信データ dout : out std_logic; --シリアル出力 ready : out std_logic --送信要求を受け付けられるか ); end uart_tx; architecture rtl of uart_tx is -- クロック分周モジュールの呼び出しの準備 component clk_div is port (clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic); end component; -- 内部変数定義 signal in_din : std_logic_vector(7 downto 0); -- 送信データ一時保存用レジスタ signal buf : std_logic_vector(7 downto 0); -- 一時的にしようするバッファ signal load : std_logic := \u0026#39;0\u0026#39;; -- 送信データを読み込んだかどうか signal cbit : unsigned(2 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); -- 送信するビット番号 signal run : std_logic := \u0026#39;0\u0026#39;; -- 送信状態にあるかどうか signal tx_en : std_logic; -- 送信用クロック signal tx_en_d : std_logic := \u0026#39;0\u0026#39;; -- 送信用クロックの立ち上がり検出用 signal tx_div : std_logic_vector(15 downto 0); -- クロック分周の倍率 signal status : unsigned(1 downto 0); -- 状態遷移用レジスタ begin -- クロック分周モジュールの呼び出し -- clk_divの入出力ポートにこのモジュールの内部変数を接続 tx_div \u0026lt;= std_logic_vector(to_unsigned((sys_clk / rate) - 1, 16)); U0 : clk_div port map (clk=\u0026gt;clk, rst=\u0026gt;reset, div=\u0026gt;tx_div, clk_out=\u0026gt;tx_en); -- readyへの代入, 常時値を更新している ready \u0026lt;= \u0026#39;1\u0026#39; when (wr = \u0026#39;0\u0026#39; and run = \u0026#39;0\u0026#39; and load = \u0026#39;0\u0026#39;) else \u0026#39;0\u0026#39;; process(clk) --変化を監視する信号を記述する, この場合クロック begin if rising_edge(clk) then --クロックの立ち上がり時の動作 if reset = \u0026#39;1\u0026#39; then --リセット時の動作, 初期値の設定 load \u0026lt;= \u0026#39;0\u0026#39;; else if(wr = \u0026#39;1\u0026#39; and run = \u0026#39;0\u0026#39;) then --送信要求があり，かつ送信中でない場合 load \u0026lt;= \u0026#39;1\u0026#39;; --データを取り込んだフラグを立てる in_din \u0026lt;= din; --一時保存用レジスタに値を格納 end if; if(load = \u0026#39;1\u0026#39; and run = \u0026#39;1\u0026#39;) then --送信中で，かつデータを取り込んだ --ことを示すフラグが立っている場合 load \u0026lt;= \u0026#39;0\u0026#39;; --データを取り込んだフラグを下げる end if; end if; end if; end process; process(clk) --変化を監視する信号(クロック) begin if rising_edge(clk) then if reset = \u0026#39;1\u0026#39; then --リセット時の動作, 初期値の設定 dout \u0026lt;= \u0026#39;1\u0026#39;; cbit \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); status \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); run \u0026lt;= \u0026#39;0\u0026#39;; tx_en_d \u0026lt;= \u0026#39;0\u0026#39;; else tx_en_d \u0026lt;= tx_en; if tx_en = \u0026#39;1\u0026#39; and tx_en_d = \u0026#39;0\u0026#39; then -- tx_enの立ち上がりで動作 case to_integer(status) is --statusの値に応じて動作が異なる when 0 =\u0026gt; --初期状態 cbit \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); --カウンタをクリア if load = \u0026#39;1\u0026#39; then -- データを取り込んでいる場合 dout \u0026lt;= \u0026#39;0\u0026#39;; -- スタートビット0を出力 status \u0026lt;= status + 1; -- 次の状態へ buf \u0026lt;= in_din; -- 送信データを一時バッファに退避 run \u0026lt;= \u0026#39;1\u0026#39;; -- 送信中の状態へ遷移 else --なにもしない状態へ遷移 dout \u0026lt;= \u0026#39;1\u0026#39;; run \u0026lt;= \u0026#39;0\u0026#39;; --送信要求受付可能状態へ end if; when 1 =\u0026gt; --データをLSBから順番に送信 cbit \u0026lt;= cbit + 1; -- カウンタをインクリメント dout \u0026lt;= buf(to_integer(cbit)); --一時バッファのcbit目を取出して出力 if(to_integer(cbit) = 7) then -- データの8ビット目を送信したら, -- ストップビットを送る状態へ遷移 status \u0026lt;= status + 1; end if; when 2 =\u0026gt; -- ストップビットを送信 dout \u0026lt;= \u0026#39;1\u0026#39;; --ストップビット1 status \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); --初期状態へ when others =\u0026gt; --その他の状態の場合 status \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); -- 初期状態へ遷移 end case; end if; end if; end if; end process; end rtl;   内部で利用しているclk_divの実装は次の通りです．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  library ieee; use ieee.std_logic_1164.ALL; use ieee.numeric_std.all; entity clk_div is port( clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic ); end clk_div; architecture RTL of clk_div is signal counter : unsigned(15 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); begin process(clk) begin if(clk\u0026#39;event and clk = \u0026#39;1\u0026#39;) then if(rst = \u0026#39;1\u0026#39;) then counter \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); elsif (counter = unsigned(div)) then counter \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); clk_out \u0026lt;= \u0026#39;1\u0026#39;; else counter \u0026lt;= counter + 1; clk_out \u0026lt;= \u0026#39;0\u0026#39;; end if; end if; end process; end RTL;   clk_divモジュールで生成した，シリアル送信用の信号にあわせて，送信すべきデータを1bitずつ出力します． また，出力中はready信号を'0'にすることで，送信モジュールが動作中であることを上位のモジュールに伝えられるようになっています．\nこのモジュールの動作をシミュレーションで確認してみましょう．\n受信モジュール 受信モジュールは送信モジュールに比べて少し複雑になります．送信側は自分のタイミングで信号を送ればいいのに対し，受信側ではスタート・ビットを頼りにデータの開始を検出し，以降の信号を正しい間隔でビットに分割しなければならないからです．また，データにはノイズが乗っている可能性もあるので，データを正しく取得する仕組みも必要です． VHDLとVerilog HDLによる実装の例が次のリストです．この例では，通信速度の16倍のクロックでデータをサンプリング（一定間隔で読み込む）することで，データを受信しています．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity uart_rx is -- 定数宣言 generic( sys_clk : integer := 14000000; --クロック周波数 rate : integer := 9600 --転送レート,単位はbps(ビット毎秒) ); -- 入出力ポート宣言 port( clk : in std_logic; -- クロック reset : in std_logic; -- リセット din : in std_logic; -- シリアル入力 rd : out std_logic; -- 受信完了を示す dout : out std_logic_vector(7 downto 0) -- 受信データ ); end uart_rx; architecture rtl of uart_rx is --クロック分周モジュールのインスタンス生成の準備 component clk_div is port( clk : in std_logic; rst : in std_logic; div : in std_logic_vector(15 downto 0); clk_out : out std_logic ); end component; --内部変数宣言 signal buf : std_logic_vector(7 downto 0); --受信データ系列の一時保存用 signal receiving : std_logic; --受信しているかどうか signal cbit : integer range 0 to 150; -- データの取り込みタイミング用カウンタ signal rx_en : std_logic; --受信用クロック signal rx_en_d : std_logic := \u0026#39;0\u0026#39;; --受信用クロック立ち上がり判定用レジスタ signal rx_div : std_logic_vector(15 downto 0); --クロック分周の倍率 begin --クロック分周モジュールのインスタンス生成 --受信側は送信側の16倍の速度で値を取り込み処理を行う rx_div \u0026lt;= std_logic_vector(to_unsigned(((sys_clk / rate) / 16) - 1, 16)); U0 : clk_div port map (clk=\u0026gt;clk, rst=\u0026gt;reset, div=\u0026gt;rx_div, clk_out=\u0026gt;rx_en); process(clk) --変化を監視する信号を記述,この場合クロック begin if rising_edge(clk) then if reset = \u0026#39;1\u0026#39; then --リセット時の動作, 初期値の設定 receiving \u0026lt;= \u0026#39;0\u0026#39;; cbit \u0026lt;= 0; buf \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); dout \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); rd \u0026lt;= \u0026#39;0\u0026#39;; rx_en_d \u0026lt;= \u0026#39;0\u0026#39;; else rx_en_d \u0026lt;= rx_en; if rx_en = \u0026#39;1\u0026#39; and rx_en_d = \u0026#39;0\u0026#39; then --受信用クロック立ち上がり時の動作 if receiving = \u0026#39;0\u0026#39; then --受信中でない場合 if din = \u0026#39;0\u0026#39; then --スタートビット0を受信したら rd \u0026lt;= \u0026#39;0\u0026#39;; --受信完了のフラグをさげる receiving \u0026lt;= \u0026#39;1\u0026#39;; end if; else --受信中の場合 case cbit is --カウンタに合わせてデータをラッチ when 6 =\u0026gt; -- スタートビットのチェック if din = \u0026#39;1\u0026#39; then -- スタートビットが中途半端．入力をキャンセル receiving \u0026lt;= \u0026#39;0\u0026#39;; cbit \u0026lt;= 0; else cbit \u0026lt;= cbit + 1; end if; when 22 | 38 | 54 | 70 | 86 | 102 | 118 | 134 =\u0026gt; --data cbit \u0026lt;= cbit + 1; buf \u0026lt;= din \u0026amp; buf(7 downto 1); -- 新しい入力と受信済みデータを連結 when 150 =\u0026gt; --stop rd \u0026lt;= \u0026#39;1\u0026#39;; dout \u0026lt;= buf; receiving \u0026lt;= \u0026#39;0\u0026#39;; -- 受信完了 cbit \u0026lt;= 0; when others =\u0026gt; cbit \u0026lt;= cbit + 1; end case; end if; end if; end if; end if; end process; end RTL;   通信速度の16倍でデータをサンプリングしているので，スタート・ビットは16サイクル分が取得できるはずです．スタートビットのはじまりと思われる\u0026rsquo;0\u0026rsquo;というデータを確認してから6サイクル目のデータをもう一度取得し，そのデータがやっぱり\u0026rsquo;0\u0026rsquo;であれば，データ送信が開始されたと解釈します（ソース・コード中の状態1）．データが送信されていることを確認した後は，16サイクル毎にデータを取得します（ソース・コード中の状態2）．8bit分データを取得したら完了です．\n送信モジュールと同じように，テストベンチを書いてシミュレーションで動作を確認してみましょう．\n実機で動作確認 シリアル通信を実機で動作確認してみましょう．入出力にPMODコネクタJEの1ピンと7ピンを割当て，物理的に両者をジャンパピンで接続すれば，通信ができるはずです．動作をILAを使って確認してみましょう．{\\bf 注意: PMODコネクタの6ピンと12ピンは3.3V，5ピンと11ピンはGNDです．間違って6ピンと5ピンなどのように3.3VとGNDを直結しないようにしましょう．}\n 図3: PMODコネクタのJEの1ピンと7ピンをジャンパケーブルで接続した様子\n  音声信号を観測してみよう ZYBO Z7-20には音声入出力用のジャックが備わっています．これを利用すると外部からの音声信号を取り込みFPGAで処理することができます．信号は，SSM2603というICでA/D変換されます．SSM2603とFPGAはI2Sで音声データをやりとりすることができます．\nSSM2603とやりとりするI2S信号は図\\ref{fig:ssm2603_protocol}の通りです．\n 図4: SSM2603との通信インターフェース\n  これを送受信するモジュールを実装して音声信号の入出力をやってみましょう． でてくる信号が少し増えて複雑にみえるかもしれませんが，方針はRS-232-Cの送受信と同じです．\nI2Sの送信 次のリストは，I2Sの送信モジュールの実装例です．シミュレーションによって，信号が図\\ref{fig:ssm2603_protocol}に示したように出力されることを確認してみましょう．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity i2s_encoder is generic ( WIDTH : integer := 24 ); port ( CLK : in std_logic; -- BCLK 4x BCLK : in std_logic; LRC : in std_logic; DAT : out std_logic; LIN : in std_logic_vector(WIDTH-1 downto 0); RIN : in std_logic_vector(WIDTH-1 downto 0) ); end entity i2s_encoder; architecture RTL of i2s_encoder is attribute mark_debug : string; signal left_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal left_cnt : unsigned(7 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal right_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal right_cnt : unsigned(7 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal lrc_d : std_logic := \u0026#39;0\u0026#39;; signal bclk_d : std_logic := \u0026#39;0\u0026#39;; attribute mark_debug of left_data : signal is \u0026#34;true\u0026#34;; attribute mark_debug of left_cnt : signal is \u0026#34;true\u0026#34;; attribute mark_debug of right_data : signal is \u0026#34;true\u0026#34;; attribute mark_debug of right_cnt : signal is \u0026#34;true\u0026#34;; begin process(CLK) begin if rising_edge(CLK) then lrc_d \u0026lt;= LRC; bclk_d \u0026lt;= BCLK; if lrc_d = \u0026#39;1\u0026#39; and LRC = \u0026#39;0\u0026#39; then left_cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); left_data \u0026lt;= LIN; else if left_cnt \u0026lt;= 4*WIDTH-1 then left_cnt \u0026lt;= left_cnt + 1; if 3 \u0026lt;= left_cnt then DAT \u0026lt;= left_data(WIDTH-1); if left_cnt(1 downto 0) = \u0026#34;10\u0026#34; then left_data \u0026lt;= left_data(WIDTH-2 downto 0) \u0026amp; \u0026#39;0\u0026#39;; end if; end if; end if; end if; if lrc_d = \u0026#39;0\u0026#39; and LRC = \u0026#39;1\u0026#39; then right_cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); right_data \u0026lt;= RIN; else if right_cnt \u0026lt;= 4*WIDTH-1 then right_cnt \u0026lt;= right_cnt + 1; if 3 \u0026lt;= right_cnt then DAT \u0026lt;= right_data(WIDTH-1); if right_cnt(1 downto 0) = \u0026#34;10\u0026#34; then right_data \u0026lt;= right_data(WIDTH-2 downto 0) \u0026amp; \u0026#39;0\u0026#39;; end if; end if; end if; end if; end if; end process; end RTL;   I2Sの受信 次は受信モジュールです．送信モジュールと組み合わせてシミュレーションすることで，入力した音声信号をI2Sフォーマットに変換し，それが復号される様を観測することができます．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity i2s_decoder is generic ( WIDTH : integer := 24 ); port ( CLK : in std_logic; BCLK : in std_logic; LRC : in std_logic; DAT : in std_logic; LOUT : out std_logic_vector(WIDTH-1 downto 0); ROUT : out std_logic_vector(WIDTH-1 downto 0); LOUT_VALID : out std_logic; ROUT_VALID : out std_logic ); end entity i2s_decoder; architecture RTL of i2s_decoder is attribute mark_debug : string; signal left_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal left_cnt : unsigned(5 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal left_valid : std_logic := \u0026#39;0\u0026#39;; signal right_data : std_logic_vector(WIDTH-1 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal right_cnt : unsigned(5 downto 0) := (others =\u0026gt; \u0026#39;0\u0026#39;); signal right_valid : std_logic := \u0026#39;0\u0026#39;; signal lrc_d : std_logic := \u0026#39;0\u0026#39;; attribute mark_debug of left_data : signal is \u0026#34;true\u0026#34;; attribute mark_debug of left_valid : signal is \u0026#34;true\u0026#34;; attribute mark_debug of left_cnt : signal is \u0026#34;true\u0026#34;; attribute mark_debug of right_data : signal is \u0026#34;true\u0026#34;; attribute mark_debug of right_valid : signal is \u0026#34;true\u0026#34;; attribute mark_debug of right_cnt : signal is \u0026#34;true\u0026#34;; signal bclk_d : std_logic := \u0026#39;0\u0026#39;; begin LOUT_VALID \u0026lt;= left_valid; ROUT_VALID \u0026lt;= right_valid; LOUT \u0026lt;= left_data; ROUT \u0026lt;= right_data; process(CLK) begin if rising_edge(CLK) then bclk_d \u0026lt;= BCLK; if bclk_d = \u0026#39;0\u0026#39; and BCLK = \u0026#39;1\u0026#39; then left_data \u0026lt;= left_data(WIDTH-2 downto 0) \u0026amp; DAT; right_data \u0026lt;= right_data(WIDTH-2 downto 0) \u0026amp; DAT; lrc_d \u0026lt;= LRC; if lrc_d = \u0026#39;1\u0026#39; and LRC = \u0026#39;0\u0026#39; then left_cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); else if left_cnt = WIDTH-1 then left_valid \u0026lt;= \u0026#39;1\u0026#39;; else left_valid \u0026lt;= \u0026#39;0\u0026#39;; end if; if left_cnt \u0026lt;= WIDTH-1 then left_cnt \u0026lt;= left_cnt + 1; end if; end if; if lrc_d = \u0026#39;0\u0026#39; and LRC = \u0026#39;1\u0026#39; then right_cnt \u0026lt;= (others =\u0026gt; \u0026#39;0\u0026#39;); else if right_cnt = WIDTH-1 then right_valid \u0026lt;= \u0026#39;1\u0026#39;; else right_valid \u0026lt;= \u0026#39;0\u0026#39;; end if; if right_cnt \u0026lt;= WIDTH-1 then right_cnt \u0026lt;= right_cnt + 1; end if; end if; end if; end if; end process; end RTL;   発展 紹介したアプリケーション実験を応用して，次のような課題に挑戦してみましょう．\n ストップウォッチモジュールを改造して，カウントダウンできるようにしてみましょう． いろいろな通信速度でRS-232-C通信を試してみましょう． 音声入出力ができるようになったので，たとえば，規定値より大きな値がきたときだけ音声を出力する，平滑化フィルタで音を滑らかにする，などが簡単には考えられるでしょう．  "});index.add({'id':8,'href':'/learning_fpga/docs/book03/ipi/','title':"IP Integrator入門",'content':"Vivado IP Integratorを使った，IPベースの設計手法を身につけてみましょう．大規模かつ複雑なデザインも小さな部品を組み合わせるボトムアップ設計で開発効率の向上が図れます．\n"});index.add({'id':9,'href':'/learning_fpga/docs/book03/','title':"Xilinx活用編",'content':""});index.add({'id':10,'href':'/learning_fpga/','title':"Top",'content':" Learning FPGA RTL編  イントロダクション VHDL/Verilog 入門 クイックスタート シミュレーション 基本実験 実験  高位合成編  高位合成とは？ VivadoHLSを使ったCベース設計に挑戦 Vivado HLS基本実験 Vivado HLS応用実験  Xilinx活用編  ZYNQ入門 プロセッサをベアメタルで使用する PetaLinuxを使ってみる Ubuntuを使ってみる PYNQによるFPGA利用方法 IP Integrator入門  "});index.add({'id':11,'href':'/learning_fpga/docs/book01/introduction_figures/readme/','title':"R E a D M E",'content':""});index.add({'id':12,'href':'/learning_fpga/categories/','title':"Categories",'content':""});index.add({'id':13,'href':'/learning_fpga/docs/','title':"Docs",'content':""});index.add({'id':14,'href':'/learning_fpga/tags/','title':"Tags",'content':""});})();